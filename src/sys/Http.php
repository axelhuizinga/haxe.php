<?php
/**
 * Generated by Haxe 4.1.1
 */

namespace sys;

use \php\_Boot\HxAnon;
use \haxe\io\_BytesData\Container;
use \php\net\SslSocket;
use \php\Boot;
use \haxe\io\BytesOutput;
use \sys\net\Socket;
use \haxe\Exception;
use \haxe\io\Output;
use \haxe\io\Eof;
use \haxe\io\BytesBuffer;
use \haxe\io\Error;
use \haxe\http\HttpBase;
use \haxe\io\Input;
use \php\_Boot\HxString;
use \sys\net\Host;
use \haxe\ds\StringMap;
use \haxe\io\Bytes;
use \haxe\NativeStackTrace;

class Http extends HttpBase {
	/**
	 * @var object
	 */
	static public $PROXY = null;

	/**
	 * @var Bytes
	 */
	public $chunk_buf;
	/**
	 * @var int
	 */
	public $chunk_size;
	/**
	 * @var float
	 */
	public $cnxTimeout;
	/**
	 * @var object
	 */
	public $file;
	/**
	 * @var bool
	 */
	public $noShutdown;
	/**
	 * @var StringMap
	 */
	public $responseHeaders;

	/**
	 * Makes a synchronous request to `url`.
	 * This creates a new Http instance and makes a GET request by calling its
	 * `request(false)` method.
	 * If `url` is null, the result is unspecified.
	 * 
	 * @param string $url
	 * 
	 * @return string
	 */
	public static function requestUrl ($url) {
		$h = new Http($url);
		$r = null;
		$h->onData = function ($d) use (&$r) {
			$r = $d;
		};
		$h->onError = function ($e) {
			throw Exception::thrown($e);
		};
		$h->request(false);
		return $r;
	}

	/**
	 * @param string $url
	 * 
	 * @return void
	 */
	public function __construct ($url) {
		$this->cnxTimeout = 10;
		$this->noShutdown = !function_exists("stream_socket_shutdown");
		parent::__construct($url);
	}

	/**
	 * @param bool $post
	 * @param Output $api
	 * @param Socket $sock
	 * @param string $method
	 * 
	 * @return void
	 */
	public function customRequest ($post, $api, $sock = null, $method = null) {
		$this->responseAsString = null;
		$this->responseBytes = null;
		$url_regexp = new \EReg("^(https?://)?([a-zA-Z\\.0-9_-]+)(:[0-9]+)?(.*)\$", "");
		if (!$url_regexp->match($this->url)) {
			$this->onError("Invalid URL");
			return;
		}
		$secure = $url_regexp->matched(1) === "https://";
		if ($sock === null) {
			if ($secure) {
				$sock = new SslSocket();
			} else {
				$sock = new Socket();
			}
			$sock->setTimeout($this->cnxTimeout);
		}
		$host = $url_regexp->matched(2);
		$portString = $url_regexp->matched(3);
		$request = $url_regexp->matched(4);
		if (mb_substr($request, 0, 1) !== "/") {
			$request = "/" . ($request??'null');
		}
		$port = (($portString === null) || ($portString === "") ? ($secure ? 443 : 80) : \Std::parseInt(mb_substr($portString, 1, mb_strlen($portString) - 1)));
		$multipart = $this->file !== null;
		$boundary = null;
		$uri = null;
		if ($multipart) {
			$post = true;
			$boundary = (\Std::string(mt_rand(0, 999))??'null') . (\Std::string(mt_rand(0, 999))??'null') . (\Std::string(mt_rand(0, 999))??'null') . (\Std::string(mt_rand(0, 999))??'null');
			while (mb_strlen($boundary) < 38) {
				$boundary = "-" . ($boundary??'null');
			}
			$b = new \StringBuf();
			$_g = 0;
			$_g1 = $this->params;
			while ($_g < $_g1->length) {
				$p = ($_g1->arr[$_g] ?? null);
				++$_g;
				$b->add("--");
				$b->add($boundary);
				$b->add("\x0D\x0A");
				$b->add("Content-Disposition: form-data; name=\"");
				$b->add($p->name);
				$b->add("\"");
				$b->add("\x0D\x0A");
				$b->add("\x0D\x0A");
				$b->add($p->value);
				$b->add("\x0D\x0A");
			}
			$b->add("--");
			$b->add($boundary);
			$b->add("\x0D\x0A");
			$b->add("Content-Disposition: form-data; name=\"");
			$b->add($this->file->param);
			$b->add("\"; filename=\"");
			$b->add($this->file->filename);
			$b->add("\"");
			$b->add("\x0D\x0A");
			$b->add("Content-Type: " . ($this->file->mimeType??'null') . "\x0D\x0A" . "\x0D\x0A");
			$uri = $b->b;
		} else {
			$_g = 0;
			$_g1 = $this->params;
			while ($_g < $_g1->length) {
				$p = ($_g1->arr[$_g] ?? null);
				++$_g;
				if ($uri === null) {
					$uri = "";
				} else {
					$uri = ($uri??'null') . "&";
				}
				$uri = ($uri??'null') . (rawurlencode($p->name)??'null') . "=" . (rawurlencode("" . ($p->value??'null'))??'null');
			}
		}
		$b = new BytesOutput();
		if ($method !== null) {
			$b->writeString($method);
			$b->writeString(" ");
		} else if ($post) {
			$b->writeString("POST ");
		} else {
			$b->writeString("GET ");
		}
		if (Http::$PROXY !== null) {
			$b->writeString("http://");
			$b->writeString($host);
			if ($port !== 80) {
				$b->writeString(":");
				$b->writeString("" . ($port??'null'));
			}
		}
		$b->writeString($request);
		if (!$post && ($uri !== null)) {
			if (HxString::indexOf($request, "?", 0) >= 0) {
				$b->writeString("&");
			} else {
				$b->writeString("?");
			}
			$b->writeString($uri);
		}
		$b->writeString(" HTTP/1.1\x0D\x0AHost: " . ($host??'null') . "\x0D\x0A");
		if ($this->postData !== null) {
			$s = $this->postData;
			$tmp = strlen($s);
			$this->postBytes = new Bytes($tmp, new Container($s));
			$this->postData = null;
		}
		if ($this->postBytes !== null) {
			$b->writeString("Content-Length: " . ($this->postBytes->length??'null') . "\x0D\x0A");
		} else if ($post && ($uri !== null)) {
			if ($multipart || !\Lambda::exists($this->headers, function ($h) {
				return $h->name === "Content-Type";
			})) {
				$b->writeString("Content-Type: ");
				if ($multipart) {
					$b->writeString("multipart/form-data");
					$b->writeString("; boundary=");
					$b->writeString($boundary);
				} else {
					$b->writeString("application/x-www-form-urlencoded");
				}
				$b->writeString("\x0D\x0A");
			}
			if ($multipart) {
				$b->writeString("Content-Length: " . (mb_strlen($uri) + $this->file->size + mb_strlen($boundary) + 6) . "\x0D\x0A");
			} else {
				$b->writeString("Content-Length: " . (mb_strlen($uri)??'null') . "\x0D\x0A");
			}
		}
		$b->writeString("Connection: close\x0D\x0A");
		$_g = 0;
		$_g1 = $this->headers;
		while ($_g < $_g1->length) {
			$h = ($_g1->arr[$_g] ?? null);
			++$_g;
			$b->writeString($h->name);
			$b->writeString(": ");
			$b->writeString($h->value);
			$b->writeString("\x0D\x0A");
		}
		$b->writeString("\x0D\x0A");
		if ($this->postBytes !== null) {
			$b->writeFullBytes($this->postBytes, 0, $this->postBytes->length);
		} else if ($post && ($uri !== null)) {
			$b->writeString($uri);
		}
		try {
			if (Http::$PROXY !== null) {
				$sock->connect(new Host(Http::$PROXY->host), Http::$PROXY->port);
			} else {
				$sock->connect(new Host($host), $port);
			}
			if ($multipart) {
				$this->writeBody($b, $this->file->io, $this->file->size, $boundary, $sock);
			} else {
				$this->writeBody($b, null, 0, null, $sock);
			}
			$this->readHttpResponse($api, $sock);
			$sock->close();
		} catch(\Throwable $_g) {
			NativeStackTrace::saveStack($_g);
			$_g1 = Exception::caught($_g)->unwrap();
			try {
				$sock->close();
			} catch(\Throwable $_g) {
			}
			$this->onError(\Std::string($_g1));
		}
	}

	/**
	 * @param string $argname
	 * @param string $filename
	 * @param Input $file
	 * @param int $size
	 * @param string $mimeType
	 * 
	 * @return void
	 */
	public function fileTransfer ($argname, $filename, $file, $size, $mimeType = "application/octet-stream") {
		if ($mimeType === null) {
			$mimeType = "application/octet-stream";
		}
		$this->file = new HxAnon([
			"param" => $argname,
			"filename" => $filename,
			"io" => $file,
			"size" => $size,
			"mimeType" => $mimeType,
		]);
	}

	/**
	 * @param string $argname
	 * @param string $filename
	 * @param Input $file
	 * @param int $size
	 * @param string $mimeType
	 * 
	 * @return void
	 */
	public function fileTransfert ($argname, $filename, $file, $size, $mimeType = "application/octet-stream") {
		if ($mimeType === null) {
			$mimeType = "application/octet-stream";
		}
		$this->fileTransfer($argname, $filename, $file, $size, $mimeType);
	}

	/**
	 * @param \EReg $chunk_re
	 * @param Output $api
	 * @param Bytes $buf
	 * @param int $len
	 * 
	 * @return bool
	 */
	public function readChunk ($chunk_re, $api, $buf, $len) {
		if ($this->chunk_size === null) {
			if ($this->chunk_buf !== null) {
				$b = new BytesBuffer();
				$b->b = ($b->b . $this->chunk_buf->b->s);
				if (($len < 0) || ($len > $buf->length)) {
					throw Exception::thrown(Error::OutsideBounds());
				} else {
					$b->b = ($b->b . substr($buf->b->s, 0, $len));
				}
				$buf = $b->getBytes();
				$len += $this->chunk_buf->length;
				$this->chunk_buf = null;
			}
			if ($chunk_re->match($buf->toString())) {
				$p = $chunk_re->matchedPos();
				if ($p->len <= $len) {
					$this->chunk_size = \Std::parseInt("0x" . ($chunk_re->matched(1)??'null'));
					if ($this->chunk_size === 0) {
						$this->chunk_size = null;
						$this->chunk_buf = null;
						return false;
					}
					$len -= $p->len;
					$pos = $p->len;
					$tmp = null;
					if (($pos < 0) || ($len < 0) || (($pos + $len) > $buf->length)) {
						throw Exception::thrown(Error::OutsideBounds());
					} else {
						$tmp = new Bytes($len, new Container(substr($buf->b->s, $pos, $len)));
					}
					return $this->readChunk($chunk_re, $api, $tmp, $len);
				}
			}
			if ($len > 10) {
				$this->onError("Invalid chunk");
				return false;
			}
			$tmp = null;
			if (($len < 0) || ($len > $buf->length)) {
				throw Exception::thrown(Error::OutsideBounds());
			} else {
				$tmp = new Bytes($len, new Container(substr($buf->b->s, 0, $len)));
			}
			$this->chunk_buf = $tmp;
			return true;
		}
		if ($this->chunk_size > $len) {
			$this->chunk_size -= $len;
			$api->writeBytes($buf, 0, $len);
			return true;
		}
		$end = $this->chunk_size + 2;
		if ($len >= $end) {
			if ($this->chunk_size > 0) {
				$api->writeBytes($buf, 0, $this->chunk_size);
			}
			$len -= $end;
			$this->chunk_size = null;
			if ($len === 0) {
				return true;
			}
			$tmp = null;
			if (($end < 0) || ($len < 0) || (($end + $len) > $buf->length)) {
				throw Exception::thrown(Error::OutsideBounds());
			} else {
				$tmp = new Bytes($len, new Container(substr($buf->b->s, $end, $len)));
			}
			return $this->readChunk($chunk_re, $api, $tmp, $len);
		}
		if ($this->chunk_size > 0) {
			$api->writeBytes($buf, 0, $this->chunk_size);
		}
		$this->chunk_size -= $len;
		return true;
	}

	/**
	 * @param Output $api
	 * @param Socket $sock
	 * 
	 * @return void
	 */
	public function readHttpResponse ($api, $sock) {
		$b = new BytesBuffer();
		$k = 4;
		$s = Bytes::alloc(4);
		$sock->setTimeout($this->cnxTimeout);
		while (true) {
			$p = $sock->input->readBytes($s, 0, $k);
			while ($p !== $k) {
				$p += $sock->input->readBytes($s, $p, $k - $p);
			}
			if (($k < 0) || ($k > $s->length)) {
				throw Exception::thrown(Error::OutsideBounds());
			} else {
				$b->b = ($b->b . substr($s->b->s, 0, $k));
			}
			if ($k === 1) {
				$c = ord($s->b->s[0]);
				if ($c === 10) {
					break;
				}
				if ($c === 13) {
					$k = 3;
				} else {
					$k = 4;
				}
			} else if ($k === 2) {
				$c1 = ord($s->b->s[1]);
				if ($c1 === 10) {
					if (ord($s->b->s[0]) === 13) {
						break;
					}
					$k = 4;
				} else if ($c1 === 13) {
					$k = 3;
				} else {
					$k = 4;
				}
			} else if ($k === 3) {
				$c2 = ord($s->b->s[2]);
				if ($c2 === 10) {
					if (ord($s->b->s[1]) !== 13) {
						$k = 4;
					} else if (ord($s->b->s[0]) !== 10) {
						$k = 2;
					} else {
						break;
					}
				} else if ($c2 === 13) {
					if ((ord($s->b->s[1]) !== 10) || (ord($s->b->s[0]) !== 13)) {
						$k = 1;
					} else {
						$k = 3;
					}
				} else {
					$k = 4;
				}
			} else if ($k === 4) {
				$c3 = ord($s->b->s[3]);
				if ($c3 === 10) {
					if (ord($s->b->s[2]) !== 13) {
						continue;
					} else if ((ord($s->b->s[1]) !== 10) || (ord($s->b->s[0]) !== 13)) {
						$k = 2;
					} else {
						break;
					}
				} else if ($c3 === 13) {
					if ((ord($s->b->s[2]) !== 10) || (ord($s->b->s[1]) !== 13)) {
						$k = 3;
					} else {
						$k = 1;
					}
				}
			}
		};
		$headers = HxString::split($b->getBytes()->toString(), "\x0D\x0A");
		if ($headers->length > 0) {
			$headers->length--;
		}
		$status = \Std::parseInt((HxString::split(array_shift($headers->arr), " ")->arr[1] ?? null));
		if (($status === 0) || ($status === null)) {
			throw Exception::thrown("Response status error");
		}
		if ($headers->length > 0) {
			$headers->length--;
		}
		array_pop($headers->arr);
		if ($headers->length > 0) {
			$headers->length--;
		}
		array_pop($headers->arr);
		$this->responseHeaders = new StringMap();
		$size = null;
		$chunked = false;
		$_g = 0;
		while ($_g < $headers->length) {
			$a = HxString::split(($headers->arr[$_g++] ?? null), ": ");
			if ($a->length > 0) {
				$a->length--;
			}
			$hname = array_shift($a->arr);
			$hval = ($a->length === 1 ? ($a->arr[0] ?? null) : $a->join(": "));
			$hval = ltrim(rtrim($hval));
			$this->responseHeaders->data[$hname] = $hval;
			$__hx__switch = (mb_strtolower($hname));
			if ($__hx__switch === "content-length") {
				$size = \Std::parseInt($hval);
			} else if ($__hx__switch === "transfer-encoding") {
				$chunked = mb_strtolower($hval) === "chunked";
			}
		}
		$this->onStatus($status);
		$chunk_re = new \EReg("^([0-9A-Fa-f]+)[ ]*\x0D\x0A", "m");
		$this->chunk_size = null;
		$this->chunk_buf = null;
		$buf = Bytes::alloc(1024);
		if ($chunked) {
			try {
				while ($this->readChunk($chunk_re, $api, $buf, $sock->input->readBytes($buf, 0, 1024))) {
				}
			} catch(\Throwable $_g) {
				NativeStackTrace::saveStack($_g);
				if ((Exception::caught($_g)->unwrap() instanceof Eof)) {
					throw Exception::thrown("Transfer aborted");
				} else {
					throw $_g;
				}
			}
		} else if ($size === null) {
			if (!$this->noShutdown) {
				$sock->shutdown(false, true);
			}
			try {
				while (true) {
					$len = $sock->input->readBytes($buf, 0, 1024);
					if ($len === 0) {
						break;
					}
					$api->writeBytes($buf, 0, $len);
				}
			} catch(\Throwable $_g) {
				NativeStackTrace::saveStack($_g);
				if (!(Exception::caught($_g)->unwrap() instanceof Eof)) {
					throw $_g;
				}
			}
		} else {
			$api->prepare($size);
			try {
				while ($size > 0) {
					$len = $sock->input->readBytes($buf, 0, ($size > 1024 ? 1024 : $size));
					$api->writeBytes($buf, 0, $len);
					$size -= $len;
				}
			} catch(\Throwable $_g) {
				NativeStackTrace::saveStack($_g);
				if ((Exception::caught($_g)->unwrap() instanceof Eof)) {
					throw Exception::thrown("Transfer aborted");
				} else {
					throw $_g;
				}
			}
		}
		if ($chunked && (($this->chunk_size !== null) || ($this->chunk_buf !== null))) {
			throw Exception::thrown("Invalid chunk");
		}
		if (($status < 200) || ($status >= 400)) {
			throw Exception::thrown("Http Error #" . ($status??'null'));
		}
		$api->close();
	}

	/**
	 * @param bool $post
	 * 
	 * @return void
	 */
	public function request ($post = null) {
		$_gthis = $this;
		$output = new BytesOutput();
		$old = $this->onError;
		$err = false;
		$this->onError = function ($e) use (&$err, &$old, &$_gthis, &$output) {
			$_gthis->responseBytes = $output->getBytes();
			$err = true;
			$_gthis->onError = $old;
			$_gthis->onError($e);
		};
		$post = $post || ($this->postBytes !== null) || ($this->postData !== null);
		$this->customRequest($post, $output);
		if (!$err) {
			$this->success($output->getBytes());
		}
	}

	/**
	 * @param BytesOutput $body
	 * @param Input $fileInput
	 * @param int $fileSize
	 * @param string $boundary
	 * @param Socket $sock
	 * 
	 * @return void
	 */
	public function writeBody ($body, $fileInput, $fileSize, $boundary, $sock) {
		if ($body !== null) {
			$bytes = $body->getBytes();
			$sock->output->writeFullBytes($bytes, 0, $bytes->length);
		}
		if ($boundary !== null) {
			$buf = Bytes::alloc(4096);
			while ($fileSize > 0) {
				$size = ($fileSize > 4096 ? 4096 : $fileSize);
				$len = 0;
				try {
					$len = $fileInput->readBytes($buf, 0, $size);
				} catch(\Throwable $_g) {
					NativeStackTrace::saveStack($_g);
					if ((Exception::caught($_g)->unwrap() instanceof Eof)) {
						break;
					} else {
						throw $_g;
					}
				}
				$sock->output->writeFullBytes($buf, 0, $len);
				$fileSize -= $len;
			}
			$sock->output->writeString("\x0D\x0A");
			$sock->output->writeString("--");
			$sock->output->writeString($boundary);
			$sock->output->writeString("--");
		}
	}
}

Boot::registerClass(Http::class, 'sys.Http');
