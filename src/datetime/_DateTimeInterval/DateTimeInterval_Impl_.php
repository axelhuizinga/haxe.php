<?php
/**
 * Generated by Haxe 4.1.4
 */

namespace datetime\_DateTimeInterval;

use \php\Boot;
use \datetime\cores\DateTimeIntervalCore;
use \datetime\utils\DateTimeIntervalUtils;

final class DateTimeInterval_Impl_ {
	/**
	 * Constructor.
	 *
	 * 
	 * @param DateTimeIntervalCore $dtic
	 * 
	 * @return DateTimeIntervalCore
	 */
	public static function _new ($dtic) {
		return $dtic;
	}

	/**
	 * Add this interval to specified DateTime instance.
	 *
	 * Returns new DateTime.
	 * 
	 * @param DateTimeIntervalCore $this
	 * @param float $dt
	 * 
	 * @return float
	 */
	public static function addTo ($this1, $dt) {
		return $dt - 62135596800.0 + (($this1->negative ? -1 : 1)) * ($this1->end - 62135596800.0 - ($this1->begin - 62135596800.0)) + 62135596800.0;
	}

	/**
	 * Create interval as difference between two DateTime instances
	 *
	 * 
	 * @param float $begin
	 * @param float $end
	 * 
	 * @return DateTimeIntervalCore
	 */
	public static function create ($begin, $end) {
		$dtic = new DateTimeIntervalCore();
		$dtic->begin = (($end - 62135596800.0) < ($begin - 62135596800.0) ? $end : $begin);
		$dtic->end = (($end - 62135596800.0) < ($begin - 62135596800.0) ? $begin : $end);
		$dtic->negative = ($end - 62135596800.0) < ($begin - 62135596800.0);
		return $dtic;
	}

	/**
	 * DateTimeInterval comparison
	 *
	 * 
	 * @param DateTimeIntervalCore $this
	 * @param DateTimeIntervalCore $dtic
	 * 
	 * @return bool
	 */
	public static function eq ($this1, $dtic) {
		if ($this1->negative === $dtic->negative) {
			return Boot::equal($this1->getTotalSeconds(), $dtic->getTotalSeconds());
		} else {
			return false;
		}
	}

	/**
	 * Formats the interval
	 *
	 *   - `%%` Literal %. Example:   %
	 *   - `%Y` Years, numeric, at least 2 digits with leading 0. Example:    01, 03
	 *   - `%y` Years, numeric. Example:  1, 3
	 *   - `%M` Months, numeric, at least 2 digits with leading 0. Example:   01, 03, 12
	 *   - `%m` Months, numeric. Example: 1, 3, 12
	 *   - `%b` Total number of months. Example:   2, 15, 36
	 *   - `%D` Days, numeric, at least 2 digits with leading 0. Example: 01, 03, 31
	 *   - `%d` Days, numeric. Example:   1, 3, 31
	 *   - `%a` Total number of days. Example:   4, 18, 8123
	 *   - `%H` Hours, numeric, at least 2 digits with leading 0. Example:    01, 03, 23
	 *   - `%h` Hours, numeric. Example:  1, 3, 23
	 *   - `%c` Total number of hours. Example:   4, 18, 8123
	 *   - `%I` Minutes, numeric, at least 2 digits with leading 0. Example:  01, 03, 59
	 *   - `%i` Minutes, numeric. Example:    1, 3, 59
	 *   - `%e` Total number of minutes. Example:   4, 18, 8123
	 *   - `%S` Seconds, numeric, at least 2 digits with leading 0. Example:  01, 03, 57
	 *   - `%s` Seconds, numeric. Example:    1, 3, 57
	 *   - `%f` Total number of seconds. Example:   4, 18, 8123
	 *   - `%R` Sign "-" when negative, "+" when positive. Example:   -, +
	 *   - `%r` Sign "-" when negative, empty when positive. Example: -,
	 * 
	 * @param DateTimeIntervalCore $this
	 * @param string $format
	 * 
	 * @return string
	 */
	public static function format ($this1, $format) {
		return DateTimeIntervalUtils::strftime($this1, $format);
	}

	/**
	 * Formats  each string in `format` array. Each string can have only one placeholder.
	 *
	 * Supported placeholders: see `format()` method description except `r,R,%` placeholders.
	 *
	 * Returns new array with elements, whose corresponding strings in `format` array were filled with non-zero values.
	 *
	 * Example: if interval contains 0 years, 2 months and 10 days, then
	 * `interval.format(['%y years', '%m months', '%d days']).join(',')` will return `'2 months, 10 days'`
	 *
	 * 
	 * @param DateTimeIntervalCore $this
	 * @param \Array_hx $format
	 * 
	 * @return \Array_hx
	 */
	public static function formatPartial ($this1, $format) {
		return DateTimeIntervalUtils::formatPartial($this1, $format);
	}

	/**
	 * @param DateTimeIntervalCore $this
	 * @param DateTimeIntervalCore $dtic
	 * 
	 * @return bool
	 */
	public static function gt ($this1, $dtic) {
		if ($this1->negative !== $dtic->negative) {
			return $dtic->negative;
		}
		$delta = $this1->getTotalSeconds() - $dtic->getTotalSeconds();
		if ($this1->negative) {
			return $delta < 0;
		} else {
			return $delta > 0;
		}
	}

	/**
	 * @param DateTimeIntervalCore $this
	 * @param DateTimeIntervalCore $dtic
	 * 
	 * @return bool
	 */
	public static function gte ($this1, $dtic) {
		if (!(($this1->negative === $dtic->negative) && Boot::equal($this1->getTotalSeconds(), $dtic->getTotalSeconds()))) {
			if ($this1->negative !== $dtic->negative) {
				return $dtic->negative;
			} else {
				$delta = $this1->getTotalSeconds() - $dtic->getTotalSeconds();
				if ($this1->negative) {
					return $delta < 0;
				} else {
					return $delta > 0;
				}
			}
		} else {
			return true;
		}
	}

	/**
	 * Invert the sign of this interval. Modifies internal state. Returns itself.
	 *
	 * 
	 * @param DateTimeIntervalCore $this
	 * 
	 * @return DateTimeIntervalCore
	 */
	public static function invert ($this1) {
		$this1->negative = !$this1->negative;
		return $this1;
	}

	/**
	 * @param DateTimeIntervalCore $this
	 * @param DateTimeIntervalCore $dtic
	 * 
	 * @return bool
	 */
	public static function lt ($this1, $dtic) {
		$tmp = null;
		if (!(($this1->negative === $dtic->negative) && Boot::equal($this1->getTotalSeconds(), $dtic->getTotalSeconds()))) {
			if ($this1->negative !== $dtic->negative) {
				$tmp = $dtic->negative;
			} else {
				$delta = $this1->getTotalSeconds() - $dtic->getTotalSeconds();
				$tmp = ($this1->negative ? $delta < 0 : $delta > 0);
			}
		} else {
			$tmp = true;
		}
		return !$tmp;
	}

	/**
	 * @param DateTimeIntervalCore $this
	 * @param DateTimeIntervalCore $dtic
	 * 
	 * @return bool
	 */
	public static function lte ($this1, $dtic) {
		$tmp = null;
		if ($this1->negative !== $dtic->negative) {
			$tmp = $dtic->negative;
		} else {
			$delta = $this1->getTotalSeconds() - $dtic->getTotalSeconds();
			$tmp = ($this1->negative ? $delta < 0 : $delta > 0);
		}
		return !$tmp;
	}

	/**
	 * @param DateTimeIntervalCore $this
	 * @param DateTimeIntervalCore $dtic
	 * 
	 * @return bool
	 */
	public static function neq ($this1, $dtic) {
		return !(($this1->negative === $dtic->negative) && Boot::equal($this1->getTotalSeconds(), $dtic->getTotalSeconds()));
	}

	/**
	 *  Returns -1 if this is a negative interval, +1 otherwise
	 *
	 * 
	 * @param DateTimeIntervalCore $this
	 * 
	 * @return int
	 */
	public static function sign ($this1) {
		if ($this1->negative) {
			return -1;
		} else {
			return 1;
		}
	}

	/**
	 * Substract this interval from specified DateTime instance.
	 *
	 * Returns new DateTime.
	 * 
	 * @param DateTimeIntervalCore $this
	 * @param float $dt
	 * 
	 * @return float
	 */
	public static function subFrom ($this1, $dt) {
		return $dt - 62135596800.0 - (($this1->negative ? -1 : 1)) * ($this1->end - 62135596800.0 - ($this1->begin - 62135596800.0)) + 62135596800.0;
	}

	/**
	 * Get string representation of this interval.
	 *
	 * 
	 * @param DateTimeIntervalCore $this
	 * 
	 * @return string
	 */
	public static function toString ($this1) {
		$years = $this1->getYears();
		$months = $this1->getMonths();
		$days = $this1->getDays();
		$hours = $this1->getHours();
		$minutes = $this1->getMinutes();
		$seconds = $this1->getSeconds();
		$parts = new \Array_hx();
		if ($years !== 0) {
			$parts->arr[$parts->length++] = "" . ($years??'null') . "y";
		}
		if ($months !== 0) {
			$parts->arr[$parts->length++] = "" . ($months??'null') . "m";
		}
		if ($days !== 0) {
			$parts->arr[$parts->length++] = "" . ($days??'null') . "d";
		}
		if ($hours !== 0) {
			$parts->arr[$parts->length++] = "" . ($hours??'null') . "hrs";
		}
		if ($minutes !== 0) {
			$parts->arr[$parts->length++] = "" . ($minutes??'null') . "min";
		}
		if ($seconds !== 0) {
			$parts->arr[$parts->length++] = "" . ($seconds??'null') . "sec";
		}
		return ((($this1->negative ? "-" : ""))??'null') . "(" . ((($parts->length === 0 ? "0sec" : $parts->join(", ")))??'null') . ")";
	}
}

Boot::registerClass(DateTimeInterval_Impl_::class, 'datetime._DateTimeInterval.DateTimeInterval_Impl_');
