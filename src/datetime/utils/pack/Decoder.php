<?php
/**
 * Generated by Haxe 4.1.4
 */

namespace datetime\utils\pack;

use \haxe\io\_BytesData\Container;
use \php\Boot;
use \haxe\Exception;
use \datetime\data\TimezoneData;
use \datetime\utils\DateTimeMonthUtils;
use \datetime\utils\DateTimeUtils;
use \haxe\io\Error;
use \haxe\ds\StringMap;
use \haxe\io\Bytes;

/**
 * Uncompress tz data compressed with tools/TZBuilder
 *
 */
class Decoder {
	/**
	 * Decode string to Bytes
	 *
	 * 
	 * @param string $data
	 * 
	 * @return Bytes
	 */
	public static function decode ($data) {
		$data = base64_decode($data);
		$tmp = \strlen($data);
		return new Bytes($tmp, new Container($data));
	}

	/**
	 * Extract abbreviations dictionary.
	 * Returns position of next byte after last byte of abbreviations dictionary.
	 *
	 * 
	 * @param Bytes $bytes
	 * @param int $pos
	 * @param \Array_hx $abrs
	 * 
	 * @return int
	 */
	public static function extractAbbreviations ($bytes, $pos, $abrs) {
		$count = \ord($bytes->b->s[$pos++]);
		$abrs->offsetSet($count - 1, null);
		$length = null;
		$name = null;
		$_g = 0;
		while ($_g < $count) {
			$i = $_g++;
			$length = \ord($bytes->b->s[$pos++]);
			if (($pos < 0) || ($length < 0) || (($pos + $length) > $bytes->length)) {
				throw Exception::thrown(Error::OutsideBounds());
			} else {
				$name = \substr($bytes->b->s, $pos, $length);
			}
			$pos += $length;
			$abrs->offsetSet($i, new TZAbr($name, $i));
		}
		return $pos;
	}

	/**
	 * Extract DstRule from position `pos` at `bytes` and assign it to `periods` at index `idx`
	 * Returns position of next byte after last byte of extracted DstRule
	 *
	 * 
	 * @param Bytes $bytes
	 * @param int $pos
	 * @param \Array_hx $periods
	 * @param int $idx
	 * @param \Array_hx $abrs
	 * @param \Array_hx $offsets
	 * 
	 * @return int
	 */
	public static function extractDstRule ($bytes, $pos, $periods, $idx, $abrs, $offsets) {
		$rule = new DstRule();
		$southernHemisphere = \ord($bytes->b->s[$pos++]) === 255;
		$pos = Decoder::extractUtc($bytes, $pos, $rule);
		$wday = \ord($bytes->b->s[$pos++]);
		$rule->wdayToDst = (int)(($wday / 10));
		$rule->wdayFromDst = $wday - $rule->wdayToDst * 10;
		$wdayNum = \ord($bytes->b->s[$pos++]);
		$rule->wdayNumToDst = (int)(($wdayNum / 10));
		$rule->wdayNumFromDst = $wdayNum - $rule->wdayNumToDst * 10;
		if ($rule->wdayNumToDst > 5) {
			$rule->wdayNumToDst -= 10;
		}
		if ($rule->wdayNumFromDst > 5) {
			$rule->wdayNumFromDst -= 10;
		}
		$month = \ord($bytes->b->s[$pos++]);
		if ($southernHemisphere) {
			$rule->monthToDst = (int)(($month / 10));
			$rule->monthFromDst = $month - $rule->monthToDst * 10;
		} else {
			$rule->monthFromDst = (int)(($month / 10));
			$rule->monthToDst = $month - $rule->monthFromDst * 10;
		}
		$h = \ord($bytes->b->s[$pos++]);
		$m = 0;
		$s = 0;
		if ($h < 100) {
			$m = \ord($bytes->b->s[$pos++]);
			$s = \ord($bytes->b->s[$pos++]);
		} else if ($h < 200) {
			$h -= 100;
			$m = \ord($bytes->b->s[$pos++]);
		} else {
			$h -= 200;
		}
		$rule->timeToDst = $h * 3600 + $m * 60 + $s;
		$h = \ord($bytes->b->s[$pos++]);
		$m = 0;
		$s = 0;
		if ($h < 100) {
			$m = \ord($bytes->b->s[$pos++]);
			$s = \ord($bytes->b->s[$pos++]);
		} else if ($h < 200) {
			$h -= 100;
			$m = \ord($bytes->b->s[$pos++]);
		} else {
			$h -= 200;
		}
		$rule->timeFromDst = $h * 3600 + $m * 60 + $s;
		$offAbrDst = \ord($bytes->b->s[$pos++]);
		$offsetIdx = (int)(($offAbrDst / 10));
		$rule->offsetDst = ($offsets->arr[$offsetIdx] ?? null);
		$rule->abrDst = ($abrs->arr[$offAbrDst - $offsetIdx * 10] ?? null)->name;
		$offAbr = \ord($bytes->b->s[$pos++]);
		$offsetIdx = (int)(($offAbr / 10));
		$rule->offset = ($offsets->arr[$offsetIdx] ?? null);
		$rule->abr = ($abrs->arr[$offAbr - $offsetIdx * 10] ?? null)->name;
		$periods->offsetSet($idx, $rule);
		return $pos;
	}

	/**
	 * Extract offsets dictionary.
	 * Returns position of next byte after last byte of offsets dictionary.
	 *
	 * 
	 * @param Bytes $bytes
	 * @param int $pos
	 * @param \Array_hx $offsets
	 * 
	 * @return int
	 */
	public static function extractOffsets ($bytes, $pos, $offsets) {
		$offset = null;
		$marker = null;
		$count = \ord($bytes->b->s[$pos++]);
		$offsets->offsetSet($count - 1, 0);
		$_g = 0;
		while ($_g < $count) {
			$i = $_g++;
			$marker = \ord($bytes->b->s[$pos++]);
			if ($marker === 255) {
				$offset = \ord($bytes->b->s[$pos++]);
				if ($offset >= 100) {
					$offset = -($offset - 100);
				}
				$offset *= 900;
			} else {
				$offset = Decoder::getInt($bytes, $pos);
				$pos += 4;
				if ($marker === 1) {
					$offset = -$offset;
				}
			}
			$offsets->offsetSet($i, $offset);
		}
		return $pos;
	}

	/**
	 * Extract TZPeriod from position `pos` at `bytes` and assign it to `periods` at index `idx`
	 * Returns position of next byte after last byte of extracted TZPeriod
	 *
	 * 
	 * @param Bytes $bytes
	 * @param int $pos
	 * @param \Array_hx $periods
	 * @param int $idx
	 * @param \Array_hx $abrs
	 * @param \Array_hx $offsets
	 * 
	 * @return int
	 */
	public static function extractTZPeriod ($bytes, $pos, $periods, $idx, $abrs, $offsets) {
		$period = new TZPeriod();
		$period->isDst = \ord($bytes->b->s[$pos++]) === 1;
		$pos = Decoder::extractUtc($bytes, $pos, $period);
		$offAbr = \ord($bytes->b->s[$pos++]);
		$offsetIdx = (int)(($offAbr / 10));
		$abr = ($abrs->arr[$offAbr - $offsetIdx * 10] ?? null);
		$period->offset = ($offsets->arr[$offsetIdx] ?? null);
		$period->abr = $abr->name;
		$periods->offsetSet($idx, $period);
		return $pos;
	}

	/**
	 * Extract utc timestamp from position `pos` at `bytes`.
	 * Returns position of the next byte after utc timestamp.
	 *
	 * 
	 * @param Bytes $bytes
	 * @param int $pos
	 * @param IPeriod $period
	 * 
	 * @return int
	 */
	public static function extractUtc ($bytes, $pos, $period) {
		$year = \ord($bytes->b->s[$pos++]) + 1900;
		$month = \ord($bytes->b->s[$pos++]);
		$day = \ord($bytes->b->s[$pos++]);
		$h = \ord($bytes->b->s[$pos++]);
		$m = 0;
		$s = 0;
		if ($h < 100) {
			$m = \ord($bytes->b->s[$pos++]);
			$s = \ord($bytes->b->s[$pos++]);
		} else if ($h < 200) {
			$h -= 100;
			$m = \ord($bytes->b->s[$pos++]);
		} else {
			$h -= 200;
		}
		$year1 = $year;
		$month1 = $month;
		$day1 = $day;
		$hour = $h;
		$minute = $m;
		$second = $s;
		if ($second === null) {
			$second = 0;
		}
		if ($minute === null) {
			$minute = 0;
		}
		if ($hour === null) {
			$hour = 0;
		}
		if ($day === null) {
			$day1 = 1;
		}
		if ($month === null) {
			$month1 = 1;
		}
		if ($year === null) {
			$year1 = 1970;
		}
		$period->utc = DateTimeUtils::yearToStamp($year1) + DateTimeMonthUtils::toSeconds($month1, (($year1 % 4) === 0) && ((($year1 % 100) === 0 ? ($year1 % 400) === 0 : true))) + ($day1 - 1) * 86400 + $hour * 3600 + $minute * 60 + $second - 62135596800.0 + 62135596800.0;
		return $pos;
	}

	/**
	 * Read integer value
	 *
	 * 
	 * @param Bytes $bytes
	 * @param int $pos
	 * 
	 * @return int
	 */
	public static function getInt ($bytes, $pos) {
		return \ord($bytes->b->s[$pos]) | (\ord($bytes->b->s[$pos + 1]) << 8) | (\ord($bytes->b->s[$pos + 2]) << 16) | (\ord($bytes->b->s[$pos + 3]) << 24);
	}

	/**
	 * Build map of timezones stored in `bytes` to be able to quickly find any timezone
	 *
	 * 
	 * @param Bytes $bytes
	 * 
	 * @return StringMap
	 */
	public static function getTzMap ($bytes) {
		$pos = 0;
		$length = null;
		$name = null;
		$map = new StringMap();
		while ($pos < $bytes->length) {
			$length = \ord($bytes->b->s[$pos]);
			++$pos;
			if (($pos < 0) || ($length < 0) || (($pos + $length) > $bytes->length)) {
				throw Exception::thrown(Error::OutsideBounds());
			} else {
				$name = \substr($bytes->b->s, $pos, $length);
			}
			$pos += $length;
			$length = Decoder::getInt($bytes, $pos);
			$pos += 4;
			$map->data[$name] = $pos;
			$pos += $length;
		}
		return $map;
	}

	/**
	 * Get timezone data located at specified `pos` in `bytes`
	 *
	 * 
	 * @param Bytes $bytes
	 * @param int $pos
	 * 
	 * @return TimezoneData
	 */
	public static function getZone ($bytes, $pos) {
		if (\ord($bytes->b->s[$pos]) === 255) {
			$pos = Decoder::getInt($bytes, $pos + 1);
		}
		$tzd = new TimezoneData();
		$abrs = new \Array_hx();
		$pos1 = $pos;
		$count = \ord($bytes->b->s[$pos1++]);
		$abrs->offsetSet($count - 1, null);
		$length = null;
		$name = null;
		$_g = 0;
		while ($_g < $count) {
			$i = $_g++;
			$length = \ord($bytes->b->s[$pos1++]);
			if (($pos1 < 0) || ($length < 0) || (($pos1 + $length) > $bytes->length)) {
				throw Exception::thrown(Error::OutsideBounds());
			} else {
				$name = \substr($bytes->b->s, $pos1, $length);
			}
			$pos1 += $length;
			$abrs->offsetSet($i, new TZAbr($name, $i));
		}
		$pos = $pos1;
		$offsets = new \Array_hx();
		$pos = Decoder::extractOffsets($bytes, $pos, $offsets);
		$count = \ord($bytes->b->s[$pos++]);
		$tzd->periods->offsetSet($count - 1, null);
		$_g = 0;
		while ($_g < $count) {
			$i = $_g++;
			if (\ord($bytes->b->s[$pos]) >= 254) {
				$pos = Decoder::extractDstRule($bytes, $pos, $tzd->periods, $i, $abrs, $offsets);
			} else {
				$pos = Decoder::extractTZPeriod($bytes, $pos, $tzd->periods, $i, $abrs, $offsets);
			}
		}
		return $tzd;
	}
}

Boot::registerClass(Decoder::class, 'datetime.utils.pack.Decoder');
