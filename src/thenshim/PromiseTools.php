<?php
/**
 * Generated by Haxe 4.1.4
 */

namespace thenshim;

use \php\_Boot\HxAnon;
use \php\Boot;
use \thenshim\_Promise\Promise_Impl_;

/**
 * Static extension class for additional JavaScript-style methods.
 *
 * The class is intended to be used using the `using` keyword.
 */
class PromiseTools {
	/**
	 * Returns a promise that is fulfilled when all the given promises are
	 * fulfilled or rejected with a reason of the first promise that is
	 * rejected.
	 * 
	 * @param object $promises
	 * 
	 * @return Thenable
	 */
	public static function all ($promises) {
		return Promise_Impl_::_new(function ($resolve, $reject) use (&$promises) {
			$promises_ = \Lambda::array($promises);
			$values = new \Array_hx();
			$values->resize($promises_->length);
			$remaining = $promises_->length;
			$_g = 0;
			$_g1 = $promises_->length;
			while ($_g < $_g1) {
				unset($index);
				$index = $_g++;
				Promise_Impl_::then(($promises_->arr[$index] ?? null), function ($value) use (&$index, &$resolve, &$values, &$remaining) {
					$values->offsetSet($index, $value);
					$remaining -= 1;
					if ($remaining === 0) {
						$resolve($values);
					}
				}, function ($reason) use (&$reject) {
					$reject($reason);
				});
			}
			if ($promises_->length === 0) {
				$resolve($values);
			}
		});
	}

	/**
	 * Returns a promise that will be fulfilled with an array of outcome objects
	 * when all of the given promises are settled.
	 *
	 * The object will have fields:
	 *
	 * - `status` (`String`) either "fulfilled" or "rejected"
	 * - `value` (`T`) when `status` is "fulfilled"
	 * - `reason` when `status` is "rejected"
	 *
	 * If the method is not implemented on the JS target, use
	 * `-D thenshim_js_fallback_allSettled` to enable a fallback implementation.
	 * Objects are either `FulfilledOutcome` or `RejectedOutcome`, but using
	 * reflection (`Reflect`) instead of casting is recommended for
	 * cross-target compatibility.
	 * 
	 * @param object $promises
	 * 
	 * @return Thenable
	 */
	public static function allSettled ($promises) {
		return Promise_Impl_::_new(function ($resolve, $reject) use (&$promises) {
			$promises_ = \Lambda::array($promises);
			$outcomes = new \Array_hx();
			$outcomes->resize($promises_->length);
			$remaining = $promises_->length;
			$countRemaining = function () use (&$outcomes, &$resolve, &$remaining) {
				$remaining -= 1;
				if ($remaining === 0) {
					$resolve($outcomes);
				}
			};
			$_g = 0;
			$_g1 = $promises_->length;
			while ($_g < $_g1) {
				unset($index);
				$index = $_g++;
				Promise_Impl_::then(($promises_->arr[$index] ?? null), function ($value) use (&$outcomes, &$countRemaining, &$index) {
					$outcomes->offsetSet($index, new HxAnon([
						"status" => "fulfilled",
						"value" => $value,
					]));
					$countRemaining();
				}, function ($reason) use (&$outcomes, &$countRemaining, &$index) {
					$outcomes->offsetSet($index, new HxAnon([
						"status" => "rejected",
						"reason" => $reason,
					]));
					$countRemaining();
				});
			}
			if ($promises_->length === 0) {
				$resolve($outcomes);
			}
		});
	}

	/**
	 * Calls `then` with the `onRejected` callback.
	 *
	 * This is an alias for `PromiseTools.catch_`.
	 * 
	 * @param Thenable $promise
	 * @param \Closure $onRejected
	 * 
	 * @return Thenable
	 */
	public static function catchError ($promise, $onRejected) {
		return PromiseTools::catch_($promise, $onRejected);
	}

	/**
	 * Calls `then` with the `onRejected` callback.
	 * 
	 * @param Thenable $promise
	 * @param \Closure $onRejected
	 * 
	 * @return Thenable
	 */
	public static function catch_ ($promise, $onRejected) {
		return Promise_Impl_::then($promise, function ($value) {
			return null;
		}, $onRejected);
	}

	/**
	 * Calls a callback when the given promise settles.
	 *
	 * If the method is not implemented on the JS target, use
	 * `-D thenshim_js_fallback_finally` to enable a fallback implementation.
	 * 
	 * @param Thenable $promise
	 * @param \Closure $onFinally
	 * 
	 * @return Thenable
	 */
	public static function finally ($promise, $onFinally) {
		return Promise_Impl_::then($promise, function ($value) use (&$onFinally) {
			$onFinally();
			return $value;
		}, function ($reason) use (&$onFinally) {
			$onFinally();
			return Promise_Impl_::reject($reason);
		});
	}

	/**
	 * Returns a promise that will be settled with the value or reason of
	 * the first promise to fullfil or reject.
	 * 
	 * @param object $promises
	 * 
	 * @return Thenable
	 */
	public static function race ($promises) {
		return Promise_Impl_::_new(function ($resolve, $reject) use (&$promises) {
			$promise = $promises->iterator();
			while ($promise->hasNext()) {
				Promise_Impl_::then($promise->next(), $resolve, $reject);
			}
		});
	}
}

Boot::registerClass(PromiseTools::class, 'thenshim.PromiseTools');
