<?php
/**
 * Generated by Haxe 4.1.2
 */

namespace thenshim\fallback;

use \php\Boot;
use \haxe\Exception;
use \php\_Boot\HxClosure;
use \thenshim\Thenable;
use \haxe\NativeStackTrace;

/**
 * Session for a `FallbackPromise` attached callback.
 */
class HandlerSession {
	/**
	 * @var mixed
	 */
	public $fulfilledCallback;
	/**
	 * @var FallbackPromise
	 */
	public $promise;
	/**
	 * @var mixed
	 */
	public $rejectedCallback;
	/**
	 * @var TaskScheduler
	 */
	public $scheduler;

	/**
	 * @param FallbackPromise $promise
	 * @param mixed $value
	 * 
	 * @return bool
	 */
	public static function rejectIfSame ($promise, $value) {
		if (Boot::equal($promise, $value)) {
			$promise->reject("promise and result is same object");
			return true;
		} else {
			return false;
		}
	}

	/**
	 * @param FallbackPromise $promise
	 * @param mixed $value
	 * 
	 * @return void
	 */
	public static function resolvePromise ($promise, $value) {
		if (HandlerSession::rejectIfSame($promise, $value)) {
			return;
		}
		if (($value instanceof Thenable)) {
			HandlerSession::resolvePromiseThenable($promise, $value);
		} else {
			$tmp = null;
			if (!is_string($value)) {
				if (!\Reflect::isObject($value)) {
					$f = $value;
					$tmp = ($f instanceof \Closure) || ($f instanceof HxClosure);
				} else {
					$tmp = true;
				}
			} else {
				$tmp = false;
			}
			if ($tmp) {
				HandlerSession::resolvePromiseObject($promise, $value);
			} else {
				$promise->resolve($value);
			}
		}
	}

	/**
	 * @param FallbackPromise $promise
	 * @param mixed $object
	 * 
	 * @return void
	 */
	public static function resolvePromiseObject ($promise, $object) {
		$then = null;
		try {
			$then = \Reflect::getProperty($object, "then");
		} catch(\Throwable $_g) {
			NativeStackTrace::saveStack($_g);
			$_g1 = Exception::caught($_g)->unwrap();
			$promise->reject($_g1);
			return;
		}
		$f = $then;
		if (!(($f instanceof \Closure) || ($f instanceof HxClosure))) {
			$promise->resolve($object);
			return;
		}
		$fulfilled = false;
		$_resolve = function ($value) use (&$promise, &$fulfilled) {
			if (!$fulfilled) {
				$fulfilled = true;
				HandlerSession::resolvePromise($promise, $value);
			}
		};
		$_reject = function ($reason) use (&$promise, &$fulfilled) {
			if (!$fulfilled) {
				$fulfilled = true;
				$promise->reject($reason);
			}
		};
		try {
			\Reflect::callMethod($object, $then, \Array_hx::wrap([
				$_resolve,
				$_reject,
			]));
		} catch(\Throwable $_g) {
			NativeStackTrace::saveStack($_g);
			$_g1 = Exception::caught($_g)->unwrap();
			if (!$fulfilled) {
				$fulfilled = true;
				$promise->reject($_g1);
			}
		}
	}

	/**
	 * @param FallbackPromise $promise
	 * @param Thenable $thenable
	 * 
	 * @return void
	 */
	public static function resolvePromiseThenable ($promise, $thenable) {
		$fulfilled = false;
		$_resolve = function ($value) use (&$promise, &$fulfilled) {
			if (!$fulfilled) {
				$fulfilled = true;
				HandlerSession::resolvePromise($promise, $value);
			}
		};
		$_reject = function ($reason) use (&$promise, &$fulfilled) {
			if (!$fulfilled) {
				$fulfilled = true;
				$promise->reject($reason);
			}
		};
		try {
			$thenable->then($_resolve, $_reject);
		} catch(\Throwable $_g) {
			NativeStackTrace::saveStack($_g);
			$_g1 = Exception::caught($_g)->unwrap();
			if (!$fulfilled) {
				$fulfilled = true;
				$promise->reject($_g1);
			}
		}
	}

	/**
	 * @param TaskScheduler $scheduler
	 * @param mixed $fulfilledCallback
	 * @param mixed $rejectedCallback
	 * 
	 * @return void
	 */
	public function __construct ($scheduler, $fulfilledCallback, $rejectedCallback) {
		$this->scheduler = $scheduler;
		$this->fulfilledCallback = $fulfilledCallback;
		$this->rejectedCallback = $rejectedCallback;
		$this->promise = new FallbackPromise($scheduler);
	}

	/**
	 * @return mixed
	 */
	public function nullThis () {
		return null;
	}

	/**
	 * @param mixed $reason
	 * 
	 * @return void
	 */
	public function reject ($reason) {
		if ($this->rejectedCallback !== null) {
			$_g = Boot::getInstanceClosure($this, 'rejectImpl');
			$reason1 = $reason;
			$tmp = function () use (&$reason1, &$_g) {
				$_g($reason1);
			};
			$this->scheduler->addNext($tmp);
		} else {
			$this->promise->reject($reason);
		}
	}

	/**
	 * @param mixed $reason
	 * 
	 * @return void
	 */
	public function rejectImpl ($reason) {
		$handlerValue = null;
		try {
			$handlerValue = \Reflect::callMethod(null, $this->rejectedCallback, \Array_hx::wrap([$reason]));
		} catch(\Throwable $_g) {
			NativeStackTrace::saveStack($_g);
			$_g1 = Exception::caught($_g)->unwrap();
			$this->promise->reject($_g1);
			return;
		}
		HandlerSession::resolvePromise($this->promise, $handlerValue);
	}

	/**
	 * @param mixed $value
	 * 
	 * @return void
	 */
	public function resolve ($value) {
		if ($this->fulfilledCallback !== null) {
			$_g = Boot::getInstanceClosure($this, 'resolveImpl');
			$value1 = $value;
			$tmp = function () use (&$value1, &$_g) {
				$_g($value1);
			};
			$this->scheduler->addNext($tmp);
		} else {
			$this->promise->resolve($value);
		}
	}

	/**
	 * @param mixed $value
	 * 
	 * @return void
	 */
	public function resolveImpl ($value) {
		$handlerValue = null;
		try {
			$handlerValue = \Reflect::callMethod(null, $this->fulfilledCallback, \Array_hx::wrap([$value]));
		} catch(\Throwable $_g) {
			NativeStackTrace::saveStack($_g);
			$_g1 = Exception::caught($_g)->unwrap();
			$this->promise->reject($_g1);
			return;
		}
		HandlerSession::resolvePromise($this->promise, $handlerValue);
	}
}

Boot::registerClass(HandlerSession::class, 'thenshim.fallback.HandlerSession');
