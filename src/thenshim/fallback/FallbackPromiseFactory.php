<?php
/**
 * Generated by Haxe 4.1.1
 */

namespace thenshim\fallback;

use \thenshim\PromiseFactory;
use \php\Boot;
use \haxe\Exception;
use \thenshim\Thenable;
use \haxe\NativeStackTrace;

/**
 * Factory that creates `FallbackPromise`.
 */
class FallbackPromiseFactory implements PromiseFactory {
	/**
	 * @var TaskScheduler
	 * Scheduler that is used for the promises created by this factory.
	 */
	public $scheduler;

	/**
	 * @return void
	 */
	public function __construct () {
		$this->scheduler = new TaskScheduler();
	}

	/**
	 * @param mixed $reason
	 * 
	 * @return Thenable
	 */
	public function asRejected ($reason) {
		$promise = new FallbackPromise($this->scheduler);
		$promise->reject($reason);
		return $promise;
	}

	/**
	 * @param mixed $object
	 * 
	 * @return Thenable
	 */
	public function asResolved ($object) {
		if (($object instanceof FallbackPromise)) {
			return $object;
		} else if (($object instanceof Thenable)) {
			return $this->asResolvedThenable($object);
		}
		$promise = $this->asResolvedThenProperty($object);
		if ($promise !== null) {
			return $promise;
		}
		$promise = new FallbackPromise($this->scheduler);
		$promise->resolve($object);
		return $promise;
	}

	/**
	 * @param mixed $object
	 * 
	 * @return Thenable
	 */
	public function asResolvedThenProperty ($object) {
		$then = null;
		try {
			$then = \Reflect::getProperty($object, "then");
		} catch(\Throwable $_g) {
			NativeStackTrace::saveStack($_g);
			return $this->asRejected(Exception::caught($_g)->unwrap());
		}
		if ($then !== null) {
			$promise = new FallbackPromise($this->scheduler);
			try {
				\Reflect::callMethod(null, $then, \Array_hx::wrap([
					Boot::getInstanceClosure($promise, 'resolve'),
					Boot::getInstanceClosure($promise, 'reject'),
				]));
			} catch(\Throwable $_g) {
				NativeStackTrace::saveStack($_g);
				$promise->reject(Exception::caught($_g)->unwrap());
			}
			return $promise;
		} else {
			return null;
		}
	}

	/**
	 * @param Thenable $thenable
	 * 
	 * @return Thenable
	 */
	public function asResolvedThenable ($thenable) {
		$promise = new FallbackPromise($this->scheduler);
		try {
			$thenable->then(Boot::getInstanceClosure($promise, 'resolve'), Boot::getInstanceClosure($promise, 'reject'));
		} catch(\Throwable $_g) {
			NativeStackTrace::saveStack($_g);
			$promise->reject(Exception::caught($_g)->unwrap());
		}
		return $promise;
	}

	/**
	 * @param \Closure $executor
	 * 
	 * @return Thenable
	 */
	public function make ($executor) {
		$promise = new FallbackPromise($this->scheduler);
		$executor(Boot::getInstanceClosure($promise, 'resolve'), Boot::getInstanceClosure($promise, 'reject'));
		return $promise;
	}
}

Boot::registerClass(FallbackPromiseFactory::class, 'thenshim.fallback.FallbackPromiseFactory');
