<?php
/**
 * Generated by Haxe 4.1.1
 */

use \php\Boot;
use \php\_Boot\HxString;
use \haxe\Exception as HaxeException;

/**
 * The Date class provides a basic structure for date and time related
 * information. Date instances can be created by
 * - `new Date()` for a specific date,
 * - `Date.now()` to obtain information about the current time,
 * - `Date.fromTime()` with a given timestamp or
 * - `Date.fromString()` by parsing from a String.
 * There are some extra functions available in the `DateTools` class.
 * In the context of Haxe dates, a timestamp is defined as the number of
 * milliseconds elapsed since 1st January 1970 UTC.
 * ## Supported range
 * Due to platform limitations, only dates in the range 1970 through 2038 are
 * supported consistently. Some targets may support dates outside this range,
 * depending on the OS at runtime. The `Date.fromTime` method will not work with
 * timestamps outside the range on any target.
 */
final class Date {
	/**
	 * @var float
	 */
	public $__t;

	/**
	 * @param float $t
	 * 
	 * @return Date
	 */
	public static function fromPhpTime ($t) {
		$d = new Date(2000, 1, 1, 0, 0, 0);
		$d->__t = $t;
		return $d;
	}

	/**
	 * Creates a Date from the formatted string `s`. The following formats are
	 * accepted by the function:
	 * - `"YYYY-MM-DD hh:mm:ss"`
	 * - `"YYYY-MM-DD"`
	 * - `"hh:mm:ss"`
	 * The first two formats expressed a date in local time. The third is a time
	 * relative to the UTC epoch.
	 * 
	 * @param string $s
	 * 
	 * @return Date
	 */
	public static function fromString ($s) {
		$__hx__switch = (mb_strlen($s));
		if ($__hx__switch === 8) {
			$k = HxString::split($s, ":");
			return Date::fromTime(\Std::parseInt(($k->arr[0] ?? null)) * 3600000. + \Std::parseInt(($k->arr[1] ?? null)) * 60000. + \Std::parseInt(($k->arr[2] ?? null)) * 1000.);
		} else if ($__hx__switch === 10) {
			$k = HxString::split($s, "-");
			$tmp = \Std::parseInt(($k->arr[0] ?? null));
			$tmp1 = \Std::parseInt(($k->arr[1] ?? null)) - 1;
			return new Date($tmp, $tmp1, \Std::parseInt(($k->arr[2] ?? null)), 0, 0, 0);
		} else if ($__hx__switch === 19) {
			$k = HxString::split($s, " ");
			$y = HxString::split(($k->arr[0] ?? null), "-");
			$t = HxString::split(($k->arr[1] ?? null), ":");
			$tmp = \Std::parseInt(($y->arr[0] ?? null));
			$tmp1 = \Std::parseInt(($y->arr[1] ?? null)) - 1;
			$tmp2 = \Std::parseInt(($y->arr[2] ?? null));
			$tmp3 = \Std::parseInt(($t->arr[0] ?? null));
			$tmp4 = \Std::parseInt(($t->arr[1] ?? null));
			return new Date($tmp, $tmp1, $tmp2, $tmp3, $tmp4, \Std::parseInt(($t->arr[2] ?? null)));
		} else {
			throw HaxeException::thrown("Invalid date format : " . ($s??'null'));
		}
	}

	/**
	 * Creates a Date from the timestamp (in milliseconds) `t`.
	 * 
	 * @param float $t
	 * 
	 * @return Date
	 */
	public static function fromTime ($t) {
		$d = new Date(2000, 1, 1, 0, 0, 0);
		$d->__t = $t / 1000;
		return $d;
	}

	/**
	 * Returns a Date representing the current local time.
	 * 
	 * @return Date
	 */
	public static function now () {
		return Date::fromPhpTime(round(microtime(true), 3));
	}

	/**
	 * Creates a new date object from the given arguments.
	 * The behaviour of a Date instance is only consistent across platforms if
	 * the the arguments describe a valid date.
	 * - month: 0 to 11 (note that this is zero-based)
	 * - day: 1 to 31
	 * - hour: 0 to 23
	 * - min: 0 to 59
	 * - sec: 0 to 59
	 * 
	 * @param int $year
	 * @param int $month
	 * @param int $day
	 * @param int $hour
	 * @param int $min
	 * @param int $sec
	 * 
	 * @return void
	 */
	public function __construct ($year, $month, $day, $hour, $min, $sec) {
		$this->__t = mktime($hour, $min, $sec, $month + 1, $day, $year);
	}

	/**
	 * Returns the day of `this` Date (1-31 range) in the local timezone.
	 * 
	 * @return int
	 */
	public function getDate () {
		return (int)(date("j", (int)($this->__t)));
	}

	/**
	 * Returns the day of the week of `this` Date (0-6 range, where `0` is Sunday)
	 * in the local timezone.
	 * 
	 * @return int
	 */
	public function getDay () {
		return (int)(date("w", (int)($this->__t)));
	}

	/**
	 * Returns the full year of `this` Date (4 digits) in the local timezone.
	 * 
	 * @return int
	 */
	public function getFullYear () {
		return (int)(date("Y", (int)($this->__t)));
	}

	/**
	 * Returns the hours of `this` Date (0-23 range) in the local timezone.
	 * 
	 * @return int
	 */
	public function getHours () {
		return (int)(date("G", (int)($this->__t)));
	}

	/**
	 * Returns the minutes of `this` Date (0-59 range) in the local timezone.
	 * 
	 * @return int
	 */
	public function getMinutes () {
		return (int)(date("i", (int)($this->__t)));
	}

	/**
	 * Returns the month of `this` Date (0-11 range) in the local timezone.
	 * Note that the month number is zero-based.
	 * 
	 * @return int
	 */
	public function getMonth () {
		return -1 + (int)(date("n", (int)($this->__t)));
	}

	/**
	 * @return float
	 */
	public function getPhpTime () {
		return $this->__t;
	}

	/**
	 * Returns the seconds of `this` Date (0-59 range) in the local timezone.
	 * 
	 * @return int
	 */
	public function getSeconds () {
		return (int)(date("s", (int)($this->__t)));
	}

	/**
	 * Returns the timestamp (in milliseconds) of `this` date.
	 * On cpp and neko, this function only has a second resolution, so the
	 * result will always be a multiple of `1000.0`, e.g. `1454698271000.0`.
	 * To obtain the current timestamp with better precision on cpp and neko,
	 * see the `Sys.time` API.
	 * For measuring time differences with millisecond accuracy on
	 * all platforms, see `haxe.Timer.stamp`.
	 * 
	 * @return float
	 */
	public function getTime () {
		return $this->__t * 1000.0;
	}

	/**
	 * Returns the time zone difference of `this` Date in the current locale
	 * to UTC, in minutes.
	 * Assuming the function is executed on a machine in a UTC+2 timezone,
	 * `Date.now().getTimezoneOffset()` will return `-120`.
	 * 
	 * @return int
	 */
	public function getTimezoneOffset () {
		return -(int)(((int)(date("Z", (int)($this->__t))) / 60));
	}

	/**
	 * Returns the day of `this` Date (1-31 range) in UTC.
	 * 
	 * @return int
	 */
	public function getUTCDate () {
		return (int)(gmdate("j", (int)($this->__t)));
	}

	/**
	 * Returns the day of the week of `this` Date (0-6 range, where `0` is Sunday)
	 * in UTC.
	 * 
	 * @return int
	 */
	public function getUTCDay () {
		return (int)(gmdate("w", (int)($this->__t)));
	}

	/**
	 * Returns the full year of `this` Date (4 digits) in UTC.
	 * 
	 * @return int
	 */
	public function getUTCFullYear () {
		return (int)(gmdate("Y", (int)($this->__t)));
	}

	/**
	 * Returns the hours of `this` Date (0-23 range) in UTC.
	 * 
	 * @return int
	 */
	public function getUTCHours () {
		return (int)(gmdate("G", (int)($this->__t)));
	}

	/**
	 * Returns the minutes of `this` Date (0-59 range) in UTC.
	 * 
	 * @return int
	 */
	public function getUTCMinutes () {
		return (int)(gmdate("i", (int)($this->__t)));
	}

	/**
	 * Returns the month of `this` Date (0-11 range) in UTC.
	 * Note that the month number is zero-based.
	 * 
	 * @return int
	 */
	public function getUTCMonth () {
		return -1 + (int)(gmdate("n", (int)($this->__t)));
	}

	/**
	 * Returns the seconds of `this` Date (0-59 range) in UTC.
	 * 
	 * @return int
	 */
	public function getUTCSeconds () {
		return (int)(gmdate("s", (int)($this->__t)));
	}

	/**
	 * Returns a string representation of `this` Date in the local timezone
	 * using the standard format `YYYY-MM-DD HH:MM:SS`. See `DateTools.format` for
	 * other formatting rules.
	 * 
	 * @return string
	 */
	public function toString () {
		return date("Y-m-d H:i:s", (int)($this->__t));
	}

	public function __toString() {
		return $this->toString();
	}
}

Boot::registerClass(Date::class, 'Date');
