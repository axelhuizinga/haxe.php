<?php
/**
 * Generated by Haxe 4.1.3
 */

use \haxe\iterators\ArrayIterator as IteratorsArrayIterator;
use \php\Boot;
use \haxe\xml\Parser;
use \_Xml\XmlType_Impl_;
use \haxe\Exception as HaxeException;
use \haxe\ds\StringMap;
use \haxe\xml\Printer;
use \php\_NativeIndexedArray\NativeIndexedArrayIterator;

/**
 * Cross-platform Xml API.
 * @see https://haxe.org/manual/std-Xml.html
 */
class Xml {
	/**
	 * @var int
	 * XML character data type.
	 */
	static public $CData;
	/**
	 * @var int
	 * XML comment type.
	 */
	static public $Comment;
	/**
	 * @var int
	 * XML doctype element type.
	 */
	static public $DocType;
	/**
	 * @var int
	 * XML document type.
	 */
	static public $Document;
	/**
	 * @var int
	 * XML element type.
	 */
	static public $Element;
	/**
	 * @var int
	 * XML parsed character data type.
	 */
	static public $PCData;
	/**
	 * @var int
	 * XML processing instruction type.
	 */
	static public $ProcessingInstruction;

	/**
	 * @var StringMap
	 */
	public $attributeMap;
	/**
	 * @var \Array_hx
	 */
	public $children;
	/**
	 * @var string
	 * Returns the node name of an Element.
	 */
	public $nodeName;
	/**
	 * @var int
	 * Returns the type of the Xml Node. This should be used before
	 * accessing other functions since some might raise an exception
	 * if the node type is not correct.
	 */
	public $nodeType;
	/**
	 * @var string
	 * Returns the node value. Only works if the Xml node is not an Element or a Document.
	 */
	public $nodeValue;
	/**
	 * @var Xml
	 * Returns the parent object in the Xml hierarchy.
	 * The parent can be `null`, an Element or a Document.
	 */
	public $parent;

	/**
	 * Creates a node of the given type.
	 * 
	 * @param string $data
	 * 
	 * @return Xml
	 */
	public static function createCData ($data) {
		$xml = new Xml(Xml::$CData);
		if (($xml->nodeType === Xml::$Document) || ($xml->nodeType === Xml::$Element)) {
			throw HaxeException::thrown("Bad node type, unexpected " . ((($xml->nodeType === null ? "null" : XmlType_Impl_::toString($xml->nodeType)))??'null'));
		}
		$xml->nodeValue = $data;
		return $xml;
	}

	/**
	 * Creates a node of the given type.
	 * 
	 * @param string $data
	 * 
	 * @return Xml
	 */
	public static function createComment ($data) {
		$xml = new Xml(Xml::$Comment);
		if (($xml->nodeType === Xml::$Document) || ($xml->nodeType === Xml::$Element)) {
			throw HaxeException::thrown("Bad node type, unexpected " . ((($xml->nodeType === null ? "null" : XmlType_Impl_::toString($xml->nodeType)))??'null'));
		}
		$xml->nodeValue = $data;
		return $xml;
	}

	/**
	 * Creates a node of the given type.
	 * 
	 * @param string $data
	 * 
	 * @return Xml
	 */
	public static function createDocType ($data) {
		$xml = new Xml(Xml::$DocType);
		if (($xml->nodeType === Xml::$Document) || ($xml->nodeType === Xml::$Element)) {
			throw HaxeException::thrown("Bad node type, unexpected " . ((($xml->nodeType === null ? "null" : XmlType_Impl_::toString($xml->nodeType)))??'null'));
		}
		$xml->nodeValue = $data;
		return $xml;
	}

	/**
	 * Creates a node of the given type.
	 * 
	 * @return Xml
	 */
	public static function createDocument () {
		return new Xml(Xml::$Document);
	}

	/**
	 * Creates a node of the given type.
	 * 
	 * @param string $name
	 * 
	 * @return Xml
	 */
	public static function createElement ($name) {
		$xml = new Xml(Xml::$Element);
		if ($xml->nodeType !== Xml::$Element) {
			throw HaxeException::thrown("Bad node type, expected Element but found " . ((($xml->nodeType === null ? "null" : XmlType_Impl_::toString($xml->nodeType)))??'null'));
		}
		$xml->nodeName = $name;
		return $xml;
	}

	/**
	 * Creates a node of the given type.
	 * 
	 * @param string $data
	 * 
	 * @return Xml
	 */
	public static function createPCData ($data) {
		$xml = new Xml(Xml::$PCData);
		if (($xml->nodeType === Xml::$Document) || ($xml->nodeType === Xml::$Element)) {
			throw HaxeException::thrown("Bad node type, unexpected " . ((($xml->nodeType === null ? "null" : XmlType_Impl_::toString($xml->nodeType)))??'null'));
		}
		$xml->nodeValue = $data;
		return $xml;
	}

	/**
	 * Creates a node of the given type.
	 * 
	 * @param string $data
	 * 
	 * @return Xml
	 */
	public static function createProcessingInstruction ($data) {
		$xml = new Xml(Xml::$ProcessingInstruction);
		if (($xml->nodeType === Xml::$Document) || ($xml->nodeType === Xml::$Element)) {
			throw HaxeException::thrown("Bad node type, unexpected " . ((($xml->nodeType === null ? "null" : XmlType_Impl_::toString($xml->nodeType)))??'null'));
		}
		$xml->nodeValue = $data;
		return $xml;
	}

	/**
	 * Parses the String into an Xml document.
	 * 
	 * @param string $str
	 * 
	 * @return Xml
	 */
	public static function parse ($str) {
		return Parser::parse($str);
	}

	/**
	 * @param int $nodeType
	 * 
	 * @return void
	 */
	public function __construct ($nodeType) {
		$this->nodeType = $nodeType;
		$this->children = new \Array_hx();
		$this->attributeMap = new StringMap();
	}

	/**
	 * Adds a child node to the Document or Element.
	 * A child node can only be inside one given parent node, which is indicated by the `parent` property.
	 * If the child is already inside this Document or Element, it will be moved to the last position among the Document or Element's children.
	 * If the child node was previously inside a different node, it will be moved to this Document or Element.
	 * 
	 * @param Xml $x
	 * 
	 * @return void
	 */
	public function addChild ($x) {
		if (($this->nodeType !== Xml::$Document) && ($this->nodeType !== Xml::$Element)) {
			throw HaxeException::thrown("Bad node type, expected Element or Document but found " . ((($this->nodeType === null ? "null" : XmlType_Impl_::toString($this->nodeType)))??'null'));
		}
		if ($x->parent !== null) {
			$x->parent->removeChild($x);
		}
		$_this = $this->children;
		$_this->arr[$_this->length++] = $x;
		$x->parent = $this;
	}

	/**
	 * Returns an `Iterator` on all the attribute names.
	 * 
	 * @return object
	 */
	public function attributes () {
		if ($this->nodeType !== Xml::$Element) {
			throw HaxeException::thrown("Bad node type, expected Element but found " . ((($this->nodeType === null ? "null" : XmlType_Impl_::toString($this->nodeType)))??'null'));
		}
		return new NativeIndexedArrayIterator(array_values(array_map("strval", array_keys($this->attributeMap->data))));
	}

	/**
	 * Returns an iterator of all child nodes which are Elements.
	 * Only works if the current node is an Element or a Document.
	 * 
	 * @return object
	 */
	public function elements () {
		if (($this->nodeType !== Xml::$Document) && ($this->nodeType !== Xml::$Element)) {
			throw HaxeException::thrown("Bad node type, expected Element or Document but found " . ((($this->nodeType === null ? "null" : XmlType_Impl_::toString($this->nodeType)))??'null'));
		}
		$_g = new \Array_hx();
		$_g1 = 0;
		$_g2 = $this->children;
		while ($_g1 < $_g2->length) {
			$child = ($_g2->arr[$_g1] ?? null);
			++$_g1;
			if ($child->nodeType === Xml::$Element) {
				$_g->arr[$_g->length++] = $child;
			}
		}
		return new IteratorsArrayIterator($_g);
	}

	/**
	 * Returns an iterator of all child nodes which are Elements with the given nodeName.
	 * Only works if the current node is an Element or a Document.
	 * 
	 * @param string $name
	 * 
	 * @return object
	 */
	public function elementsNamed ($name) {
		if (($this->nodeType !== Xml::$Document) && ($this->nodeType !== Xml::$Element)) {
			throw HaxeException::thrown("Bad node type, expected Element or Document but found " . ((($this->nodeType === null ? "null" : XmlType_Impl_::toString($this->nodeType)))??'null'));
		}
		$_g = new \Array_hx();
		$_g1 = 0;
		$_g2 = $this->children;
		while ($_g1 < $_g2->length) {
			$child = ($_g2->arr[$_g1] ?? null);
			++$_g1;
			$tmp = null;
			if ($child->nodeType === Xml::$Element) {
				if ($child->nodeType !== Xml::$Element) {
					throw HaxeException::thrown("Bad node type, expected Element but found " . ((($child->nodeType === null ? "null" : XmlType_Impl_::toString($child->nodeType)))??'null'));
				}
				$tmp = $child->nodeName === $name;
			} else {
				$tmp = false;
			}
			if ($tmp) {
				$_g->arr[$_g->length++] = $child;
			}
		}
		return new IteratorsArrayIterator($_g);
	}

	/**
	 * @return void
	 */
	public function ensureElementType () {
		if (($this->nodeType !== Xml::$Document) && ($this->nodeType !== Xml::$Element)) {
			throw HaxeException::thrown("Bad node type, expected Element or Document but found " . ((($this->nodeType === null ? "null" : XmlType_Impl_::toString($this->nodeType)))??'null'));
		}
	}

	/**
	 * Tells if the Element node has a given attribute.
	 * Attributes are case-sensitive.
	 * 
	 * @param string $att
	 * 
	 * @return bool
	 */
	public function exists ($att) {
		if ($this->nodeType !== Xml::$Element) {
			throw HaxeException::thrown("Bad node type, expected Element but found " . ((($this->nodeType === null ? "null" : XmlType_Impl_::toString($this->nodeType)))??'null'));
		}
		return array_key_exists($att, $this->attributeMap->data);
	}

	/**
	 * Returns the first child node.
	 * 
	 * @return Xml
	 */
	public function firstChild () {
		if (($this->nodeType !== Xml::$Document) && ($this->nodeType !== Xml::$Element)) {
			throw HaxeException::thrown("Bad node type, expected Element or Document but found " . ((($this->nodeType === null ? "null" : XmlType_Impl_::toString($this->nodeType)))??'null'));
		}
		return ($this->children->arr[0] ?? null);
	}

	/**
	 * Returns the first child node which is an Element.
	 * 
	 * @return Xml
	 */
	public function firstElement () {
		if (($this->nodeType !== Xml::$Document) && ($this->nodeType !== Xml::$Element)) {
			throw HaxeException::thrown("Bad node type, expected Element or Document but found " . ((($this->nodeType === null ? "null" : XmlType_Impl_::toString($this->nodeType)))??'null'));
		}
		$_g = 0;
		$_g1 = $this->children;
		while ($_g < $_g1->length) {
			$child = ($_g1->arr[$_g] ?? null);
			++$_g;
			if ($child->nodeType === Xml::$Element) {
				return $child;
			}
		}
		return null;
	}

	/**
	 * Get the given attribute of an Element node. Returns `null` if not found.
	 * Attributes are case-sensitive.
	 * 
	 * @param string $att
	 * 
	 * @return string
	 */
	public function get ($att) {
		if ($this->nodeType !== Xml::$Element) {
			throw HaxeException::thrown("Bad node type, expected Element but found " . ((($this->nodeType === null ? "null" : XmlType_Impl_::toString($this->nodeType)))??'null'));
		}
		return ($this->attributeMap->data[$att] ?? null);
	}

	/**
	 * @return string
	 */
	public function get_nodeName () {
		if ($this->nodeType !== Xml::$Element) {
			throw HaxeException::thrown("Bad node type, expected Element but found " . ((($this->nodeType === null ? "null" : XmlType_Impl_::toString($this->nodeType)))??'null'));
		}
		return $this->nodeName;
	}

	/**
	 * @return string
	 */
	public function get_nodeValue () {
		if (($this->nodeType === Xml::$Document) || ($this->nodeType === Xml::$Element)) {
			throw HaxeException::thrown("Bad node type, unexpected " . ((($this->nodeType === null ? "null" : XmlType_Impl_::toString($this->nodeType)))??'null'));
		}
		return $this->nodeValue;
	}

	/**
	 * Inserts a child at the given position among the other childs.
	 * A child node can only be inside one given parent node, which is indicated by the [parent] property.
	 * If the child is already inside this Document or Element, it will be moved to the new position among the Document or Element's children.
	 * If the child node was previously inside a different node, it will be moved to this Document or Element.
	 * 
	 * @param Xml $x
	 * @param int $pos
	 * 
	 * @return void
	 */
	public function insertChild ($x, $pos) {
		if (($this->nodeType !== Xml::$Document) && ($this->nodeType !== Xml::$Element)) {
			throw HaxeException::thrown("Bad node type, expected Element or Document but found " . ((($this->nodeType === null ? "null" : XmlType_Impl_::toString($this->nodeType)))??'null'));
		}
		if ($x->parent !== null) {
			$x->parent->children->remove($x);
		}
		$this->children->insert($pos, $x);
		$x->parent = $this;
	}

	/**
	 * Returns an iterator of all child nodes.
	 * Only works if the current node is an Element or a Document.
	 * 
	 * @return object
	 */
	public function iterator () {
		if (($this->nodeType !== Xml::$Document) && ($this->nodeType !== Xml::$Element)) {
			throw HaxeException::thrown("Bad node type, expected Element or Document but found " . ((($this->nodeType === null ? "null" : XmlType_Impl_::toString($this->nodeType)))??'null'));
		}
		return new IteratorsArrayIterator($this->children);
	}

	/**
	 * Removes an attribute for an Element node.
	 * Attributes are case-sensitive.
	 * 
	 * @param string $att
	 * 
	 * @return void
	 */
	public function remove ($att) {
		if ($this->nodeType !== Xml::$Element) {
			throw HaxeException::thrown("Bad node type, expected Element but found " . ((($this->nodeType === null ? "null" : XmlType_Impl_::toString($this->nodeType)))??'null'));
		}
		$this->attributeMap->remove($att);
	}

	/**
	 * Removes a child from the Document or Element.
	 * Returns true if the child was successfuly removed.
	 * 
	 * @param Xml $x
	 * 
	 * @return bool
	 */
	public function removeChild ($x) {
		if (($this->nodeType !== Xml::$Document) && ($this->nodeType !== Xml::$Element)) {
			throw HaxeException::thrown("Bad node type, expected Element or Document but found " . ((($this->nodeType === null ? "null" : XmlType_Impl_::toString($this->nodeType)))??'null'));
		}
		if ($this->children->remove($x)) {
			$x->parent = null;
			return true;
		}
		return false;
	}

	/**
	 * Set the given attribute value for an Element node.
	 * Attributes are case-sensitive.
	 * 
	 * @param string $att
	 * @param string $value
	 * 
	 * @return void
	 */
	public function set ($att, $value) {
		if ($this->nodeType !== Xml::$Element) {
			throw HaxeException::thrown("Bad node type, expected Element but found " . ((($this->nodeType === null ? "null" : XmlType_Impl_::toString($this->nodeType)))??'null'));
		}
		$this->attributeMap->data[$att] = $value;
	}

	/**
	 * @param string $v
	 * 
	 * @return string
	 */
	public function set_nodeName ($v) {
		if ($this->nodeType !== Xml::$Element) {
			throw HaxeException::thrown("Bad node type, expected Element but found " . ((($this->nodeType === null ? "null" : XmlType_Impl_::toString($this->nodeType)))??'null'));
		}
		return $this->nodeName = $v;
	}

	/**
	 * @param string $v
	 * 
	 * @return string
	 */
	public function set_nodeValue ($v) {
		if (($this->nodeType === Xml::$Document) || ($this->nodeType === Xml::$Element)) {
			throw HaxeException::thrown("Bad node type, unexpected " . ((($this->nodeType === null ? "null" : XmlType_Impl_::toString($this->nodeType)))??'null'));
		}
		return $this->nodeValue = $v;
	}

	/**
	 * Returns a String representation of the Xml node.
	 * 
	 * @return string
	 */
	public function toString () {
		return Printer::print($this);
	}

	public function __toString() {
		return $this->toString();
	}

	/**
	 * @internal
	 * @access private
	 */
	static public function __hx__init ()
	{
		static $called = false;
		if ($called) return;
		$called = true;


		self::$Element = 0;
		self::$PCData = 1;
		self::$CData = 2;
		self::$Comment = 3;
		self::$DocType = 4;
		self::$ProcessingInstruction = 5;
		self::$Document = 6;
	}
}

Boot::registerClass(Xml::class, 'Xml');
Boot::registerGetters('Xml', [
	'nodeValue' => true,
	'nodeName' => true
]);
Boot::registerSetters('Xml', [
	'nodeValue' => true,
	'nodeName' => true
]);
Xml::__hx__init();
