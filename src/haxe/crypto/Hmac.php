<?php
/**
 * Generated by Haxe 4.1.5
 */

namespace haxe\crypto;

use \haxe\io\_BytesData\Container;
use \php\Boot;
use \haxe\io\BytesBuffer;
use \haxe\io\Bytes;

/**
 * Calculates a Hmac of the given Bytes using a HashMethod.
 */
class Hmac {
	/**
	 * @var int
	 */
	public $blockSize;
	/**
	 * @var int
	 */
	public $length;
	/**
	 * @var HashMethod
	 */
	public $method;

	/**
	 * @param HashMethod $hashMethod
	 * 
	 * @return void
	 */
	public function __construct ($hashMethod) {
		$this->method = $hashMethod;
		$this->blockSize = 64;
		$tmp = null;
		$__hx__switch = ($hashMethod->index);
		if ($__hx__switch === 0) {
			$tmp = 16;
		} else if ($__hx__switch === 1) {
			$tmp = 20;
		} else if ($__hx__switch === 2) {
			$tmp = 32;
		}
		$this->length = $tmp;
	}

	/**
	 * @param Bytes $b
	 * 
	 * @return Bytes
	 */
	public function doHash ($b) {
		$__hx__switch = ($this->method->index);
		if ($__hx__switch === 0) {
			$b1 = new Container(\md5($b->b->s, true));
			return new Bytes(\strlen($b1->s), $b1);
		} else if ($__hx__switch === 1) {
			$b1 = new Container(\sha1($b->b->s, true));
			return new Bytes(\strlen($b1->s), $b1);
		} else if ($__hx__switch === 2) {
			return Sha256::make($b);
		}
	}

	/**
	 * @param Bytes $key
	 * @param Bytes $msg
	 * 
	 * @return Bytes
	 */
	public function make ($key, $msg) {
		if ($key->length > $this->blockSize) {
			$__hx__switch = ($this->method->index);
			if ($__hx__switch === 0) {
				$b = new Container(\md5($key->b->s, true));
				$key = new Bytes(\strlen($b->s), $b);
			} else if ($__hx__switch === 1) {
				$b = new Container(\sha1($key->b->s, true));
				$key = new Bytes(\strlen($b->s), $b);
			} else if ($__hx__switch === 2) {
				$key = Sha256::make($key);
			}
		}
		$key = $this->nullPad($key, $this->blockSize);
		$Ki = new BytesBuffer();
		$Ko = new BytesBuffer();
		$_g = 0;
		$_g1 = $key->length;
		while ($_g < $_g1) {
			$i = $_g++;
			$byte = \ord($key->b->s[$i]) ^ 92;
			$Ko->b = ($Ko->b . \chr($byte));
			$byte1 = \ord($key->b->s[$i]) ^ 54;
			$Ki->b = ($Ki->b . \chr($byte1));
		}
		$Ki->b = ($Ki->b . $msg->b->s);
		$b = $Ki->getBytes();
		$src = null;
		$__hx__switch = ($this->method->index);
		if ($__hx__switch === 0) {
			$b1 = new Container(\md5($b->b->s, true));
			$src = new Bytes(\strlen($b1->s), $b1);
		} else if ($__hx__switch === 1) {
			$b1 = new Container(\sha1($b->b->s, true));
			$src = new Bytes(\strlen($b1->s), $b1);
		} else if ($__hx__switch === 2) {
			$src = Sha256::make($b);
		}
		$Ko->b = ($Ko->b . $src->b->s);
		$b = $Ko->getBytes();
		$__hx__switch = ($this->method->index);
		if ($__hx__switch === 0) {
			$b1 = new Container(\md5($b->b->s, true));
			return new Bytes(\strlen($b1->s), $b1);
		} else if ($__hx__switch === 1) {
			$b1 = new Container(\sha1($b->b->s, true));
			return new Bytes(\strlen($b1->s), $b1);
		} else if ($__hx__switch === 2) {
			return Sha256::make($b);
		}
	}

	/**
	 * @param Bytes $s
	 * @param int $chunkLen
	 * 
	 * @return Bytes
	 */
	public function nullPad ($s, $chunkLen) {
		$r = $chunkLen - ($s->length % $chunkLen);
		if (($r === $chunkLen) && ($s->length !== 0)) {
			return $s;
		}
		$sb = new BytesBuffer();
		$sb->b = ($sb->b . $s->b->s);
		$_g = 0;
		while ($_g < $r) {
			++$_g;
			$sb->b = ($sb->b . \chr(0));
		}
		return $sb->getBytes();
	}
}

Boot::registerClass(Hmac::class, 'haxe.crypto.Hmac');
