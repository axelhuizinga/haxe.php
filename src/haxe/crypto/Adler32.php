<?php
/**
 * Generated by Haxe 4.1.5
 */

namespace haxe\crypto;

use \php\Boot;
use \haxe\io\Input;
use \haxe\io\Bytes;

/**
 * Calculates the Adler32 of the given Bytes.
 */
class Adler32 {
	/**
	 * @var int
	 */
	public $a1;
	/**
	 * @var int
	 */
	public $a2;

	/**
	 * @param Bytes $b
	 * 
	 * @return int
	 */
	public static function make ($b) {
		$a = new Adler32();
		$a->update($b, 0, $b->length);
		return $a->get();
	}

	/**
	 * @param Input $i
	 * 
	 * @return Adler32
	 */
	public static function read ($i) {
		$a = new Adler32();
		$a2a = $i->readByte();
		$a2b = $i->readByte();
		$a->a1 = ($i->readByte() << 8) | $i->readByte();
		$a->a2 = ($a2a << 8) | $a2b;
		return $a;
	}

	/**
	 * @return void
	 */
	public function __construct () {
		$this->a1 = 1;
		$this->a2 = 0;
	}

	/**
	 * @param Adler32 $a
	 * 
	 * @return bool
	 */
	public function equals ($a) {
		if ($a->a1 === $this->a1) {
			return $a->a2 === $this->a2;
		} else {
			return false;
		}
	}

	/**
	 * @return int
	 */
	public function get () {
		return ($this->a2 << 16) | $this->a1;
	}

	/**
	 * @return string
	 */
	public function toString () {
		return (\StringTools::hex($this->a2, 8)??'null') . (\StringTools::hex($this->a1, 8)??'null');
	}

	/**
	 * @param Bytes $b
	 * @param int $pos
	 * @param int $len
	 * 
	 * @return void
	 */
	public function update ($b, $pos, $len) {
		$a1 = $this->a1;
		$a2 = $this->a2;
		$_g = $pos;
		$_g1 = $pos + $len;
		while ($_g < $_g1) {
			$a1 = ($a1 + \ord($b->b->s[$_g++])) % 65521;
			$a2 = ($a2 + $a1) % 65521;
		}
		$this->a1 = $a1;
		$this->a2 = $a2;
	}

	public function __toString() {
		return $this->toString();
	}
}

Boot::registerClass(Adler32::class, 'haxe.crypto.Adler32');
