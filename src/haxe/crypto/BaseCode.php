<?php
/**
 * Generated by Haxe 4.1.5
 */

namespace haxe\crypto;

use \haxe\io\_BytesData\Container;
use \php\Boot;
use \haxe\Exception;
use \haxe\io\Bytes;

/**
 * Allows one to encode/decode String and bytes using a power of two base dictionary.
 */
class BaseCode {
	/**
	 * @var Bytes
	 */
	public $base;
	/**
	 * @var int
	 */
	public $nbits;
	/**
	 * @var \Array_hx
	 */
	public $tbl;

	/**
	 * @param string $s
	 * @param string $base
	 * 
	 * @return string
	 */
	public static function decode ($s, $base) {
		$b = \strlen($base);
		return (new BaseCode(new Bytes($b, new Container($base))))->decodeString($s);
	}

	/**
	 * @param string $s
	 * @param string $base
	 * 
	 * @return string
	 */
	public static function encode ($s, $base) {
		$b = \strlen($base);
		return (new BaseCode(new Bytes($b, new Container($base))))->encodeString($s);
	}

	/**
	 * @param Bytes $base
	 * 
	 * @return void
	 */
	public function __construct ($base) {
		$len = $base->length;
		$nbits = 1;
		while ($len > (1 << $nbits)) {
			++$nbits;
		}
		if (($nbits > 8) || ($len !== (1 << $nbits))) {
			throw Exception::thrown("BaseCode : base length must be a power of two.");
		}
		$this->base = $base;
		$this->nbits = $nbits;
	}

	/**
	 * @param Bytes $b
	 * 
	 * @return Bytes
	 */
	public function decodeBytes ($b) {
		$nbits = $this->nbits;
		if ($this->tbl === null) {
			$this->initTable();
		}
		$tbl = $this->tbl;
		$size = ($b->length * $nbits) >> 3;
		$out = Bytes::alloc($size);
		$buf = 0;
		$curbits = 0;
		$pin = 0;
		$pout = 0;
		while ($pout < $size) {
			while ($curbits < 8) {
				$curbits += $nbits;
				$buf <<= $nbits;
				$i = ($tbl->arr[\ord($b->b->s[$pin++])] ?? null);
				if ($i === -1) {
					throw Exception::thrown("BaseCode : invalid encoded char");
				}
				$buf |= $i;
			}
			$curbits -= 8;
			$out->b->s[$pout++] = \chr(($buf >> $curbits) & 255);
		}
		return $out;
	}

	/**
	 * @param string $s
	 * 
	 * @return string
	 */
	public function decodeString ($s) {
		$tmp = \strlen($s);
		return $this->decodeBytes(new Bytes($tmp, new Container($s)))->toString();
	}

	/**
	 * @param Bytes $b
	 * 
	 * @return Bytes
	 */
	public function encodeBytes ($b) {
		$nbits = $this->nbits;
		$base = $this->base;
		$size = (int)(($b->length * 8 / $nbits));
		$out = Bytes::alloc($size + (((($b->length * 8) % $nbits) === 0 ? 0 : 1)));
		$buf = 0;
		$curbits = 0;
		$mask = (1 << $nbits) - 1;
		$pin = 0;
		$pout = 0;
		while ($pout < $size) {
			while ($curbits < $nbits) {
				$curbits += 8;
				$buf <<= 8;
				$buf |= \ord($b->b->s[$pin++]);
			}
			$curbits -= $nbits;
			$v = \ord($base->b->s[($buf >> $curbits) & $mask]);
			$out->b->s[$pout++] = \chr($v);
		}
		if ($curbits > 0) {
			$v = \ord($base->b->s[($buf << ($nbits - $curbits)) & $mask]);
			$out->b->s[$pout++] = \chr($v);
		}
		return $out;
	}

	/**
	 * @param string $s
	 * 
	 * @return string
	 */
	public function encodeString ($s) {
		$tmp = \strlen($s);
		return $this->encodeBytes(new Bytes($tmp, new Container($s)))->toString();
	}

	/**
	 * @return void
	 */
	public function initTable () {
		$tbl = new \Array_hx();
		$_g = 0;
		while ($_g < 256) {
			$tbl->offsetSet($_g++, -1);
		}
		$_g = 0;
		$_g1 = $this->base->length;
		while ($_g < $_g1) {
			$i = $_g++;
			$tbl->offsetSet(\ord($this->base->b->s[$i]), $i);
		}
		$this->tbl = $tbl;
	}
}

Boot::registerClass(BaseCode::class, 'haxe.crypto.BaseCode');
