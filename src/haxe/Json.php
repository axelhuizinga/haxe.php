<?php
/**
 * Generated by Haxe 4.1.1
 */

namespace haxe;

use \php\_Boot\HxAnon;
use \php\Boot;
use \haxe\format\JsonPrinter;

/**
 * Cross-platform JSON API: it will automatically use the optimized native API if available.
 * Use `-D haxeJSON` to force usage of the Haxe implementation even if a native API is found:
 * This will provide extra encoding features such as enums (replaced by their index) and StringMaps.
 * @see https://haxe.org/manual/std-Json.html
 */
class Json {
	/**
	 * @param mixed $value
	 * 
	 * @return mixed
	 */
	public static function convertAfterDecode ($value) {
		if (is_object($value)) {
			$result = [];
			$data = ((array)($value));
			foreach ($data as $key => $value1) {
				$result[$key] = Json::convertAfterDecode($value1);
			}
			return new HxAnon($result);
		}
		if (is_array($value)) {
			$result = [];
			foreach ($value as $key => $value1) {
				$result[$key] = Json::convertAfterDecode($value1);
			}
			return \Array_hx::wrap($result);
		}
		return $value;
	}

	/**
	 * @param mixed $value
	 * 
	 * @return mixed
	 */
	public static function convertBeforeEncode ($value) {
		if (($value instanceof \Array_hx)) {
			$result = [];
			$collection = Boot::dynamicField($value, 'arr');
			foreach ($collection as $key => $value1) {
				$result[$key] = Json::convertBeforeEncode($value1);
			}
			return $result;
		}
		if (is_object($value)) {
			$result = new HxAnon();
			foreach ($value as $key => $value1) {
				$result->{$key} = Json::convertBeforeEncode($value1);
			}
			return $result;
		}
		if (is_float($value) && !is_finite($value)) {
			return null;
		}
		return $value;
	}

	/**
	 * Parses given JSON-encoded `text` and returns the resulting object.
	 * JSON objects are parsed into anonymous structures and JSON arrays
	 * are parsed into `Array<Dynamic>`.
	 * If given `text` is not valid JSON, an exception will be thrown.
	 * @see https://haxe.org/manual/std-Json-parsing.html
	 * 
	 * @param string $text
	 * 
	 * @return mixed
	 */
	public static function parse ($text) {
		return Json::phpJsonDecode($text);
	}

	/**
	 * @param string $json
	 * 
	 * @return mixed
	 */
	public static function phpJsonDecode ($json) {
		$value = json_decode($json);
		if (($value === null) && (json_last_error() !== JSON_ERROR_NONE)) {
			throw Exception::thrown(json_last_error_msg());
		}
		return Json::convertAfterDecode($value);
	}

	/**
	 * @param mixed $value
	 * @param \Closure $replacer
	 * @param string $space
	 * 
	 * @return string
	 */
	public static function phpJsonEncode ($value, $replacer = null, $space = null) {
		if ((null !== $replacer) || (null !== $space)) {
			return JsonPrinter::print($value, $replacer, $space);
		}
		$json = json_encode(Json::convertBeforeEncode($value));
		if (json_last_error() !== JSON_ERROR_NONE) {
			throw Exception::thrown(json_last_error_msg());
		}
		return $json;
	}

	/**
	 * Encodes the given `value` and returns the resulting JSON string.
	 * If `replacer` is given and is not null, it is used to retrieve the
	 * actual object to be encoded. The `replacer` function takes two parameters,
	 * the key and the value being encoded. Initial key value is an empty string.
	 * If `space` is given and is not null, the result will be pretty-printed.
	 * Successive levels will be indented by this string.
	 * @see https://haxe.org/manual/std-Json-encoding.html
	 * 
	 * @param mixed $value
	 * @param \Closure $replacer
	 * @param string $space
	 * 
	 * @return string
	 */
	public static function stringify ($value, $replacer = null, $space = null) {
		return Json::phpJsonEncode($value, $replacer, $space);
	}
}

Boot::registerClass(Json::class, 'haxe.Json');
