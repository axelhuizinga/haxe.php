<?php
/**
 * Generated by Haxe 4.1.4
 */

namespace haxe\rtti;

use \php\Boot;
use \haxe\Exception;

/**
 * Contains type and equality checks functionalities for RTTI.
 */
class TypeApi {
	/**
	 * Unlike `c1 == c2`, this function performs a deep equality check on
	 * the arguments of the enum constructors, if exists.
	 * If `c1` or `c2` are `null`, the result is unspecified.
	 * 
	 * @param object $c1
	 * @param object $c2
	 * 
	 * @return bool
	 */
	public static function constructorEq ($c1, $c2) {
		if ($c1->name !== $c2->name) {
			return false;
		}
		if ($c1->doc !== $c2->doc) {
			return false;
		}
		if (($c1->args === null) !== ($c2->args === null)) {
			return false;
		}
		if (($c1->args !== null) && !TypeApi::leq(function ($a, $b) {
			if (($a->name === $b->name) && ($a->opt === $b->opt)) {
				return TypeApi::typeEq($a->t, $b->t);
			} else {
				return false;
			}
		}, $c1->args, $c2->args)) {
			return false;
		}
		return true;
	}

	/**
	 * Unlike `f1 == f2`, this function performs a deep equality check on
	 * the given `ClassField` instances.
	 * If `f1` or `f2` are `null`, the result is unspecified.
	 * 
	 * @param object $f1
	 * @param object $f2
	 * 
	 * @return bool
	 */
	public static function fieldEq ($f1, $f2) {
		if ($f1->name !== $f2->name) {
			return false;
		}
		if (!TypeApi::typeEq($f1->type, $f2->type)) {
			return false;
		}
		if ($f1->isPublic !== $f2->isPublic) {
			return false;
		}
		if ($f1->doc !== $f2->doc) {
			return false;
		}
		if (!TypeApi::rightsEq($f1->get, $f2->get)) {
			return false;
		}
		if (!TypeApi::rightsEq($f1->set, $f2->set)) {
			return false;
		}
		if (($f1->params === null) !== ($f2->params === null)) {
			return false;
		}
		if (($f1->params !== null) && ($f1->params->join(":") !== $f2->params->join(":"))) {
			return false;
		}
		return true;
	}

	/**
	 * Returns `true` if the given `CType` is a variable or `false` if it is a
	 * function.
	 * 
	 * @param CType $t
	 * 
	 * @return bool
	 */
	public static function isVar ($t) {
		if ($t->index === 4) {
			return false;
		} else {
			return true;
		}
	}

	/**
	 * @param \Closure $f
	 * @param \Array_hx $l1
	 * @param \Array_hx $l2
	 * 
	 * @return bool
	 */
	public static function leq ($f, $l1, $l2) {
		$it_current = 0;
		$_g = 0;
		while ($_g < $l1->length) {
			$e1 = ($l1->arr[$_g++] ?? null);
			if ($it_current >= $l2->length) {
				return false;
			}
			if (!$f($e1, ($l2->arr[$it_current++] ?? null))) {
				return false;
			}
		}
		if ($it_current < $l2->length) {
			return false;
		}
		return true;
	}

	/**
	 * Unlike `r1 == r2`, this function performs a deep equality check on
	 * the given `Rights` instances.
	 * If `r1` or `r2` are `null`, the result is unspecified.
	 * 
	 * @param Rights $r1
	 * @param Rights $r2
	 * 
	 * @return bool
	 */
	public static function rightsEq ($r1, $r2) {
		if ($r1 === $r2) {
			return true;
		}
		if ($r1->index === 2) {
			if ($r2->index === 2) {
				return $r1->params[0] === $r2->params[0];
			}
		}
		return false;
	}

	/**
	 * Unlike `t1 == t2`, this function performs a deep equality check on
	 * the given `CType` instances.
	 * If `t1` or `t2` are `null`, the result is unspecified.
	 * 
	 * @param CType $t1
	 * @param CType $t2
	 * 
	 * @return bool
	 */
	public static function typeEq ($t1, $t2) {
		$__hx__switch = ($t1->index);
		if ($__hx__switch === 0) {
			return $t2 === CType::CUnknown();
		} else if ($__hx__switch === 1) {
			if ($t2->index === 1) {
				if ($t1->params[0] === $t2->params[0]) {
					return TypeApi::leq(Boot::getStaticClosure(TypeApi::class, 'typeEq'), $t1->params[1], $t2->params[1]);
				} else {
					return false;
				}
			}
		} else if ($__hx__switch === 2) {
			if ($t2->index === 2) {
				if ($t1->params[0] === $t2->params[0]) {
					return TypeApi::leq(Boot::getStaticClosure(TypeApi::class, 'typeEq'), $t1->params[1], $t2->params[1]);
				} else {
					return false;
				}
			}
		} else if ($__hx__switch === 3) {
			if ($t2->index === 3) {
				if ($t1->params[0] === $t2->params[0]) {
					return TypeApi::leq(Boot::getStaticClosure(TypeApi::class, 'typeEq'), $t1->params[1], $t2->params[1]);
				} else {
					return false;
				}
			}
		} else if ($__hx__switch === 4) {
			if ($t2->index === 4) {
				if (TypeApi::leq(function ($a, $b) {
					if (($a->name === $b->name) && ($a->opt === $b->opt)) {
						return TypeApi::typeEq($a->t, $b->t);
					} else {
						return false;
					}
				}, $t1->params[0], $t2->params[0])) {
					return TypeApi::typeEq($t1->params[1], $t2->params[1]);
				} else {
					return false;
				}
			}
		} else if ($__hx__switch === 5) {
			if ($t2->index === 5) {
				return TypeApi::leq(function ($a, $b) {
					return TypeApi::fieldEq($a, $b);
				}, $t1->params[0], $t2->params[0]);
			}
		} else if ($__hx__switch === 6) {
			$_g = $t1->params[0];
			if ($t2->index === 6) {
				$_g1 = $t2->params[0];
				if (($_g === null) !== ($_g1 === null)) {
					return false;
				}
				if ($_g !== null) {
					return TypeApi::typeEq($_g, $_g1);
				} else {
					return true;
				}
			}
		} else if ($__hx__switch === 7) {
			if ($t2->index === 7) {
				if ($t1->params[0] === $t2->params[0]) {
					return TypeApi::leq(Boot::getStaticClosure(TypeApi::class, 'typeEq'), $t1->params[1], $t2->params[1]);
				} else {
					return false;
				}
			}
		}
		return false;
	}

	/**
	 * @param TypeTree $t
	 * 
	 * @return object
	 */
	public static function typeInfos ($t) {
		$inf = null;
		$__hx__switch = ($t->index);
		if ($__hx__switch === 0) {
			throw Exception::thrown("Unexpected Package");
		} else if ($__hx__switch === 1) {
			$inf = $t->params[0];
		} else if ($__hx__switch === 2) {
			$inf = $t->params[0];
		} else if ($__hx__switch === 3) {
			$inf = $t->params[0];
		} else if ($__hx__switch === 4) {
			$inf = $t->params[0];
		}
		return $inf;
	}
}

Boot::registerClass(TypeApi::class, 'haxe.rtti.TypeApi');
