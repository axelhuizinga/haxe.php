<?php
/**
 * Generated by Haxe 4.1.4
 */

namespace haxe\rtti;

use \php\_Boot\HxAnon;
use \haxe\xml\_Access\HasAttribAccess_Impl_;
use \php\Boot;
use \haxe\Exception;
use \haxe\xml\_Access\NodeListAccess_Impl_;
use \haxe\xml\_Access\AttribAccess_Impl_;
use \haxe\xml\_Access\HasNodeAccess_Impl_;
use \_Xml\XmlType_Impl_;
use \php\_Boot\HxString;
use \php\_Boot\HxClosure;
use \haxe\ds\StringMap;
use \haxe\xml\_Access\NodeAccess_Impl_;
use \haxe\xml\_Access\Access_Impl_;
use \haxe\iterators\ArrayIterator;

/**
 * XmlParser processes the runtime type information (RTTI) which
 * is stored as a XML string in a static field `__rtti`.
 * @see <https://haxe.org/manual/cr-rtti.html>
 */
class XmlParser {
	/**
	 * @var string
	 */
	public $curplatform;
	/**
	 * @var \Closure
	 */
	public $newField;
	/**
	 * @var \Array_hx
	 */
	public $root;

	/**
	 * @return void
	 */
	public function __construct () {
		if (!$this->__hx__default__newField) {
			$this->__hx__default__newField = new HxClosure($this, 'newField');
			if ($this->newField === null) $this->newField = $this->__hx__default__newField;
		}
		$this->root = new \Array_hx();
	}

	/**
	 * @return \Array_hx
	 */
	public function defplat () {
		$l = new \Array_hx();
		if ($this->curplatform !== null) {
			$l->arr[$l->length++] = $this->curplatform;
		}
		return $l;
	}

	/**
	 * @param TypeTree $t
	 * 
	 * @return void
	 */
	public function merge ($t) {
		$inf = TypeApi::typeInfos($t);
		$pack = HxString::split($inf->path, ".");
		$cur = $this->root;
		$curpack = new \Array_hx();
		if ($pack->length > 0) {
			$pack->length--;
		}
		\array_pop($pack->arr);
		$_g = 0;
		while ($_g < $pack->length) {
			$p = ($pack->arr[$_g] ?? null);
			++$_g;
			$found = false;
			$_g1 = 0;
			while ($_g1 < $cur->length) {
				$pk = ($cur->arr[$_g1] ?? null);
				++$_g1;
				if ($pk->index === 0) {
					if ($pk->params[0] === $p) {
						$found = true;
						$cur = $pk->params[2];
						break;
					}
				}
			}
			$curpack->arr[$curpack->length++] = $p;
			if (!$found) {
				$pk1 = new \Array_hx();
				$x = TypeTree::TPackage($p, $curpack->join("."), $pk1);
				$cur->arr[$cur->length++] = $x;
				$cur = $pk1;
			}
		}
		$_g = 0;
		while ($_g < $cur->length) {
			$ct = ($cur->arr[$_g] ?? null);
			++$_g;
			if ($ct->index === 0) {
				continue;
			}
			$tinf = TypeApi::typeInfos($ct);
			if ($tinf->path === $inf->path) {
				$sameType = true;
				if (($tinf->doc === null) !== ($inf->doc === null)) {
					if ($inf->doc === null) {
						$inf->doc = $tinf->doc;
					} else {
						$tinf->doc = $inf->doc;
					}
				}
				if ($tinf->path === "haxe._Int64.NativeInt64") {
					continue;
				}
				if (($tinf->module === $inf->module) && ($tinf->doc === $inf->doc) && ($tinf->isPrivate === $inf->isPrivate)) {
					$__hx__switch = ($ct->index);
					if ($__hx__switch === 0) {
						$sameType = false;
					} else if ($__hx__switch === 1) {
						if ($t->index === 1) {
							if ($this->mergeClasses($ct->params[0], $t->params[0])) {
								return;
							}
						} else {
							$sameType = false;
						}
					} else if ($__hx__switch === 2) {
						if ($t->index === 2) {
							if ($this->mergeEnums($ct->params[0], $t->params[0])) {
								return;
							}
						} else {
							$sameType = false;
						}
					} else if ($__hx__switch === 3) {
						if ($t->index === 3) {
							if ($this->mergeTypedefs($ct->params[0], $t->params[0])) {
								return;
							}
						}
					} else if ($__hx__switch === 4) {
						if ($t->index === 4) {
							if ($this->mergeAbstracts($ct->params[0], $t->params[0])) {
								return;
							}
						} else {
							$sameType = false;
						}
					}
				}
				$msg = ($tinf->module !== $inf->module ? "module " . ($inf->module??'null') . " should be " . ($tinf->module??'null') : ($tinf->doc !== $inf->doc ? "documentation is different" : ($tinf->isPrivate !== $inf->isPrivate ? "private flag is different" : (!$sameType ? "type kind is different" : "could not merge definition"))));
				throw Exception::thrown("Incompatibilities between " . ($tinf->path??'null') . " in " . ($tinf->platforms->join(",")??'null') . " and " . ($this->curplatform??'null') . " (" . ($msg??'null') . ")");
			}
		}
		$cur->arr[$cur->length++] = $t;
	}

	/**
	 * @param object $a
	 * @param object $a2
	 * 
	 * @return bool
	 */
	public function mergeAbstracts ($a, $a2) {
		if ($this->curplatform === null) {
			return false;
		}
		if (($a->to->length !== $a2->to->length) || ($a->from->length !== $a2->from->length)) {
			return false;
		}
		$_g = 0;
		$_g1 = $a->to->length;
		while ($_g < $_g1) {
			$i = $_g++;
			if (!TypeApi::typeEq(($a->to->arr[$i] ?? null)->t, ($a2->to->arr[$i] ?? null)->t)) {
				return false;
			}
		}
		$_g = 0;
		$_g1 = $a->from->length;
		while ($_g < $_g1) {
			$i = $_g++;
			if (!TypeApi::typeEq(($a->from->arr[$i] ?? null)->t, ($a2->from->arr[$i] ?? null)->t)) {
				return false;
			}
		}
		if ($a2->impl !== null) {
			$this->mergeClasses($a->impl, $a2->impl);
		}
		$_this = $a->platforms;
		$_this->arr[$_this->length++] = $this->curplatform;
		return true;
	}

	/**
	 * @param object $c
	 * @param object $c2
	 * 
	 * @return bool
	 */
	public function mergeClasses ($c, $c2) {
		if ($c->isInterface !== $c2->isInterface) {
			return false;
		}
		if ($this->curplatform !== null) {
			$_this = $c->platforms;
			$_this->arr[$_this->length++] = $this->curplatform;
		}
		if ($c->isExtern !== $c2->isExtern) {
			$c->isExtern = false;
		}
		$_g = 0;
		$_g1 = $c2->fields;
		while ($_g < $_g1->length) {
			$f2 = ($_g1->arr[$_g] ?? null);
			++$_g;
			$found = null;
			$_g2 = 0;
			$_g3 = $c->fields;
			while ($_g2 < $_g3->length) {
				$f = ($_g3->arr[$_g2] ?? null);
				++$_g2;
				if ($this->mergeFields($f, $f2)) {
					$found = $f;
					break;
				}
			}
			if ($found === null) {
				$this->newField($c, $f2);
				$_this = $c->fields;
				$_this->arr[$_this->length++] = $f2;
			} else if ($this->curplatform !== null) {
				$_this1 = $found->platforms;
				$_this1->arr[$_this1->length++] = $this->curplatform;
			}
		}
		$_g = 0;
		$_g1 = $c2->statics;
		while ($_g < $_g1->length) {
			$f2 = ($_g1->arr[$_g] ?? null);
			++$_g;
			$found = null;
			$_g2 = 0;
			$_g3 = $c->statics;
			while ($_g2 < $_g3->length) {
				$f = ($_g3->arr[$_g2] ?? null);
				++$_g2;
				if ($this->mergeFields($f, $f2)) {
					$found = $f;
					break;
				}
			}
			if ($found === null) {
				$this->newField($c, $f2);
				$_this = $c->statics;
				$_this->arr[$_this->length++] = $f2;
			} else if ($this->curplatform !== null) {
				$_this1 = $found->platforms;
				$_this1->arr[$_this1->length++] = $this->curplatform;
			}
		}
		return true;
	}

	/**
	 * @param object $f1
	 * @param object $f2
	 * 
	 * @return bool
	 */
	public function mergeDoc ($f1, $f2) {
		if ($f1->doc === null) {
			$f1->doc = $f2->doc;
		} else if ($f2->doc === null) {
			$f2->doc = $f1->doc;
		}
		return true;
	}

	/**
	 * @param object $e
	 * @param object $e2
	 * 
	 * @return bool
	 */
	public function mergeEnums ($e, $e2) {
		if ($e->isExtern !== $e2->isExtern) {
			return false;
		}
		if ($this->curplatform !== null) {
			$_this = $e->platforms;
			$_this->arr[$_this->length++] = $this->curplatform;
		}
		$_g = 0;
		$_g1 = $e2->constructors;
		while ($_g < $_g1->length) {
			$c2 = ($_g1->arr[$_g] ?? null);
			++$_g;
			$found = null;
			$_g2 = 0;
			$_g3 = $e->constructors;
			while ($_g2 < $_g3->length) {
				$c = ($_g3->arr[$_g2] ?? null);
				++$_g2;
				if (TypeApi::constructorEq($c, $c2)) {
					$found = $c;
					break;
				}
			}
			if ($found === null) {
				$_this = $e->constructors;
				$_this->arr[$_this->length++] = $c2;
			} else if ($this->curplatform !== null) {
				$_this1 = $found->platforms;
				$_this1->arr[$_this1->length++] = $this->curplatform;
			}
		}
		return true;
	}

	/**
	 * @param object $f
	 * @param object $f2
	 * 
	 * @return bool
	 */
	public function mergeFields ($f, $f2) {
		if (!TypeApi::fieldEq($f, $f2)) {
			if (($f->name === $f2->name) && ($this->mergeRights($f, $f2) || $this->mergeRights($f2, $f)) && $this->mergeDoc($f, $f2)) {
				return TypeApi::fieldEq($f, $f2);
			} else {
				return false;
			}
		} else {
			return true;
		}
	}

	/**
	 * @param object $f1
	 * @param object $f2
	 * 
	 * @return bool
	 */
	public function mergeRights ($f1, $f2) {
		if (($f1->get === Rights::RInline()) && ($f1->set === Rights::RNo()) && ($f2->get === Rights::RNormal()) && ($f2->set === Rights::RMethod())) {
			$f1->get = Rights::RNormal();
			$f1->set = Rights::RMethod();
			return true;
		}
		if (\Type::enumEq($f1->get, $f2->get)) {
			return \Type::enumEq($f1->set, $f2->set);
		} else {
			return false;
		}
	}

	/**
	 * @param object $t
	 * @param object $t2
	 * 
	 * @return bool
	 */
	public function mergeTypedefs ($t, $t2) {
		if ($this->curplatform === null) {
			return false;
		}
		$_this = $t->platforms;
		$_this->arr[$_this->length++] = $this->curplatform;
		$t->types->data[$this->curplatform] = $t2->type;
		return true;
	}

	/**
	 * @param string $p
	 * 
	 * @return string
	 */
	public function mkPath ($p) {
		return $p;
	}

	/**
	 * @param string $r
	 * 
	 * @return Rights
	 */
	public function mkRights ($r) {
		if ($r === "dynamic") {
			return Rights::RDynamic();
		} else if ($r === "inline") {
			return Rights::RInline();
		} else if ($r === "method") {
			return Rights::RMethod();
		} else if ($r === "null") {
			return Rights::RNo();
		} else {
			return Rights::RCall($r);
		}
	}

	/**
	 * @param string $p
	 * 
	 * @return \Array_hx
	 */
	public function mkTypeParams ($p) {
		$pl = HxString::split($p, ":");
		if (($pl->arr[0] ?? null) === "") {
			return new \Array_hx();
		}
		return $pl;
	}

	/**
	 * @param object $c
	 * @param object $f
	 * 
	 * @return void
	 */
	public function newField ($c, $f)
	{
		if ($this->newField !== $this->__hx__default__newField) return call_user_func_array($this->newField, func_get_args());
	}
	protected $__hx__default__newField;

	/**
	 * @param \Xml $x
	 * @param string $platform
	 * 
	 * @return void
	 */
	public function process ($x, $platform) {
		$this->curplatform = $platform;
		if (($x->nodeType !== \Xml::$Document) && ($x->nodeType !== \Xml::$Element)) {
			throw Exception::thrown("Invalid nodeType " . ((($x->nodeType === null ? "null" : XmlType_Impl_::toString($x->nodeType)))??'null'));
		}
		$this->xroot($x);
	}

	/**
	 * @param \Xml $x
	 * 
	 * @return TypeTree
	 */
	public function processElement ($x) {
		if (($x->nodeType !== \Xml::$Document) && ($x->nodeType !== \Xml::$Element)) {
			throw Exception::thrown("Invalid nodeType " . ((($x->nodeType === null ? "null" : XmlType_Impl_::toString($x->nodeType)))??'null'));
		}
		$c = $x;
		$_g = null;
		if ($c->nodeType === \Xml::$Document) {
			$_g = "Document";
		} else {
			if ($c->nodeType !== \Xml::$Element) {
				throw Exception::thrown("Bad node type, expected Element but found " . ((($c->nodeType === null ? "null" : XmlType_Impl_::toString($c->nodeType)))??'null'));
			}
			$_g = $c->nodeName;
		}
		if ($_g === "abstract") {
			return TypeTree::TAbstractdecl($this->xabstract($c));
		} else if ($_g === "class") {
			return TypeTree::TClassdecl($this->xclass($c));
		} else if ($_g === "enum") {
			return TypeTree::TEnumdecl($this->xenum($c));
		} else if ($_g === "typedef") {
			return TypeTree::TTypedecl($this->xtypedef($c));
		} else {
			return $this->xerror($c);
		}
	}

	/**
	 * @param \Array_hx $l
	 * 
	 * @return void
	 */
	public function sort ($l = null) {
		if ($l === null) {
			$l = $this->root;
		}
		\usort($l->arr, function ($e1, $e2) {
			if (strcmp((($e1->index === 0 ? " " . ($e1->params[0]??'null') : TypeApi::typeInfos($e1)->path)), (($e2->index === 0 ? " " . ($e2->params[0]??'null') : TypeApi::typeInfos($e2)->path))) > 0) {
				return 1;
			}
			return -1;
		});
		$_g = 0;
		while ($_g < $l->length) {
			$x = ($l->arr[$_g] ?? null);
			++$_g;
			$__hx__switch = ($x->index);
			if ($__hx__switch === 0) {
				$this->sort($x->params[2]);
			} else if ($__hx__switch === 1) {
				$_g1 = $x->params[0];
				$this->sortFields($_g1->fields);
				$this->sortFields($_g1->statics);
			} else if ($__hx__switch === 2) {
			} else if ($__hx__switch === 3) {
			} else if ($__hx__switch === 4) {
			}
		}
	}

	/**
	 * @param \Array_hx $a
	 * 
	 * @return void
	 */
	public function sortFields ($a) {
		\usort($a->arr, function ($f1, $f2) {
			$v1 = TypeApi::isVar($f1->type);
			$v2 = TypeApi::isVar($f2->type);
			if ($v1 && !$v2) {
				return -1;
			}
			if ($v2 && !$v1) {
				return 1;
			}
			if ($f1->name === "new") {
				return -1;
			}
			if ($f2->name === "new") {
				return 1;
			}
			if (strcmp($f1->name, $f2->name) > 0) {
				return 1;
			}
			return -1;
		});
	}

	/**
	 * @param \Xml $x
	 * 
	 * @return object
	 */
	public function xabstract ($x) {
		$doc = null;
		$impl = null;
		$athis = null;
		$meta = new \Array_hx();
		$to = new \Array_hx();
		$from = new \Array_hx();
		$c = $x->elements();
		while ($c->hasNext()) {
			$c1 = $c->next();
			$_g = null;
			if ($c1->nodeType === \Xml::$Document) {
				$_g = "Document";
			} else {
				if ($c1->nodeType !== \Xml::$Element) {
					throw Exception::thrown("Bad node type, expected Element but found " . ((($c1->nodeType === null ? "null" : XmlType_Impl_::toString($c1->nodeType)))??'null'));
				}
				$_g = $c1->nodeName;
			}
			if ($_g === "from") {
				$t = $c1->elements();
				while ($t->hasNext()) {
					$t1 = $t->next();
					$x1 = $t1->firstElement();
					if (($x1->nodeType !== \Xml::$Document) && ($x1->nodeType !== \Xml::$Element)) {
						throw Exception::thrown("Invalid nodeType " . ((($x1->nodeType === null ? "null" : XmlType_Impl_::toString($x1->nodeType)))??'null'));
					}
					$x2 = $this->xtype($x1);
					$x3 = (HasAttribAccess_Impl_::resolve($t1, "field") ? AttribAccess_Impl_::resolve($t1, "field") : null);
					$from->arr[$from->length++] = new HxAnon([
						"t" => $x2,
						"field" => $x3,
					]);
				}
			} else if ($_g === "haxe_doc") {
				$doc = Access_Impl_::get_innerData($c1);
			} else if ($_g === "impl") {
				$impl = $this->xclass(NodeAccess_Impl_::resolve($c1, "class"));
			} else if ($_g === "meta") {
				$meta = $this->xmeta($c1);
			} else if ($_g === "this") {
				$x4 = $c1->firstElement();
				if (($x4->nodeType !== \Xml::$Document) && ($x4->nodeType !== \Xml::$Element)) {
					throw Exception::thrown("Invalid nodeType " . ((($x4->nodeType === null ? "null" : XmlType_Impl_::toString($x4->nodeType)))??'null'));
				}
				$athis = $this->xtype($x4);
			} else if ($_g === "to") {
				$t2 = $c1->elements();
				while ($t2->hasNext()) {
					$t3 = $t2->next();
					$x5 = $t3->firstElement();
					if (($x5->nodeType !== \Xml::$Document) && ($x5->nodeType !== \Xml::$Element)) {
						throw Exception::thrown("Invalid nodeType " . ((($x5->nodeType === null ? "null" : XmlType_Impl_::toString($x5->nodeType)))??'null'));
					}
					$x6 = $this->xtype($x5);
					$x7 = (HasAttribAccess_Impl_::resolve($t3, "field") ? AttribAccess_Impl_::resolve($t3, "field") : null);
					$to->arr[$to->length++] = new HxAnon([
						"t" => $x6,
						"field" => $x7,
					]);
				}
			} else {
				$this->xerror($c1);
			}
		}
		$tmp = (HasAttribAccess_Impl_::resolve($x, "file") ? AttribAccess_Impl_::resolve($x, "file") : null);
		$tmp1 = $this->mkPath(AttribAccess_Impl_::resolve($x, "path"));
		$tmp2 = (HasAttribAccess_Impl_::resolve($x, "module") ? $this->mkPath(AttribAccess_Impl_::resolve($x, "module")) : null);
		$tmp3 = $x->exists("private");
		$tmp4 = $this->mkTypeParams(AttribAccess_Impl_::resolve($x, "params"));
		return new HxAnon([
			"file" => $tmp,
			"path" => $tmp1,
			"module" => $tmp2,
			"doc" => $doc,
			"isPrivate" => $tmp3,
			"params" => $tmp4,
			"platforms" => $this->defplat(),
			"meta" => $meta,
			"athis" => $athis,
			"to" => $to,
			"from" => $from,
			"impl" => $impl,
		]);
	}

	/**
	 * @param \Xml $x
	 * 
	 * @return object
	 */
	public function xclass ($x) {
		$csuper = null;
		$doc = null;
		$tdynamic = null;
		$interfaces = new \Array_hx();
		$fields = new \Array_hx();
		$statics = new \Array_hx();
		$meta = new \Array_hx();
		$isInterface = $x->exists("interface");
		$c = $x->elements();
		while ($c->hasNext()) {
			$c1 = $c->next();
			$_g = null;
			if ($c1->nodeType === \Xml::$Document) {
				$_g = "Document";
			} else {
				if ($c1->nodeType !== \Xml::$Element) {
					throw Exception::thrown("Bad node type, expected Element but found " . ((($c1->nodeType === null ? "null" : XmlType_Impl_::toString($c1->nodeType)))??'null'));
				}
				$_g = $c1->nodeName;
			}
			if ($_g === "extends") {
				if ($isInterface) {
					$x1 = $this->xpath($c1);
					$interfaces->arr[$interfaces->length++] = $x1;
				} else {
					$csuper = $this->xpath($c1);
				}
			} else if ($_g === "haxe_doc") {
				$doc = Access_Impl_::get_innerData($c1);
			} else if ($_g === "haxe_dynamic") {
				$x2 = $c1->firstElement();
				if (($x2->nodeType !== \Xml::$Document) && ($x2->nodeType !== \Xml::$Element)) {
					throw Exception::thrown("Invalid nodeType " . ((($x2->nodeType === null ? "null" : XmlType_Impl_::toString($x2->nodeType)))??'null'));
				}
				$tdynamic = $this->xtype($x2);
			} else if ($_g === "implements") {
				$x3 = $this->xpath($c1);
				$interfaces->arr[$interfaces->length++] = $x3;
			} else if ($_g === "meta") {
				$meta = $this->xmeta($c1);
			} else {
				if ($c1->exists("static")) {
					$x4 = $this->xclassfield($c1);
					$statics->arr[$statics->length++] = $x4;
				} else {
					$x5 = $this->xclassfield($c1);
					$fields->arr[$fields->length++] = $x5;
				}
			}
		}
		$tmp = (HasAttribAccess_Impl_::resolve($x, "file") ? AttribAccess_Impl_::resolve($x, "file") : null);
		$tmp1 = $this->mkPath(AttribAccess_Impl_::resolve($x, "path"));
		$tmp2 = (HasAttribAccess_Impl_::resolve($x, "module") ? $this->mkPath(AttribAccess_Impl_::resolve($x, "module")) : null);
		$tmp3 = $x->exists("private");
		$tmp4 = $x->exists("extern");
		$tmp5 = $x->exists("final");
		$tmp6 = $this->mkTypeParams(AttribAccess_Impl_::resolve($x, "params"));
		return new HxAnon([
			"file" => $tmp,
			"path" => $tmp1,
			"module" => $tmp2,
			"doc" => $doc,
			"isPrivate" => $tmp3,
			"isExtern" => $tmp4,
			"isFinal" => $tmp5,
			"isInterface" => $isInterface,
			"params" => $tmp6,
			"superClass" => $csuper,
			"interfaces" => $interfaces,
			"fields" => $fields,
			"statics" => $statics,
			"tdynamic" => $tdynamic,
			"platforms" => $this->defplat(),
			"meta" => $meta,
		]);
	}

	/**
	 * @param \Xml $x
	 * @param bool $defPublic
	 * 
	 * @return object
	 */
	public function xclassfield ($x, $defPublic = false) {
		if ($defPublic === null) {
			$defPublic = false;
		}
		$e = $x->elements();
		$t = $this->xtype($e->next());
		$doc = null;
		$meta = new \Array_hx();
		$overloads = null;
		while ($e->hasNext()) {
			$c = $e->next();
			$_g = null;
			if ($c->nodeType === \Xml::$Document) {
				$_g = "Document";
			} else {
				if ($c->nodeType !== \Xml::$Element) {
					throw Exception::thrown("Bad node type, expected Element but found " . ((($c->nodeType === null ? "null" : XmlType_Impl_::toString($c->nodeType)))??'null'));
				}
				$_g = $c->nodeName;
			}
			if ($_g === "haxe_doc") {
				$doc = Access_Impl_::get_innerData($c);
			} else if ($_g === "meta") {
				$meta = $this->xmeta($c);
			} else if ($_g === "overloads") {
				$overloads = $this->xoverloads($c);
			} else {
				$this->xerror($c);
			}
		}
		$tmp = null;
		if ($x->nodeType === \Xml::$Document) {
			$tmp = "Document";
		} else {
			if ($x->nodeType !== \Xml::$Element) {
				throw Exception::thrown("Bad node type, expected Element but found " . ((($x->nodeType === null ? "null" : XmlType_Impl_::toString($x->nodeType)))??'null'));
			}
			$tmp = $x->nodeName;
		}
		$tmp1 = $x->exists("public") || $defPublic;
		$tmp2 = $x->exists("final");
		$tmp3 = $x->exists("override");
		$tmp4 = (HasAttribAccess_Impl_::resolve($x, "line") ? \Std::parseInt(AttribAccess_Impl_::resolve($x, "line")) : null);
		$tmp5 = (HasAttribAccess_Impl_::resolve($x, "get") ? $this->mkRights(AttribAccess_Impl_::resolve($x, "get")) : Rights::RNormal());
		$tmp6 = (HasAttribAccess_Impl_::resolve($x, "set") ? $this->mkRights(AttribAccess_Impl_::resolve($x, "set")) : Rights::RNormal());
		$tmp7 = (HasAttribAccess_Impl_::resolve($x, "params") ? $this->mkTypeParams(AttribAccess_Impl_::resolve($x, "params")) : new \Array_hx());
		$tmp8 = $this->defplat();
		return new HxAnon([
			"name" => $tmp,
			"type" => $t,
			"isPublic" => $tmp1,
			"isFinal" => $tmp2,
			"isOverride" => $tmp3,
			"line" => $tmp4,
			"doc" => $doc,
			"get" => $tmp5,
			"set" => $tmp6,
			"params" => $tmp7,
			"platforms" => $tmp8,
			"meta" => $meta,
			"overloads" => $overloads,
			"expr" => (HasAttribAccess_Impl_::resolve($x, "expr") ? AttribAccess_Impl_::resolve($x, "expr") : null),
		]);
	}

	/**
	 * @param \Xml $x
	 * 
	 * @return object
	 */
	public function xenum ($x) {
		$cl = new \Array_hx();
		$doc = null;
		$meta = new \Array_hx();
		$c = $x->elements();
		while ($c->hasNext()) {
			$c1 = $c->next();
			$tmp = null;
			if ($c1->nodeType === \Xml::$Document) {
				$tmp = "Document";
			} else {
				if ($c1->nodeType !== \Xml::$Element) {
					throw Exception::thrown("Bad node type, expected Element but found " . ((($c1->nodeType === null ? "null" : XmlType_Impl_::toString($c1->nodeType)))??'null'));
				}
				$tmp = $c1->nodeName;
			}
			if ($tmp === "haxe_doc") {
				$doc = Access_Impl_::get_innerData($c1);
			} else {
				$tmp1 = null;
				if ($c1->nodeType === \Xml::$Document) {
					$tmp1 = "Document";
				} else {
					if ($c1->nodeType !== \Xml::$Element) {
						throw Exception::thrown("Bad node type, expected Element but found " . ((($c1->nodeType === null ? "null" : XmlType_Impl_::toString($c1->nodeType)))??'null'));
					}
					$tmp1 = $c1->nodeName;
				}
				if ($tmp1 === "meta") {
					$meta = $this->xmeta($c1);
				} else {
					$x1 = $this->xenumfield($c1);
					$cl->arr[$cl->length++] = $x1;
				}
			}
		}
		$tmp = (HasAttribAccess_Impl_::resolve($x, "file") ? AttribAccess_Impl_::resolve($x, "file") : null);
		$tmp1 = $this->mkPath(AttribAccess_Impl_::resolve($x, "path"));
		$tmp2 = (HasAttribAccess_Impl_::resolve($x, "module") ? $this->mkPath(AttribAccess_Impl_::resolve($x, "module")) : null);
		$tmp3 = $x->exists("private");
		$tmp4 = $x->exists("extern");
		$tmp5 = $this->mkTypeParams(AttribAccess_Impl_::resolve($x, "params"));
		return new HxAnon([
			"file" => $tmp,
			"path" => $tmp1,
			"module" => $tmp2,
			"doc" => $doc,
			"isPrivate" => $tmp3,
			"isExtern" => $tmp4,
			"params" => $tmp5,
			"constructors" => $cl,
			"platforms" => $this->defplat(),
			"meta" => $meta,
		]);
	}

	/**
	 * @param \Xml $x
	 * 
	 * @return object
	 */
	public function xenumfield ($x) {
		$args = null;
		$docElements = $x->elementsNamed("haxe_doc");
		$xdoc = ($docElements->hasNext() ? $docElements->next() : null);
		$meta = (HasNodeAccess_Impl_::resolve($x, "meta") ? $this->xmeta(NodeAccess_Impl_::resolve($x, "meta")) : new \Array_hx());
		if (HasAttribAccess_Impl_::resolve($x, "a")) {
			$names = HxString::split(AttribAccess_Impl_::resolve($x, "a"), ":");
			$elts = $x->elements();
			$args = new \Array_hx();
			$_g = 0;
			while ($_g < $names->length) {
				$c = ($names->arr[$_g] ?? null);
				++$_g;
				$opt = false;
				if (\mb_substr($c, 0, 1) === "?") {
					$opt = true;
					$c = \mb_substr($c, 1, null);
				}
				$x1 = new HxAnon([
					"name" => $c,
					"opt" => $opt,
					"t" => $this->xtype($elts->next()),
				]);
				$args->arr[$args->length++] = $x1;
			}
		}
		$tmp = null;
		if ($x->nodeType === \Xml::$Document) {
			$tmp = "Document";
		} else {
			if ($x->nodeType !== \Xml::$Element) {
				throw Exception::thrown("Bad node type, expected Element but found " . ((($x->nodeType === null ? "null" : XmlType_Impl_::toString($x->nodeType)))??'null'));
			}
			$tmp = $x->nodeName;
		}
		$tmp1 = null;
		if ($xdoc === null) {
			$tmp1 = null;
		} else {
			if (($xdoc->nodeType !== \Xml::$Document) && ($xdoc->nodeType !== \Xml::$Element)) {
				throw Exception::thrown("Invalid nodeType " . ((($xdoc->nodeType === null ? "null" : XmlType_Impl_::toString($xdoc->nodeType)))??'null'));
			}
			$tmp1 = Access_Impl_::get_innerData($xdoc);
		}
		return new HxAnon([
			"name" => $tmp,
			"args" => $args,
			"doc" => $tmp1,
			"meta" => $meta,
			"platforms" => $this->defplat(),
		]);
	}

	/**
	 * @param \Xml $c
	 * 
	 * @return mixed
	 */
	public function xerror ($c) {
		$tmp = null;
		if ($c->nodeType === \Xml::$Document) {
			$tmp = "Document";
		} else {
			if ($c->nodeType !== \Xml::$Element) {
				throw Exception::thrown("Bad node type, expected Element but found " . ((($c->nodeType === null ? "null" : XmlType_Impl_::toString($c->nodeType)))??'null'));
			}
			$tmp = $c->nodeName;
		}
		throw Exception::thrown("Invalid " . ($tmp??'null'));
	}

	/**
	 * @param \Xml $x
	 * 
	 * @return \Array_hx
	 */
	public function xmeta ($x) {
		$ml = new \Array_hx();
		$_g = 0;
		$_g1 = NodeListAccess_Impl_::resolve($x, "m");
		while ($_g < $_g1->length) {
			$m = ($_g1->arr[$_g] ?? null);
			++$_g;
			$pl = new \Array_hx();
			$_g2 = 0;
			$_g3 = NodeListAccess_Impl_::resolve($m, "e");
			while ($_g2 < $_g3->length) {
				$x = Access_Impl_::get_innerHTML(($_g3->arr[$_g2++] ?? null));
				$pl->arr[$pl->length++] = $x;
			}
			$x1 = new HxAnon([
				"name" => AttribAccess_Impl_::resolve($m, "n"),
				"params" => $pl,
			]);
			$ml->arr[$ml->length++] = $x1;
		}
		return $ml;
	}

	/**
	 * @param \Xml $x
	 * 
	 * @return \Array_hx
	 */
	public function xoverloads ($x) {
		$l = new \Array_hx();
		$m = $x->elements();
		while ($m->hasNext()) {
			$x = $this->xclassfield($m->next());
			$l->arr[$l->length++] = $x;
		}
		return $l;
	}

	/**
	 * @param \Xml $x
	 * 
	 * @return object
	 */
	public function xpath ($x) {
		$path = $this->mkPath(AttribAccess_Impl_::resolve($x, "path"));
		$params = new \Array_hx();
		$c = $x->elements();
		while ($c->hasNext()) {
			$x = $this->xtype($c->next());
			$params->arr[$params->length++] = $x;
		}
		return new HxAnon([
			"path" => $path,
			"params" => $params,
		]);
	}

	/**
	 * @param \Xml $x
	 * 
	 * @return void
	 */
	public function xroot ($x) {
		$c = $x->elements();
		while ($c->hasNext()) {
			$this->merge($this->processElement($c->next()));
		}
	}

	/**
	 * @param \Xml $x
	 * 
	 * @return CType
	 */
	public function xtype ($x) {
		$_g = null;
		if ($x->nodeType === \Xml::$Document) {
			$_g = "Document";
		} else {
			if ($x->nodeType !== \Xml::$Element) {
				throw Exception::thrown("Bad node type, expected Element but found " . ((($x->nodeType === null ? "null" : XmlType_Impl_::toString($x->nodeType)))??'null'));
			}
			$_g = $x->nodeName;
		}
		if ($_g === "a") {
			$fields = new \Array_hx();
			$f = $x->elements();
			while ($f->hasNext()) {
				$f1 = $this->xclassfield($f->next(), true);
				$f1->platforms = new \Array_hx();
				$fields->arr[$fields->length++] = $f1;
			}
			return CType::CAnonymous($fields);
		} else if ($_g === "c") {
			$tmp = $this->mkPath(AttribAccess_Impl_::resolve($x, "path"));
			return CType::CClass($tmp, $this->xtypeparams($x));
		} else if ($_g === "d") {
			$t = null;
			$tx = $x->firstElement();
			if ($tx !== null) {
				if (($tx->nodeType !== \Xml::$Document) && ($tx->nodeType !== \Xml::$Element)) {
					throw Exception::thrown("Invalid nodeType " . ((($tx->nodeType === null ? "null" : XmlType_Impl_::toString($tx->nodeType)))??'null'));
				}
				$t = $this->xtype($tx);
			}
			return CType::CDynamic($t);
		} else if ($_g === "e") {
			$tmp = $this->mkPath(AttribAccess_Impl_::resolve($x, "path"));
			return CType::CEnum($tmp, $this->xtypeparams($x));
		} else if ($_g === "f") {
			$args = new \Array_hx();
			$aname = HxString::split(AttribAccess_Impl_::resolve($x, "a"), ":");
			$eargs_current = 0;
			$evalues = (HasAttribAccess_Impl_::resolve($x, "v") ? new ArrayIterator(HxString::split(AttribAccess_Impl_::resolve($x, "v"), ":")) : null);
			$e = $x->elements();
			while ($e->hasNext()) {
				$e1 = $e->next();
				$opt = false;
				$a = ($eargs_current < $aname->length ? ($aname->arr[$eargs_current++] ?? null) : null);
				if ($a === null) {
					$a = "";
				}
				if (\mb_substr($a, 0, 1) === "?") {
					$opt = true;
					$a = \mb_substr($a, 1, null);
				}
				$v = (($evalues === null) || ($evalues->current >= $evalues->array->length) ? null : ($evalues->array->arr[$evalues->current++] ?? null));
				$x1 = $this->xtype($e1);
				$args->arr[$args->length++] = new HxAnon([
					"name" => $a,
					"opt" => $opt,
					"t" => $x1,
					"value" => ($v === "" ? null : $v),
				]);
			}
			$ret = ($args->arr[$args->length - 1] ?? null);
			$args->remove($ret);
			return CType::CFunction($args, $ret->t);
		} else if ($_g === "t") {
			$tmp = $this->mkPath(AttribAccess_Impl_::resolve($x, "path"));
			return CType::CTypedef($tmp, $this->xtypeparams($x));
		} else if ($_g === "unknown") {
			return CType::CUnknown();
		} else if ($_g === "x") {
			$tmp = $this->mkPath(AttribAccess_Impl_::resolve($x, "path"));
			return CType::CAbstract($tmp, $this->xtypeparams($x));
		} else {
			return $this->xerror($x);
		}
	}

	/**
	 * @param \Xml $x
	 * 
	 * @return object
	 */
	public function xtypedef ($x) {
		$doc = null;
		$t = null;
		$meta = new \Array_hx();
		$c = $x->elements();
		while ($c->hasNext()) {
			$c1 = $c->next();
			$tmp = null;
			if ($c1->nodeType === \Xml::$Document) {
				$tmp = "Document";
			} else {
				if ($c1->nodeType !== \Xml::$Element) {
					throw Exception::thrown("Bad node type, expected Element but found " . ((($c1->nodeType === null ? "null" : XmlType_Impl_::toString($c1->nodeType)))??'null'));
				}
				$tmp = $c1->nodeName;
			}
			if ($tmp === "haxe_doc") {
				$doc = Access_Impl_::get_innerData($c1);
			} else {
				$tmp1 = null;
				if ($c1->nodeType === \Xml::$Document) {
					$tmp1 = "Document";
				} else {
					if ($c1->nodeType !== \Xml::$Element) {
						throw Exception::thrown("Bad node type, expected Element but found " . ((($c1->nodeType === null ? "null" : XmlType_Impl_::toString($c1->nodeType)))??'null'));
					}
					$tmp1 = $c1->nodeName;
				}
				if ($tmp1 === "meta") {
					$meta = $this->xmeta($c1);
				} else {
					$t = $this->xtype($c1);
				}
			}
		}
		$types = new StringMap();
		if ($this->curplatform !== null) {
			$types->data[$this->curplatform] = $t;
		}
		$tmp = (HasAttribAccess_Impl_::resolve($x, "file") ? AttribAccess_Impl_::resolve($x, "file") : null);
		$tmp1 = $this->mkPath(AttribAccess_Impl_::resolve($x, "path"));
		$tmp2 = (HasAttribAccess_Impl_::resolve($x, "module") ? $this->mkPath(AttribAccess_Impl_::resolve($x, "module")) : null);
		$tmp3 = $x->exists("private");
		$tmp4 = $this->mkTypeParams(AttribAccess_Impl_::resolve($x, "params"));
		return new HxAnon([
			"file" => $tmp,
			"path" => $tmp1,
			"module" => $tmp2,
			"doc" => $doc,
			"isPrivate" => $tmp3,
			"params" => $tmp4,
			"type" => $t,
			"types" => $types,
			"platforms" => $this->defplat(),
			"meta" => $meta,
		]);
	}

	/**
	 * @param \Xml $x
	 * 
	 * @return \Array_hx
	 */
	public function xtypeparams ($x) {
		$p = new \Array_hx();
		$c = $x->elements();
		while ($c->hasNext()) {
			$x = $this->xtype($c->next());
			$p->arr[$p->length++] = $x;
		}
		return $p;
	}
}

Boot::registerClass(XmlParser::class, 'haxe.rtti.XmlParser');
