<?php
/**
 * Generated by Haxe 4.1.5
 */

namespace haxe\iterators;

use \php\Boot;

class StringIteratorUnicode {
	/**
	 * @var int
	 */
	public $byteOffset;
	/**
	 * @var mixed
	 */
	public $s;
	/**
	 * @var int
	 */
	public $totalBytes;

	/**
	 * @param string $s
	 * 
	 * @return StringIteratorUnicode
	 */
	public static function unicodeIterator ($s) {
		return new StringIteratorUnicode($s);
	}

	/**
	 * @param string $s
	 * 
	 * @return void
	 */
	public function __construct ($s) {
		$this->byteOffset = 0;
		$this->s = $s;
		$this->totalBytes = \strlen($s);
	}

	/**
	 * @return bool
	 */
	public function hasNext () {
		return $this->byteOffset < $this->totalBytes;
	}

	/**
	 * @return int
	 */
	public function next () {
		$code = \ord($this->s[$this->byteOffset]);
		if ($code < 192) {
			$this->byteOffset++;
		} else if ($code < 224) {
			$code = (($code - 192) << 6) + \ord($this->s[$this->byteOffset + 1]) - 128;
			$this->byteOffset += 2;
		} else if ($code < 240) {
			$code = (($code - 224) << 12) + ((\ord($this->s[$this->byteOffset + 1]) - 128) << 6) + \ord($this->s[$this->byteOffset + 2]) - 128;
			$this->byteOffset += 3;
		} else {
			$code = (($code - 240) << 18) + ((\ord($this->s[$this->byteOffset + 1]) - 128) << 12) + ((\ord($this->s[$this->byteOffset + 2]) - 128) << 6) + \ord($this->s[$this->byteOffset + 3]) - 128;
			$this->byteOffset += 4;
		}
		return $code;
	}
}

Boot::registerClass(StringIteratorUnicode::class, 'haxe.iterators.StringIteratorUnicode');
