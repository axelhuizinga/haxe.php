<?php
/**
 * Generated by Haxe 4.1.1
 */

namespace haxe;

use \haxe\_Int64\___Int64;
use \php\Boot;
use \php\_Boot\HxString;
use \haxe\_Int32\Int32_Impl_;

/**
 * Helper for parsing to `Int64` instances.
 */
class Int64Helper {
	/**
	 * Create `Int64` from given float.
	 * 
	 * @param float $f
	 * 
	 * @return ___Int64
	 */
	public static function fromFloat ($f) {
		if (is_nan($f) || !is_finite($f)) {
			throw Exception::thrown("Number is NaN or Infinite");
		}
		$noFractions = $f - fmod($f, 1);
		if ($noFractions > 9007199254740991) {
			throw Exception::thrown("Conversion overflow");
		}
		if ($noFractions < -9007199254740991) {
			throw Exception::thrown("Conversion underflow");
		}
		$result = new ___Int64(0, 0);
		$neg = $noFractions < 0;
		$rest = ($neg ? -$noFractions : $noFractions);
		$i = 0;
		while ($rest >= 1) {
			$curr = fmod($rest, 2);
			$rest /= 2;
			if ($curr >= 1) {
				$a_high = 0;
				$a_low = 1;
				$b = $i;
				$b &= 63;
				$b1 = ($b === 0 ? new ___Int64($a_high, $a_low) : ($b < 32 ? new ___Int64((((($a_high << $b << Int32_Impl_::$extraBits) >> Int32_Impl_::$extraBits) | Boot::shiftRightUnsigned($a_low, (32 - $b))) << Int32_Impl_::$extraBits) >> Int32_Impl_::$extraBits, ($a_low << $b << Int32_Impl_::$extraBits) >> Int32_Impl_::$extraBits) : new ___Int64(($a_low << ($b - 32) << Int32_Impl_::$extraBits) >> Int32_Impl_::$extraBits, 0)));
				$high = (($result->high + $b1->high) << Int32_Impl_::$extraBits) >> Int32_Impl_::$extraBits;
				$low = (($result->low + $b1->low) << Int32_Impl_::$extraBits) >> Int32_Impl_::$extraBits;
				if (Int32_Impl_::ucompare($low, $result->low) < 0) {
					++$high;
					$high = ($high << Int32_Impl_::$extraBits) >> Int32_Impl_::$extraBits;
				}
				$result = new ___Int64($high, $low);
			}
			++$i;
		}
		if ($neg) {
			$high = (~$result->high << Int32_Impl_::$extraBits) >> Int32_Impl_::$extraBits;
			$low = ((~$result->low + 1) << Int32_Impl_::$extraBits) >> Int32_Impl_::$extraBits;
			if ($low === 0) {
				++$high;
				$high = ($high << Int32_Impl_::$extraBits) >> Int32_Impl_::$extraBits;
			}
			$result = new ___Int64($high, $low);
		}
		return $result;
	}

	/**
	 * Create `Int64` from given string.
	 * 
	 * @param string $sParam
	 * 
	 * @return ___Int64
	 */
	public static function parseString ($sParam) {
		$base_high = 0;
		$base_low = 10;
		$current = new ___Int64(0, 0);
		$multiplier = new ___Int64(0, 1);
		$sIsNegative = false;
		$s = trim($sParam);
		if (mb_substr($s, 0, 1) === "-") {
			$sIsNegative = true;
			$s = HxString::substring($s, 1, mb_strlen($s));
		}
		$len = mb_strlen($s);
		$_g = 0;
		while ($_g < $len) {
			$digitInt = HxString::charCodeAt($s, $len - 1 - $_g++) - 48;
			if (($digitInt < 0) || ($digitInt > 9)) {
				throw Exception::thrown("NumberFormatError");
			}
			if ($digitInt !== 0) {
				$digit_high = $digitInt >> 31;
				$digit_low = $digitInt;
				if ($sIsNegative) {
					$al = $multiplier->low & 65535;
					$ah = Boot::shiftRightUnsigned($multiplier->low, 16);
					$bl = $digit_low & 65535;
					$bh = Boot::shiftRightUnsigned($digit_low, 16);
					$p00 = Int32_Impl_::mul($al, $bl);
					$p10 = Int32_Impl_::mul($ah, $bl);
					$p01 = Int32_Impl_::mul($al, $bh);
					$low = $p00;
					$high = (((((Int32_Impl_::mul($ah, $bh) + (Boot::shiftRightUnsigned($p01, 16))) << Int32_Impl_::$extraBits) >> Int32_Impl_::$extraBits) + (Boot::shiftRightUnsigned($p10, 16))) << Int32_Impl_::$extraBits) >> Int32_Impl_::$extraBits;
					$p01 = ($p01 << 16 << Int32_Impl_::$extraBits) >> Int32_Impl_::$extraBits;
					$low = (($p00 + $p01) << Int32_Impl_::$extraBits) >> Int32_Impl_::$extraBits;
					if (Int32_Impl_::ucompare($low, $p01) < 0) {
						++$high;
						$high = ($high << Int32_Impl_::$extraBits) >> Int32_Impl_::$extraBits;
					}
					$p10 = ($p10 << 16 << Int32_Impl_::$extraBits) >> Int32_Impl_::$extraBits;
					$low = (($low + $p10) << Int32_Impl_::$extraBits) >> Int32_Impl_::$extraBits;
					if (Int32_Impl_::ucompare($low, $p10) < 0) {
						++$high;
						$high = ($high << Int32_Impl_::$extraBits) >> Int32_Impl_::$extraBits;
					}
					$high = (($high + (((Int32_Impl_::mul($multiplier->low, $digit_high) + Int32_Impl_::mul($multiplier->high, $digit_low)) << Int32_Impl_::$extraBits) >> Int32_Impl_::$extraBits)) << Int32_Impl_::$extraBits) >> Int32_Impl_::$extraBits;
					$b_low = $low;
					$high1 = (($current->high - $high) << Int32_Impl_::$extraBits) >> Int32_Impl_::$extraBits;
					if (Int32_Impl_::ucompare($current->low, $b_low) < 0) {
						--$high1;
						$high1 = ($high1 << Int32_Impl_::$extraBits) >> Int32_Impl_::$extraBits;
					}
					$current = new ___Int64($high1, (($current->low - $b_low) << Int32_Impl_::$extraBits) >> Int32_Impl_::$extraBits);
					if (!($current->high < 0)) {
						throw Exception::thrown("NumberFormatError: Underflow");
					}
				} else {
					$al1 = $multiplier->low & 65535;
					$ah1 = Boot::shiftRightUnsigned($multiplier->low, 16);
					$bl1 = $digit_low & 65535;
					$bh1 = Boot::shiftRightUnsigned($digit_low, 16);
					$p001 = Int32_Impl_::mul($al1, $bl1);
					$p101 = Int32_Impl_::mul($ah1, $bl1);
					$p011 = Int32_Impl_::mul($al1, $bh1);
					$low1 = $p001;
					$high2 = (((((Int32_Impl_::mul($ah1, $bh1) + (Boot::shiftRightUnsigned($p011, 16))) << Int32_Impl_::$extraBits) >> Int32_Impl_::$extraBits) + (Boot::shiftRightUnsigned($p101, 16))) << Int32_Impl_::$extraBits) >> Int32_Impl_::$extraBits;
					$p011 = ($p011 << 16 << Int32_Impl_::$extraBits) >> Int32_Impl_::$extraBits;
					$low1 = (($p001 + $p011) << Int32_Impl_::$extraBits) >> Int32_Impl_::$extraBits;
					if (Int32_Impl_::ucompare($low1, $p011) < 0) {
						++$high2;
						$high2 = ($high2 << Int32_Impl_::$extraBits) >> Int32_Impl_::$extraBits;
					}
					$p101 = ($p101 << 16 << Int32_Impl_::$extraBits) >> Int32_Impl_::$extraBits;
					$low1 = (($low1 + $p101) << Int32_Impl_::$extraBits) >> Int32_Impl_::$extraBits;
					if (Int32_Impl_::ucompare($low1, $p101) < 0) {
						++$high2;
						$high2 = ($high2 << Int32_Impl_::$extraBits) >> Int32_Impl_::$extraBits;
					}
					$high2 = (($high2 + (((Int32_Impl_::mul($multiplier->low, $digit_high) + Int32_Impl_::mul($multiplier->high, $digit_low)) << Int32_Impl_::$extraBits) >> Int32_Impl_::$extraBits)) << Int32_Impl_::$extraBits) >> Int32_Impl_::$extraBits;
					$high3 = (($current->high + $high2) << Int32_Impl_::$extraBits) >> Int32_Impl_::$extraBits;
					$low2 = (($current->low + $low1) << Int32_Impl_::$extraBits) >> Int32_Impl_::$extraBits;
					if (Int32_Impl_::ucompare($low2, $current->low) < 0) {
						++$high3;
						$high3 = ($high3 << Int32_Impl_::$extraBits) >> Int32_Impl_::$extraBits;
					}
					$current = new ___Int64($high3, $low2);
					if ($current->high < 0) {
						throw Exception::thrown("NumberFormatError: Overflow");
					}
				}
			}
			$al2 = $multiplier->low & 65535;
			$ah2 = Boot::shiftRightUnsigned($multiplier->low, 16);
			$bl2 = $base_low & 65535;
			$bh2 = Boot::shiftRightUnsigned($base_low, 16);
			$p002 = Int32_Impl_::mul($al2, $bl2);
			$p102 = Int32_Impl_::mul($ah2, $bl2);
			$p012 = Int32_Impl_::mul($al2, $bh2);
			$low3 = $p002;
			$high4 = (((((Int32_Impl_::mul($ah2, $bh2) + (Boot::shiftRightUnsigned($p012, 16))) << Int32_Impl_::$extraBits) >> Int32_Impl_::$extraBits) + (Boot::shiftRightUnsigned($p102, 16))) << Int32_Impl_::$extraBits) >> Int32_Impl_::$extraBits;
			$p012 = ($p012 << 16 << Int32_Impl_::$extraBits) >> Int32_Impl_::$extraBits;
			$low3 = (($p002 + $p012) << Int32_Impl_::$extraBits) >> Int32_Impl_::$extraBits;
			if (Int32_Impl_::ucompare($low3, $p012) < 0) {
				++$high4;
				$high4 = ($high4 << Int32_Impl_::$extraBits) >> Int32_Impl_::$extraBits;
			}
			$p102 = ($p102 << 16 << Int32_Impl_::$extraBits) >> Int32_Impl_::$extraBits;
			$low3 = (($low3 + $p102) << Int32_Impl_::$extraBits) >> Int32_Impl_::$extraBits;
			if (Int32_Impl_::ucompare($low3, $p102) < 0) {
				++$high4;
				$high4 = ($high4 << Int32_Impl_::$extraBits) >> Int32_Impl_::$extraBits;
			}
			$high4 = (($high4 + (((Int32_Impl_::mul($multiplier->low, $base_high) + Int32_Impl_::mul($multiplier->high, $base_low)) << Int32_Impl_::$extraBits) >> Int32_Impl_::$extraBits)) << Int32_Impl_::$extraBits) >> Int32_Impl_::$extraBits;
			$multiplier = new ___Int64($high4, $low3);
		}
		return $current;
	}
}

Boot::registerClass(Int64Helper::class, 'haxe.Int64Helper');
