<?php
/**
 * Generated by Haxe 4.1.1
 */

namespace haxe;

use \haxe\_Int64\___Int64;
use \php\Boot;
use \php\_Boot\HxString;
use \haxe\_Int32\Int32_Impl_;

/**
 * Helper for parsing to `Int64` instances.
 */
class Int64Helper {
	/**
	 * Create `Int64` from given float.
	 * 
	 * @param float $f
	 * 
	 * @return ___Int64
	 */
	public static function fromFloat ($f) {
		if (is_nan($f) || !is_finite($f)) {
			throw Exception::thrown("Number is NaN or Infinite");
		}
		$noFractions = $f - fmod($f, 1);
		if ($noFractions > 9007199254740991) {
			throw Exception::thrown("Conversion overflow");
		}
		if ($noFractions < -9007199254740991) {
			throw Exception::thrown("Conversion underflow");
		}
		$this1 = new ___Int64(0, 0);
		$result = $this1;
		$neg = $noFractions < 0;
		$rest = ($neg ? -$noFractions : $noFractions);
		$i = 0;
		while ($rest >= 1) {
			$curr = fmod($rest, 2);
			$rest /= 2;
			if ($curr >= 1) {
				$a_high = 0;
				$a_low = 1;
				$b = $i;
				$b &= 63;
				$b1 = null;
				if ($b === 0) {
					$this1 = new ___Int64($a_high, $a_low);
					$b1 = $this1;
				} else if ($b < 32) {
					$this2 = new ___Int64((((($a_high << $b << Int32_Impl_::$extraBits) >> Int32_Impl_::$extraBits) | Boot::shiftRightUnsigned($a_low, (32 - $b))) << Int32_Impl_::$extraBits) >> Int32_Impl_::$extraBits, ($a_low << $b << Int32_Impl_::$extraBits) >> Int32_Impl_::$extraBits);
					$b1 = $this2;
				} else {
					$this3 = new ___Int64(($a_low << ($b - 32) << Int32_Impl_::$extraBits) >> Int32_Impl_::$extraBits, 0);
					$b1 = $this3;
				}
				$high = (($result->high + $b1->high) << Int32_Impl_::$extraBits) >> Int32_Impl_::$extraBits;
				$low = (($result->low + $b1->low) << Int32_Impl_::$extraBits) >> Int32_Impl_::$extraBits;
				if (Int32_Impl_::ucompare($low, $result->low) < 0) {
					$ret = $high++;
					$high = ($high << Int32_Impl_::$extraBits) >> Int32_Impl_::$extraBits;
				}
				$this4 = new ___Int64($high, $low);
				$result = $this4;
			}
			++$i;
		}
		if ($neg) {
			$high = (~$result->high << Int32_Impl_::$extraBits) >> Int32_Impl_::$extraBits;
			$low = ((~$result->low + 1) << Int32_Impl_::$extraBits) >> Int32_Impl_::$extraBits;
			if ($low === 0) {
				$ret = $high++;
				$high = ($high << Int32_Impl_::$extraBits) >> Int32_Impl_::$extraBits;
			}
			$this1 = new ___Int64($high, $low);
			$result = $this1;
		}
		return $result;
	}

	/**
	 * Create `Int64` from given string.
	 * 
	 * @param string $sParam
	 * 
	 * @return ___Int64
	 */
	public static function parseString ($sParam) {
		$base_high = 0;
		$base_low = 10;
		$this1 = new ___Int64(0, 0);
		$current = $this1;
		$this1 = new ___Int64(0, 1);
		$multiplier = $this1;
		$sIsNegative = false;
		$s = trim($sParam);
		if (mb_substr($s, 0, 1) === "-") {
			$sIsNegative = true;
			$s = HxString::substring($s, 1, mb_strlen($s));
		}
		$len = mb_strlen($s);
		$_g = 0;
		$_g1 = $len;
		while ($_g < $_g1) {
			$i = $_g++;
			$digitInt = HxString::charCodeAt($s, $len - 1 - $i) - 48;
			if (($digitInt < 0) || ($digitInt > 9)) {
				throw Exception::thrown("NumberFormatError");
			}
			if ($digitInt !== 0) {
				$digit_high = $digitInt >> 31;
				$digit_low = $digitInt;
				if ($sIsNegative) {
					$mask = 65535;
					$al = $multiplier->low & $mask;
					$ah = Boot::shiftRightUnsigned($multiplier->low, 16);
					$bl = $digit_low & $mask;
					$bh = Boot::shiftRightUnsigned($digit_low, 16);
					$p00 = Int32_Impl_::mul($al, $bl);
					$p10 = Int32_Impl_::mul($ah, $bl);
					$p01 = Int32_Impl_::mul($al, $bh);
					$p11 = Int32_Impl_::mul($ah, $bh);
					$low = $p00;
					$high = ((((($p11 + (Boot::shiftRightUnsigned($p01, 16))) << Int32_Impl_::$extraBits) >> Int32_Impl_::$extraBits) + (Boot::shiftRightUnsigned($p10, 16))) << Int32_Impl_::$extraBits) >> Int32_Impl_::$extraBits;
					$p01 = ($p01 << 16 << Int32_Impl_::$extraBits) >> Int32_Impl_::$extraBits;
					$low = (($low + $p01) << Int32_Impl_::$extraBits) >> Int32_Impl_::$extraBits;
					if (Int32_Impl_::ucompare($low, $p01) < 0) {
						$ret = $high++;
						$high = ($high << Int32_Impl_::$extraBits) >> Int32_Impl_::$extraBits;
					}
					$p10 = ($p10 << 16 << Int32_Impl_::$extraBits) >> Int32_Impl_::$extraBits;
					$low = (($low + $p10) << Int32_Impl_::$extraBits) >> Int32_Impl_::$extraBits;
					if (Int32_Impl_::ucompare($low, $p10) < 0) {
						$ret1 = $high++;
						$high = ($high << Int32_Impl_::$extraBits) >> Int32_Impl_::$extraBits;
					}
					$high = (($high + (((Int32_Impl_::mul($multiplier->low, $digit_high) + Int32_Impl_::mul($multiplier->high, $digit_low)) << Int32_Impl_::$extraBits) >> Int32_Impl_::$extraBits)) << Int32_Impl_::$extraBits) >> Int32_Impl_::$extraBits;
					$b_high = $high;
					$b_low = $low;
					$high1 = (($current->high - $b_high) << Int32_Impl_::$extraBits) >> Int32_Impl_::$extraBits;
					$low1 = (($current->low - $b_low) << Int32_Impl_::$extraBits) >> Int32_Impl_::$extraBits;
					if (Int32_Impl_::ucompare($current->low, $b_low) < 0) {
						$ret2 = $high1--;
						$high1 = ($high1 << Int32_Impl_::$extraBits) >> Int32_Impl_::$extraBits;
					}
					$this1 = new ___Int64($high1, $low1);
					$current = $this1;
					if (!($current->high < 0)) {
						throw Exception::thrown("NumberFormatError: Underflow");
					}
				} else {
					$mask1 = 65535;
					$al1 = $multiplier->low & $mask1;
					$ah1 = Boot::shiftRightUnsigned($multiplier->low, 16);
					$bl1 = $digit_low & $mask1;
					$bh1 = Boot::shiftRightUnsigned($digit_low, 16);
					$p001 = Int32_Impl_::mul($al1, $bl1);
					$p101 = Int32_Impl_::mul($ah1, $bl1);
					$p011 = Int32_Impl_::mul($al1, $bh1);
					$p111 = Int32_Impl_::mul($ah1, $bh1);
					$low2 = $p001;
					$high2 = ((((($p111 + (Boot::shiftRightUnsigned($p011, 16))) << Int32_Impl_::$extraBits) >> Int32_Impl_::$extraBits) + (Boot::shiftRightUnsigned($p101, 16))) << Int32_Impl_::$extraBits) >> Int32_Impl_::$extraBits;
					$p011 = ($p011 << 16 << Int32_Impl_::$extraBits) >> Int32_Impl_::$extraBits;
					$low2 = (($low2 + $p011) << Int32_Impl_::$extraBits) >> Int32_Impl_::$extraBits;
					if (Int32_Impl_::ucompare($low2, $p011) < 0) {
						$ret3 = $high2++;
						$high2 = ($high2 << Int32_Impl_::$extraBits) >> Int32_Impl_::$extraBits;
					}
					$p101 = ($p101 << 16 << Int32_Impl_::$extraBits) >> Int32_Impl_::$extraBits;
					$low2 = (($low2 + $p101) << Int32_Impl_::$extraBits) >> Int32_Impl_::$extraBits;
					if (Int32_Impl_::ucompare($low2, $p101) < 0) {
						$ret4 = $high2++;
						$high2 = ($high2 << Int32_Impl_::$extraBits) >> Int32_Impl_::$extraBits;
					}
					$high2 = (($high2 + (((Int32_Impl_::mul($multiplier->low, $digit_high) + Int32_Impl_::mul($multiplier->high, $digit_low)) << Int32_Impl_::$extraBits) >> Int32_Impl_::$extraBits)) << Int32_Impl_::$extraBits) >> Int32_Impl_::$extraBits;
					$b_high1 = $high2;
					$b_low1 = $low2;
					$high3 = (($current->high + $b_high1) << Int32_Impl_::$extraBits) >> Int32_Impl_::$extraBits;
					$low3 = (($current->low + $b_low1) << Int32_Impl_::$extraBits) >> Int32_Impl_::$extraBits;
					if (Int32_Impl_::ucompare($low3, $current->low) < 0) {
						$ret5 = $high3++;
						$high3 = ($high3 << Int32_Impl_::$extraBits) >> Int32_Impl_::$extraBits;
					}
					$this2 = new ___Int64($high3, $low3);
					$current = $this2;
					if ($current->high < 0) {
						throw Exception::thrown("NumberFormatError: Overflow");
					}
				}
			}
			$mask2 = 65535;
			$al2 = $multiplier->low & $mask2;
			$ah2 = Boot::shiftRightUnsigned($multiplier->low, 16);
			$bl2 = $base_low & $mask2;
			$bh2 = Boot::shiftRightUnsigned($base_low, 16);
			$p002 = Int32_Impl_::mul($al2, $bl2);
			$p102 = Int32_Impl_::mul($ah2, $bl2);
			$p012 = Int32_Impl_::mul($al2, $bh2);
			$p112 = Int32_Impl_::mul($ah2, $bh2);
			$low4 = $p002;
			$high4 = ((((($p112 + (Boot::shiftRightUnsigned($p012, 16))) << Int32_Impl_::$extraBits) >> Int32_Impl_::$extraBits) + (Boot::shiftRightUnsigned($p102, 16))) << Int32_Impl_::$extraBits) >> Int32_Impl_::$extraBits;
			$p012 = ($p012 << 16 << Int32_Impl_::$extraBits) >> Int32_Impl_::$extraBits;
			$low4 = (($low4 + $p012) << Int32_Impl_::$extraBits) >> Int32_Impl_::$extraBits;
			if (Int32_Impl_::ucompare($low4, $p012) < 0) {
				$ret6 = $high4++;
				$high4 = ($high4 << Int32_Impl_::$extraBits) >> Int32_Impl_::$extraBits;
			}
			$p102 = ($p102 << 16 << Int32_Impl_::$extraBits) >> Int32_Impl_::$extraBits;
			$low4 = (($low4 + $p102) << Int32_Impl_::$extraBits) >> Int32_Impl_::$extraBits;
			if (Int32_Impl_::ucompare($low4, $p102) < 0) {
				$ret7 = $high4++;
				$high4 = ($high4 << Int32_Impl_::$extraBits) >> Int32_Impl_::$extraBits;
			}
			$high4 = (($high4 + (((Int32_Impl_::mul($multiplier->low, $base_high) + Int32_Impl_::mul($multiplier->high, $base_low)) << Int32_Impl_::$extraBits) >> Int32_Impl_::$extraBits)) << Int32_Impl_::$extraBits) >> Int32_Impl_::$extraBits;
			$this3 = new ___Int64($high4, $low4);
			$multiplier = $this3;
		}
		return $current;
	}
}

Boot::registerClass(Int64Helper::class, 'haxe.Int64Helper');
