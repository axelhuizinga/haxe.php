<?php
/**
 * Generated by Haxe 4.1.5
 */

namespace haxe\zip;

use \php\Boot;
use \haxe\Exception;
use \haxe\ds\IntMap;

class HuffTools {
	/**
	 * @return void
	 */
	public function __construct () {
	}

	/**
	 * @param \Array_hx $lengths
	 * @param int $pos
	 * @param int $nlengths
	 * @param int $maxbits
	 * 
	 * @return Huffman
	 */
	public function make ($lengths, $pos, $nlengths, $maxbits) {
		if ($nlengths === 1) {
			return Huffman::NeedBit(Huffman::Found(0), Huffman::Found(0));
		}
		$counts = new \Array_hx();
		$tmp = new \Array_hx();
		if ($maxbits > 32) {
			throw Exception::thrown("Invalid huffman");
		}
		$_g = 0;
		while ($_g < $maxbits) {
			++$_g;
			$counts->arr[$counts->length++] = 0;
			$tmp->arr[$tmp->length++] = 0;
		}
		$_g = 0;
		while ($_g < $nlengths) {
			$p = ($lengths->arr[$_g++ + $pos] ?? null);
			if ($p >= $maxbits) {
				throw Exception::thrown("Invalid huffman");
			}
			$counts[$p]++;
		}
		$code = 0;
		$_g = 1;
		$_g1 = $maxbits - 1;
		while ($_g < $_g1) {
			$i = $_g++;
			$code = ($code + ($counts->arr[$i] ?? null)) << 1;
			$tmp->offsetSet($i, $code);
		}
		$bits = new IntMap();
		$_g = 0;
		while ($_g < $nlengths) {
			$i = $_g++;
			$l = ($lengths->arr[$i + $pos] ?? null);
			if ($l !== 0) {
				$n = ($tmp->arr[$l - 1] ?? null);
				$tmp->offsetSet($l - 1, $n + 1);
				$bits->data[($n << 5) | $l] = $i;
			}
		}
		$tmp = $this->treeMake($bits, $maxbits, 0, 1);
		return $this->treeCompress(Huffman::NeedBit($tmp, $this->treeMake($bits, $maxbits, 1, 1)));
	}

	/**
	 * @param Huffman $t
	 * 
	 * @return Huffman
	 */
	public function treeCompress ($t) {
		$d = $this->treeDepth($t);
		if ($d === 0) {
			return $t;
		}
		if ($d === 1) {
			if ($t->index === 1) {
				$tmp = $this->treeCompress($t->params[0]);
				return Huffman::NeedBit($tmp, $this->treeCompress($t->params[1]));
			} else {
				throw Exception::thrown("assert");
			}
		}
		$size = 1 << $d;
		$table = new \Array_hx();
		$_g = 0;
		while ($_g < $size) {
			++$_g;
			$table->arr[$table->length++] = Huffman::Found(-1);
		}
		$this->treeWalk($table, 0, 0, $d, $t);
		return Huffman::NeedBits($d, $table);
	}

	/**
	 * @param Huffman $t
	 * 
	 * @return int
	 */
	public function treeDepth ($t) {
		$__hx__switch = ($t->index);
		if ($__hx__switch === 0) {
			return 0;
		} else if ($__hx__switch === 1) {
			$da = $this->treeDepth($t->params[0]);
			$db = $this->treeDepth($t->params[1]);
			return 1 + (($da < $db ? $da : $db));
		} else if ($__hx__switch === 2) {
			throw Exception::thrown("assert");
		}
	}

	/**
	 * @param IntMap $bits
	 * @param int $maxbits
	 * @param int $v
	 * @param int $len
	 * 
	 * @return Huffman
	 */
	public function treeMake ($bits, $maxbits, $v, $len) {
		if ($len > $maxbits) {
			throw Exception::thrown("Invalid huffman");
		}
		$idx = ($v << 5) | $len;
		if (\array_key_exists($idx, $bits->data)) {
			return Huffman::Found(($bits->data[$idx] ?? null));
		}
		$v <<= 1;
		++$len;
		$tmp = $this->treeMake($bits, $maxbits, $v, $len);
		return Huffman::NeedBit($tmp, $this->treeMake($bits, $maxbits, $v | 1, $len));
	}

	/**
	 * @param \Array_hx $table
	 * @param int $p
	 * @param int $cd
	 * @param int $d
	 * @param Huffman $t
	 * 
	 * @return void
	 */
	public function treeWalk ($table, $p, $cd, $d, $t) {
		if ($t->index === 1) {
			if ($d > 0) {
				$this->treeWalk($table, $p, $cd + 1, $d - 1, $t->params[0]);
				$this->treeWalk($table, $p | (1 << $cd), $cd + 1, $d - 1, $t->params[1]);
			} else {
				$table->offsetSet($p, $this->treeCompress($t));
			}
		} else {
			$table->offsetSet($p, $this->treeCompress($t));
		}
	}
}

Boot::registerClass(HuffTools::class, 'haxe.zip.HuffTools');
