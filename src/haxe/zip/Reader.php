<?php
/**
 * Generated by Haxe 4.1.5
 */

namespace haxe\zip;

use \php\_Boot\HxAnon;
use \php\Boot;
use \haxe\Exception;
use \haxe\io\BytesBuffer;
use \haxe\io\Error;
use \haxe\io\Input;
use \haxe\ds\List_hx;
use \haxe\io\Bytes;

class Reader {
	/**
	 * @var Input
	 */
	public $i;

	/**
	 * @param Input $i
	 * 
	 * @return List_hx
	 */
	public static function readZip ($i) {
		return (new Reader($i))->read();
	}

	/**
	 * @param object $f
	 * 
	 * @return Bytes
	 */
	public static function unzip ($f) {
		if (!$f->compressed) {
			return $f->data;
		}
		$c = new Uncompress(-15);
		$s = Bytes::alloc($f->fileSize);
		$r = $c->execute($f->data, 0, $s, 0);
		$c->close();
		if (!$r->done || ($r->read !== $f->data->length) || ($r->write !== $f->fileSize)) {
			throw Exception::thrown("Invalid compressed data for " . ($f->fileName??'null'));
		}
		$f->compressed = false;
		$f->dataSize = $f->fileSize;
		$f->data = $s;
		return $f->data;
	}

	/**
	 * @param Input $i
	 * 
	 * @return void
	 */
	public function __construct ($i) {
		$this->i = $i;
	}

	/**
	 * @return List_hx
	 */
	public function read () {
		$l = new List_hx();
		$tmp = null;
		while (true) {
			$e = $this->readEntryHeader();
			if ($e === null) {
				break;
			}
			if ($e->crc32 === null) {
				if ($e->compressed) {
					if ($tmp === null) {
						$tmp = Bytes::alloc(65536);
					}
					$out = new BytesBuffer();
					$z = new InflateImpl($this->i, false, false);
					while (true) {
						$n = $z->readBytes($tmp, 0, 65536);
						if (($n < 0) || ($n > $tmp->length)) {
							throw Exception::thrown(Error::OutsideBounds());
						} else {
							$out->b = ($out->b . \substr($tmp->b->s, 0, $n));
						}
						if ($n < 65536) {
							break;
						}
					}
					$e->data = $out->getBytes();
				} else {
					$e->data = $this->i->read($e->dataSize);
				}
				$e->crc32 = $this->i->readInt32();
				if ($e->crc32 === 134695760) {
					$e->crc32 = $this->i->readInt32();
				}
				$e->dataSize = $this->i->readInt32();
				$e->fileSize = $this->i->readInt32();
				$e->dataSize = $e->fileSize;
				$e->compressed = false;
			} else {
				$e->data = $this->i->read($e->dataSize);
			}
			$l->add($e);
		}
		return $l;
	}

	/**
	 * @return object
	 */
	public function readEntryHeader () {
		$i = $this->i;
		$h = $i->readInt32();
		if (($h === 33639248) || ($h === 101010256)) {
			return null;
		}
		if ($h !== 67324752) {
			throw Exception::thrown("Invalid Zip Data");
		}
		$i->readUInt16();
		$flags = $i->readUInt16();
		if (($flags & 63473) !== 0) {
			throw Exception::thrown("Unsupported flags " . ($flags??'null'));
		}
		$compression = $i->readUInt16();
		$compressed = $compression !== 0;
		if ($compressed && ($compression !== 8)) {
			throw Exception::thrown("Unsupported compression " . ($compression??'null'));
		}
		$mtime = $this->readZipDate();
		$crc32 = $i->readInt32();
		$csize = $i->readInt32();
		$usize = $i->readInt32();
		$fnamelen = $i->readInt16();
		$elen = $i->readInt16();
		$fname = $i->readString($fnamelen);
		$fields = $this->readExtraFields($elen);
		if (($flags & 2048) !== 0) {
			$fields->push(ExtraField::FUtf8());
		}
		if (($flags & 8) !== 0) {
			$crc32 = null;
		}
		return new HxAnon([
			"fileName" => $fname,
			"fileSize" => $usize,
			"fileTime" => $mtime,
			"compressed" => $compressed,
			"dataSize" => $csize,
			"data" => null,
			"crc32" => $crc32,
			"extraFields" => $fields,
		]);
	}

	/**
	 * @param int $length
	 * 
	 * @return List_hx
	 */
	public function readExtraFields ($length) {
		$fields = new List_hx();
		while ($length > 0) {
			if ($length < 4) {
				throw Exception::thrown("Invalid extra fields data");
			}
			$tag = $this->i->readUInt16();
			$len = $this->i->readUInt16();
			if ($length < $len) {
				throw Exception::thrown("Invalid extra fields data");
			}
			if ($tag === 28789) {
				$version = $this->i->readByte();
				if ($version !== 1) {
					$data = new BytesBuffer();
					$data->b = ($data->b . \chr($version));
					$src = $this->i->read($len - 1);
					$data->b = ($data->b . $src->b->s);
					$fields->add(ExtraField::FUnknown($tag, $data->getBytes()));
				} else {
					$crc = $this->i->readInt32();
					$fields->add(ExtraField::FInfoZipUnicodePath($this->i->read($len - 5)->toString(), $crc));
				}
			} else {
				$fields->add(ExtraField::FUnknown($tag, $this->i->read($len)));
			}
			$length -= 4 + $len;
		}
		return $fields;
	}

	/**
	 * @return \Date
	 */
	public function readZipDate () {
		$t = $this->i->readUInt16();
		$d = $this->i->readUInt16();
		return new \Date(($d >> 9) + 1980, (($d >> 5) & 15) - 1, $d & 31, ($t >> 11) & 31, ($t >> 5) & 63, ($t & 31) << 1);
	}
}

Boot::registerClass(Reader::class, 'haxe.zip.Reader');
