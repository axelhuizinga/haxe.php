<?php
/**
 * Generated by Haxe 4.1.5
 */

namespace haxe\zip;

use \php\_Boot\HxAnon;
use \haxe\io\_BytesData\Container;
use \php\Boot;
use \haxe\Exception;
use \haxe\io\Error;
use \haxe\io\Bytes;

class Compress {
	/**
	 * @var int
	 */
	public $level;

	/**
	 * @param Bytes $s
	 * @param int $level
	 * 
	 * @return Bytes
	 */
	public static function run ($s, $level) {
		$c = \gzcompress($s->toString(), $level);
		$tmp = \strlen($c);
		return new Bytes($tmp, new Container($c));
	}

	/**
	 * @param int $level
	 * 
	 * @return void
	 */
	public function __construct ($level) {
		$this->level = $level;
	}

	/**
	 * @return void
	 */
	public function close () {
	}

	/**
	 * @param Bytes $src
	 * @param int $srcPos
	 * @param Bytes $dst
	 * @param int $dstPos
	 * 
	 * @return object
	 */
	public function execute ($src, $srcPos, $dst, $dstPos) {
		$len = $src->length - $srcPos;
		$input = null;
		if (($srcPos < 0) || ($len < 0) || (($srcPos + $len) > $src->length)) {
			throw Exception::thrown(Error::OutsideBounds());
		} else {
			$input = new Bytes($len, new Container(\substr($src->b->s, $srcPos, $len)));
		}
		$data = Compress::run($input, $this->level);
		$len = $data->length;
		if (($dstPos < 0) || ($len < 0) || (($dstPos + $len) > $dst->length) || ($len > $data->length)) {
			throw Exception::thrown(Error::OutsideBounds());
		} else {
			$this1 = $dst->b;
			$src = $data->b;
			$this1->s = ((\substr($this1->s, 0, $dstPos) . \substr($src->s, 0, $len)) . \substr($this1->s, $dstPos + $len));
		}
		return new HxAnon([
			"done" => true,
			"read" => $input->length,
			"write" => $data->length,
		]);
	}

	/**
	 * @param FlushMode $f
	 * 
	 * @return void
	 */
	public function setFlushMode ($f) {
	}
}

Boot::registerClass(Compress::class, 'haxe.zip.Compress');
