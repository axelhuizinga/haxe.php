<?php
/**
 * Generated by Haxe 4.1.4
 */

namespace haxe;

use \php\Boot;
use \haxe\_CallStack\CallStack_Impl_;

/**
 * Base class for exceptions.
 * If this class (or derivatives) is used to catch an exception, then
 * `haxe.CallStack.exceptionStack()` will not return a stack for the exception
 * caught. Use `haxe.Exception.stack` property instead:
 * ```haxe
 * try {
 * throwSomething();
 * } catch(e:Exception) {
 * trace(e.stack);
 * }
 * ```
 * Custom exceptions should extend this class:
 * ```haxe
 * class MyException extends haxe.Exception {}
 * //...
 * throw new MyException('terrible exception');
 * ```
 * `haxe.Exception` is also a wildcard type to catch any exception:
 * ```haxe
 * try {
 * throw 'Catch me!';
 * } catch(e:haxe.Exception) {
 * trace(e.message); // Output: Catch me!
 * }
 * ```
 * To rethrow an exception just throw it again.
 * Haxe will try to rethrow an original native exception whenever possible.
 * ```haxe
 * try {
 * var a:Array<Int> = null;
 * a.push(1); // generates target-specific null-pointer exception
 * } catch(e:haxe.Exception) {
 * throw e; // rethrows native exception instead of haxe.Exception
 * }
 * ```
 */
class Exception extends \Exception {
	/**
	 * @var \Array_hx
	 */
	public $__exceptionStack;
	/**
	 * @var \Throwable
	 */
	public $__nativeException;
	/**
	 * @var Exception
	 */
	public $__previousException;
	/**
	 * @var int
	 */
	public $__skipStack;

	/**
	 * @param mixed $value
	 * 
	 * @return Exception
	 */
	public static function caught ($value) {
		if (($value instanceof Exception)) {
			return $value;
		} else if (($value instanceof \Throwable)) {
			return new Exception($value->getMessage(), null, $value);
		} else {
			return new ValueException($value, null, $value);
		}
	}

	/**
	 * @param mixed $value
	 * 
	 * @return mixed
	 */
	public static function thrown ($value) {
		if (($value instanceof Exception)) {
			return $value->get_native();
		} else if (($value instanceof \Throwable)) {
			return $value;
		} else {
			$e = new ValueException($value);
			$e->__skipStack = 1;
			return $e;
		}
	}

	/**
	 * Create a new Exception instance.
	 * The `previous` argument could be used for exception chaining.
	 * The `native` argument is for internal usage only.
	 * There is no need to provide `native` argument manually and no need to keep it
	 * upon extending `haxe.Exception` unless you know what you're doing.
	 * 
	 * @param string $message
	 * @param Exception $previous
	 * @param mixed $native
	 * 
	 * @return void
	 */
	public function __construct ($message, $previous = null, $native = null) {
		$this->__skipStack = 0;
		parent::__construct($message, 0, $previous);
		$this->__previousException = $previous;
		if (($native !== null) && ($native instanceof \Throwable)) {
			$this->__nativeException = $native;
		} else {
			$this->__nativeException = $this;
		}
	}

	/**
	 * Detailed exception description.
	 * Includes message, stack and the chain of previous exceptions (if set).
	 * 
	 * @return string
	 */
	public function details () {
		if ($this->get_previous() === null) {
			$tmp = "Exception: " . ($this->get_message()??'null');
			$tmp1 = $this->get_stack();
			return ($tmp??'null') . ((($tmp1 === null ? "null" : CallStack_Impl_::toString($tmp1)))??'null');
		} else {
			$result = "";
			$e = $this;
			$prev = null;
			while ($e !== null) {
				if ($prev === null) {
					$result1 = "Exception: " . ($e->get_message()??'null');
					$tmp = $e->get_stack();
					$result = ($result1??'null') . ((($tmp === null ? "null" : CallStack_Impl_::toString($tmp)))??'null') . ($result??'null');
				} else {
					$prevStack = CallStack_Impl_::subtract($e->get_stack(), $prev->get_stack());
					$result = "Exception: " . ($e->get_message()??'null') . ((($prevStack === null ? "null" : CallStack_Impl_::toString($prevStack)))??'null') . "\x0A\x0ANext " . ($result??'null');
				}
				$prev = $e;
				$e = $e->get_previous();
			}
			return $result;
		}
	}

	/**
	 * @return string
	 */
	public function get_message () {
		return $this->getMessage();
	}

	/**
	 * @return mixed
	 */
	final public function get_native () {
		return $this->__nativeException;
	}

	/**
	 * @return Exception
	 */
	public function get_previous () {
		return $this->__previousException;
	}

	/**
	 * @return \Array_hx
	 */
	public function get_stack () {
		$_g = $this->__exceptionStack;
		if ($_g === null) {
			return $this->__exceptionStack = NativeStackTrace::toHaxe(NativeStackTrace::complementTrace($this->__nativeException->getTrace(), $this->get_native()), $this->__skipStack);
		} else {
			return $_g;
		}
	}

	/**
	 * Returns exception message.
	 * 
	 * @return string
	 */
	public function toString () {
		return $this->get_message();
	}

	/**
	 * @return mixed
	 */
	public function unwrap () {
		return $this->__nativeException;
	}

	public function __toString() {
		return $this->toString();
	}
}

Boot::registerClass(Exception::class, 'haxe.Exception');
Boot::registerGetters('haxe\\Exception', [
	'native' => true,
	'previous' => true,
	'stack' => true,
	'message' => true
]);
