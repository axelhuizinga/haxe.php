<?php
/**
 * Generated by Haxe 4.1.1
 */

namespace haxe;

use \php\_Boot\HxAnon;
use \php\Boot;
use \php\_Boot\HxString;
use \haxe\ds\List_hx;
use \haxe\_Template\TemplateExpr;
use \haxe\iterators\ArrayIterator;

/**
 * `Template` provides a basic templating mechanism to replace values in a source
 * String, and to have some basic logic.
 * A complete documentation of the supported syntax is available at:
 * <https://haxe.org/manual/std-template.html>
 */
class Template {
	/**
	 * @var \EReg
	 */
	static public $expr_float;
	/**
	 * @var \EReg
	 */
	static public $expr_int;
	/**
	 * @var \EReg
	 */
	static public $expr_splitter;
	/**
	 * @var \EReg
	 */
	static public $expr_trim;
	/**
	 * @var mixed
	 * Global replacements which are used across all `Template` instances. This
	 * has lower priority than the context argument of `execute()`.
	 */
	static public $globals;
	/**
	 * @var ArrayIterator
	 */
	static public $hxKeepArrayIterator;
	/**
	 * @var \EReg
	 */
	static public $splitter;

	/**
	 * @var \StringBuf
	 */
	public $buf;
	/**
	 * @var mixed
	 */
	public $context;
	/**
	 * @var TemplateExpr
	 */
	public $expr;
	/**
	 * @var mixed
	 */
	public $macros;
	/**
	 * @var List_hx
	 */
	public $stack;

	/**
	 * Creates a new `Template` instance from `str`.
	 * `str` is parsed into tokens, which are stored for internal use. This
	 * means that multiple `execute()` operations on a single `Template` instance
	 * are more efficient than one `execute()` operations on multiple `Template`
	 * instances.
	 * If `str` is `null`, the result is unspecified.
	 * 
	 * @param string $str
	 * 
	 * @return void
	 */
	public function __construct ($str) {
		$tokens = $this->parseTokens($str);
		$this->expr = $this->parseBlock($tokens);
		if (!$tokens->isEmpty()) {
			throw Exception::thrown("Unexpected '" . (\Std::string($tokens->first()->s)??'null') . "'");
		}
	}

	/**
	 * Executes `this` `Template`, taking into account `context` for
	 * replacements and `macros` for callback functions.
	 * If `context` has a field `name`, its value replaces all occurrences of
	 * `::name::` in the `Template`. Otherwise `Template.globals` is checked instead,
	 * If `name` is not a field of that either, `::name::` is replaced with `null`.
	 * If `macros` has a field `name`, all occurrences of `$$name(args)` are
	 * replaced with the result of calling that field. The first argument is
	 * always the `resolve()` method, followed by the given arguments.
	 * If `macros` has no such field, the result is unspecified.
	 * If `context` is `null`, the result is unspecified. If `macros` is `null`,
	 * no macros are used.
	 * 
	 * @param mixed $context
	 * @param mixed $macros
	 * 
	 * @return string
	 */
	public function execute ($context, $macros = null) {
		$this->macros = ($macros === null ? new HxAnon() : $macros);
		$this->context = $context;
		$this->stack = new List_hx();
		$this->buf = new \StringBuf();
		$this->run($this->expr);
		return $this->buf->b;
	}

	/**
	 * @param string $v
	 * 
	 * @return \Closure
	 */
	public function makeConst ($v) {
		Template::$expr_trim->match($v);
		$v = Template::$expr_trim->matched(1);
		if (HxString::charCodeAt($v, 0) === 34) {
			$str = mb_substr($v, 1, mb_strlen($v) - 2);
			return function () use (&$str) {
				return $str;
			};
		}
		if (Template::$expr_int->match($v)) {
			$i = \Std::parseInt($v);
			return function () use (&$i) {
				return $i;
			};
		}
		if (Template::$expr_float->match($v)) {
			$f = \Std::parseFloat($v);
			return function () use (&$f) {
				return $f;
			};
		}
		$me = $this;
		return function () use (&$v, &$me) {
			return $me->resolve($v);
		};
	}

	/**
	 * @param List_hx $l
	 * 
	 * @return \Closure
	 */
	public function makeExpr ($l) {
		return $this->makePath($this->makeExpr2($l), $l);
	}

	/**
	 * @param List_hx $l
	 * 
	 * @return \Closure
	 */
	public function makeExpr2 ($l) {
		$this->skipSpaces($l);
		$p = $l->pop();
		$this->skipSpaces($l);
		if ($p === null) {
			throw Exception::thrown("<eof>");
		}
		if ($p->s) {
			return $this->makeConst($p->p);
		}
		$__hx__switch = ($p->p);
		if ($__hx__switch === "!") {
			$e = $this->makeExpr($l);
			return function () use (&$e) {
				$v = $e();
				if ($v !== null) {
					return $v === false;
				} else {
					return true;
				}
			};
		} else if ($__hx__switch === "(") {
			$this->skipSpaces($l);
			$e1 = $this->makeExpr($l);
			$this->skipSpaces($l);
			$p1 = $l->pop();
			if (($p1 === null) || $p1->s) {
				throw Exception::thrown($p1);
			}
			if ($p1->p === ")") {
				return $e1;
			}
			$this->skipSpaces($l);
			$e2 = $this->makeExpr($l);
			$this->skipSpaces($l);
			$p2 = $l->pop();
			$this->skipSpaces($l);
			if (($p2 === null) || ($p2->p !== ")")) {
				throw Exception::thrown($p2);
			}
			$__hx__switch = ($p1->p);
			if ($__hx__switch === "!=") {
				return function () use (&$e1, &$e2) {
					return !Boot::equal($e1(), $e2());
				};
			} else if ($__hx__switch === "&&") {
				return function () use (&$e1, &$e2) {
					return $e1() && $e2();
				};
			} else if ($__hx__switch === "*") {
				return function () use (&$e1, &$e2) {
					return $e1() * $e2();
				};
			} else if ($__hx__switch === "+") {
				return function () use (&$e1, &$e2) {
					return Boot::addOrConcat($e1(), $e2());
				};
			} else if ($__hx__switch === "-") {
				return function () use (&$e1, &$e2) {
					return $e1() - $e2();
				};
			} else if ($__hx__switch === "/") {
				return function () use (&$e1, &$e2) {
					return $e1() / $e2();
				};
			} else if ($__hx__switch === "<") {
				return function () use (&$e1, &$e2) {
					return $e1() < $e2();
				};
			} else if ($__hx__switch === "<=") {
				return function () use (&$e1, &$e2) {
					return $e1() <= $e2();
				};
			} else if ($__hx__switch === "==") {
				return function () use (&$e1, &$e2) {
					return Boot::equal($e1(), $e2());
				};
			} else if ($__hx__switch === ">") {
				return function () use (&$e1, &$e2) {
					return $e1() > $e2();
				};
			} else if ($__hx__switch === ">=") {
				return function () use (&$e1, &$e2) {
					return $e1() >= $e2();
				};
			} else if ($__hx__switch === "||") {
				return function () use (&$e1, &$e2) {
					return $e1() || $e2();
				};
			} else {
				throw Exception::thrown("Unknown operation " . ($p1->p??'null'));
			}
		} else if ($__hx__switch === "-") {
			$e3 = $this->makeExpr($l);
			return function () use (&$e3) {
				return -$e3();
			};
		}
		throw Exception::thrown($p->p);
	}

	/**
	 * @param \Closure $e
	 * @param List_hx $l
	 * 
	 * @return \Closure
	 */
	public function makePath ($e, $l) {
		$p = $l->first();
		if (($p === null) || ($p->p !== ".")) {
			return $e;
		}
		$l->pop();
		$field = $l->pop();
		if (($field === null) || !$field->s) {
			throw Exception::thrown($field->p);
		}
		$f = $field->p;
		Template::$expr_trim->match($f);
		$f = Template::$expr_trim->matched(1);
		return $this->makePath(function () use (&$f, &$e) {
			return \Reflect::field($e(), $f);
		}, $l);
	}

	/**
	 * @param List_hx $tokens
	 * 
	 * @return TemplateExpr
	 */
	public function parse ($tokens) {
		$t = $tokens->pop();
		$p = $t->p;
		if ($t->s) {
			return TemplateExpr::OpStr($p);
		}
		if ($t->l !== null) {
			$pe = new List_hx();
			$_g = 0;
			$_g1 = $t->l;
			while ($_g < $_g1->length) {
				$p1 = ($_g1->arr[$_g] ?? null);
				++$_g;
				$pe->add($this->parseBlock($this->parseTokens($p1)));
			}
			return TemplateExpr::OpMacro($p, $pe);
		}
		$kwdEnd = function ($kwd) use (&$p) {
			$pos = -1;
			$length = mb_strlen($kwd);
			if (mb_substr($p, 0, $length) === $kwd) {
				$pos = $length;
				$_g_offset = 0;
				$_g_s = mb_substr($p, $length, null);
				while ($_g_offset < mb_strlen($_g_s)) {
					$c = \StringTools::fastCodeAt($_g_s, $_g_offset++);
					if ($c === 32) {
						++$pos;
					} else {
						break;
					}
				}
			}
			return $pos;
		};
		$pos = $kwdEnd("if");
		if ($pos > 0) {
			$p = mb_substr($p, $pos, mb_strlen($p) - $pos);
			$e = $this->parseExpr($p);
			$eif = $this->parseBlock($tokens);
			$t = $tokens->first();
			$eelse = null;
			if ($t === null) {
				throw Exception::thrown("Unclosed 'if'");
			}
			if ($t->p === "end") {
				$tokens->pop();
				$eelse = null;
			} else if ($t->p === "else") {
				$tokens->pop();
				$eelse = $this->parseBlock($tokens);
				$t = $tokens->pop();
				if (($t === null) || ($t->p !== "end")) {
					throw Exception::thrown("Unclosed 'else'");
				}
			} else {
				$t->p = mb_substr($t->p, 4, mb_strlen($t->p) - 4);
				$eelse = $this->parse($tokens);
			}
			return TemplateExpr::OpIf($e, $eif, $eelse);
		}
		$pos = $kwdEnd("foreach");
		if ($pos >= 0) {
			$p = mb_substr($p, $pos, mb_strlen($p) - $pos);
			$e = $this->parseExpr($p);
			$efor = $this->parseBlock($tokens);
			$t = $tokens->pop();
			if (($t === null) || ($t->p !== "end")) {
				throw Exception::thrown("Unclosed 'foreach'");
			}
			return TemplateExpr::OpForeach($e, $efor);
		}
		if (Template::$expr_splitter->match($p)) {
			return TemplateExpr::OpExpr($this->parseExpr($p));
		}
		return TemplateExpr::OpVar($p);
	}

	/**
	 * @param List_hx $tokens
	 * 
	 * @return TemplateExpr
	 */
	public function parseBlock ($tokens) {
		$l = new List_hx();
		while (true) {
			$t = $tokens->first();
			if ($t === null) {
				break;
			}
			if (!$t->s && (($t->p === "end") || ($t->p === "else") || (mb_substr($t->p, 0, 7) === "elseif "))) {
				break;
			}
			$l->add($this->parse($tokens));
		}
		if ($l->length === 1) {
			return $l->first();
		}
		return TemplateExpr::OpBlock($l);
	}

	/**
	 * @param string $data
	 * 
	 * @return \Closure
	 */
	public function parseExpr ($data) {
		$l = new List_hx();
		$expr = $data;
		while (Template::$expr_splitter->match($data)) {
			$p = Template::$expr_splitter->matchedPos();
			$k = $p->pos + $p->len;
			if ($p->pos !== 0) {
				$l->add(new HxAnon([
					"p" => mb_substr($data, 0, $p->pos),
					"s" => true,
				]));
			}
			$p1 = Template::$expr_splitter->matched(0);
			$l->add(new HxAnon([
				"p" => $p1,
				"s" => HxString::indexOf($p1, "\"") >= 0,
			]));
			$data = Template::$expr_splitter->matchedRight();
		}
		if (mb_strlen($data) !== 0) {
			$_g_offset = 0;
			$_g_s = $data;
			while ($_g_offset < mb_strlen($_g_s)) {
				$_g1_key = $_g_offset;
				$_g1_value = \StringTools::fastCodeAt($_g_s, $_g_offset++);
				$i = $_g1_key;
				$c = $_g1_value;
				if ($c !== 32) {
					$l->add(new HxAnon([
						"p" => mb_substr($data, $i, null),
						"s" => true,
					]));
					break;
				}
			}
		}
		$e = null;
		try {
			$e = $this->makeExpr($l);
			if (!$l->isEmpty()) {
				throw Exception::thrown($l->first()->p);
			}
		} catch(\Throwable $_g) {
			NativeStackTrace::saveStack($_g);
			$_g1 = Exception::caught($_g)->unwrap();
			if (is_string($_g1)) {
				$s = $_g1;
				throw Exception::thrown("Unexpected '" . ($s??'null') . "' in " . ($expr??'null'));
			} else {
				throw $_g;
			}
		}
		return function () use (&$e, &$expr, &$_g) {
			try {
				return $e();
			} catch(\Throwable $_g) {
				NativeStackTrace::saveStack($_g);
				$exc = Exception::caught($_g)->unwrap();
				throw Exception::thrown("Error : " . (\Std::string($exc)??'null') . " in " . ($expr??'null'));
			}
		};
	}

	/**
	 * @param string $data
	 * 
	 * @return List_hx
	 */
	public function parseTokens ($data) {
		$tokens = new List_hx();
		while (Template::$splitter->match($data)) {
			$p = Template::$splitter->matchedPos();
			if ($p->pos > 0) {
				$tokens->add(new HxAnon([
					"p" => mb_substr($data, 0, $p->pos),
					"s" => true,
					"l" => null,
				]));
			}
			if (HxString::charCodeAt($data, $p->pos) === 58) {
				$tokens->add(new HxAnon([
					"p" => mb_substr($data, $p->pos + 2, $p->len - 4),
					"s" => false,
					"l" => null,
				]));
				$data = Template::$splitter->matchedRight();
				continue;
			}
			$parp = $p->pos + $p->len;
			$npar = 1;
			$params = new \Array_hx();
			$part = "";
			while (true) {
				$c = HxString::charCodeAt($data, $parp);
				++$parp;
				if ($c === 40) {
					++$npar;
				} else if ($c === 41) {
					--$npar;
					if ($npar <= 0) {
						break;
					}
				} else if ($c === null) {
					throw Exception::thrown("Unclosed macro parenthesis");
				}
				if (($c === 44) && ($npar === 1)) {
					$params->arr[$params->length++] = $part;
					$part = "";
				} else {
					$part = ($part??'null') . (mb_chr($c)??'null');
				}
			}
			$params->arr[$params->length++] = $part;
			$tokens->add(new HxAnon([
				"p" => Template::$splitter->matched(2),
				"s" => false,
				"l" => $params,
			]));
			$data = mb_substr($data, $parp, mb_strlen($data) - $parp);
		}
		if (mb_strlen($data) > 0) {
			$tokens->add(new HxAnon([
				"p" => $data,
				"s" => true,
				"l" => null,
			]));
		}
		return $tokens;
	}

	/**
	 * @param string $v
	 * 
	 * @return mixed
	 */
	public function resolve ($v) {
		if ($v === "__current__") {
			return $this->context;
		}
		$value = \Reflect::getProperty($this->context, $v);
		if (($value !== null) || \Reflect::hasField($this->context, $v)) {
			return $value;
		}
		$_g_head = $this->stack->h;
		while ($_g_head !== null) {
			$val = $_g_head->item;
			$_g_head = $_g_head->next;
			$ctx = $val;
			$value = \Reflect::getProperty($ctx, $v);
			if (($value !== null) || \Reflect::hasField($ctx, $v)) {
				return $value;
			}
		}
		return \Reflect::field(Template::$globals, $v);
	}

	/**
	 * @param TemplateExpr $e
	 * 
	 * @return void
	 */
	public function run ($e) {
		$__hx__switch = ($e->index);
		if ($__hx__switch === 0) {
			$v = $e->params[0];
			$this->buf->add(\Std::string($this->resolve($v)));
		} else if ($__hx__switch === 1) {
			$e1 = $e->params[0];
			$this->buf->add(\Std::string($e1()));
		} else if ($__hx__switch === 2) {
			$eelse = $e->params[2];
			$eif = $e->params[1];
			$e1 = $e->params[0];
			$v = $e1();
			if (($v === null) || ($v === false)) {
				if ($eelse !== null) {
					$this->run($eelse);
				}
			} else {
				$this->run($eif);
			}
		} else if ($__hx__switch === 3) {
			$str = $e->params[0];
			$this->buf->add($str);
		} else if ($__hx__switch === 4) {
			$l = $e->params[0];
			$_g_head = $l->h;
			while ($_g_head !== null) {
				$val = $_g_head->item;
				$_g_head = $_g_head->next;
				$e1 = $val;
				$this->run($e1);
			}
		} else if ($__hx__switch === 5) {
			$loop = $e->params[1];
			$e1 = $e->params[0];
			$v = $e1();
			try {
				$x = $v->iterator();
				if (Boot::dynamicField($x, 'hasNext') === null) {
					throw Exception::thrown(null);
				}
				$v = $x;
			} catch(\Throwable $_g) {
				NativeStackTrace::saveStack($_g);
				try {
					if (Boot::dynamicField($v, 'hasNext') === null) {
						throw Exception::thrown(null);
					}
				} catch(\Throwable $_g) {
					throw Exception::thrown("Cannot iter on " . (\Std::string($v)??'null'));
				}
			}
			$this->stack->push($this->context);
			$v1 = $v;
			$ctx = $v1;
			while ($ctx->hasNext()) {
				$ctx1 = $ctx->next();
				$this->context = $ctx1;
				$this->run($loop);
			}
			$this->context = $this->stack->pop();
		} else if ($__hx__switch === 6) {
			$params = $e->params[1];
			$m = $e->params[0];
			$v = \Reflect::field($this->macros, $m);
			$pl = new \Array_hx();
			$old = $this->buf;
			$pl->arr[$pl->length++] = Boot::getInstanceClosure($this, 'resolve');
			$_g_head = $params->h;
			while ($_g_head !== null) {
				$val = $_g_head->item;
				$_g_head = $_g_head->next;
				$p = $val;
				if ($p->index === 0) {
					$v1 = $p->params[0];
					$x = $this->resolve($v1);
					$pl->arr[$pl->length++] = $x;
				} else {
					$this->buf = new \StringBuf();
					$this->run($p);
					$pl->arr[$pl->length++] = $this->buf->b;
				}
			}
			$this->buf = $old;
			try {
				$this->buf->add(\Std::string(\Reflect::callMethod($this->macros, $v, $pl)));
			} catch(\Throwable $_g) {
				NativeStackTrace::saveStack($_g);
				$e = Exception::caught($_g)->unwrap();
				$plstr = null;
				try {
					$plstr = $pl->join(",");
				} catch(\Throwable $_g) {
					$plstr = "???";
				}
				$msg = "Macro call " . ($m??'null') . "(" . ($plstr??'null') . ") failed (" . (\Std::string($e)??'null') . ")";
				throw Exception::thrown($msg);
			}
		}
	}

	/**
	 * @param List_hx $l
	 * 
	 * @return void
	 */
	public function skipSpaces ($l) {
		$p = $l->first();
		while ($p !== null) {
			$_g_offset = 0;
			$_g_s = $p->p;
			while ($_g_offset < mb_strlen($_g_s)) {
				$c = \StringTools::fastCodeAt($_g_s, $_g_offset++);
				if ($c !== 32) {
					return;
				}
			}
			$l->pop();
			$p = $l->first();
		}
	}

	/**
	 * @internal
	 * @access private
	 */
	static public function __hx__init ()
	{
		static $called = false;
		if ($called) return;
		$called = true;


		self::$splitter = new \EReg("(::[A-Za-z0-9_ ()&|!+=/><*.\"-]+::|\\\$\\\$([A-Za-z0-9_-]+)\\()", "");
		self::$expr_splitter = new \EReg("(\\(|\\)|[ \x0D\x0A\x09]*\"[^\"]*\"[ \x0D\x0A\x09]*|[!+=/><*.&|-]+)", "");
		self::$expr_trim = new \EReg("^[ ]*([^ ]+)[ ]*\$", "");
		self::$expr_int = new \EReg("^[0-9]+\$", "");
		self::$expr_float = new \EReg("^([+-]?)(?=\\d|,\\d)\\d*(,\\d*)?([Ee]([+-]?\\d+))?\$", "");
		self::$globals = new HxAnon();
		self::$hxKeepArrayIterator = new ArrayIterator(new \Array_hx());
	}
}

Boot::registerClass(Template::class, 'haxe.Template');
Template::__hx__init();
