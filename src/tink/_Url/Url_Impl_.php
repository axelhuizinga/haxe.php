<?php
/**
 * Generated by Haxe 4.1.3
 */

namespace tink\_Url;

use \php\_Boot\HxAnon;
use \php\Boot;
use \tink\url\_Path\Path_Impl_;
use \php\_Boot\HxString;
use \tink\url\_Host\Host_Impl_;

final class Url_Impl_ {
	/**
	 * @var int
	 */
	const AUTH = 6;
	/**
	 * @var int
	 */
	const HASH = 12;
	/**
	 * @var int
	 */
	const HOSTNAMES = 7;
	/**
	 * @var int
	 */
	const PATH = 8;
	/**
	 * @var int
	 */
	const PAYLOAD = 3;
	/**
	 * @var int
	 */
	const QUERY = 10;
	/**
	 * @var int
	 */
	const SCHEME = 2;


	/**
	 * @param object $parts
	 * 
	 * @return object
	 */
	public static function _new ($parts) {
		return $parts;
	}

	/**
	 * @param string $s
	 * 
	 * @return object
	 */
	public static function fromString ($s) {
		return Url_Impl_::parse($s);
	}

	/**
	 * @param object $this
	 * 
	 * @return string
	 */
	public static function get_host ($this1) {
		return ($this1->hosts->arr[0] ?? null);
	}

	/**
	 * @param object $this
	 * 
	 * @return object
	 */
	public static function get_hosts ($this1) {
		return $this1->hosts;
	}

	/**
	 * @param object $this
	 * 
	 * @return string
	 */
	public static function get_pathWithQuery ($this1) {
		if ($this1->query === null) {
			return $this1->path;
		} else {
			return ((($this1->path === null ? "null" : $this1->path))??'null') . "?" . ((($this1->query === null ? "null" : $this1->query))??'null');
		}
	}

	/**
	 * @param object $parts
	 * 
	 * @return object
	 */
	public static function make ($parts) {
		$parts1 = new HxAnon([
			"payload" => "",
			"path" => $parts->path,
			"query" => $parts->query,
			"hosts" => $parts->hosts,
			"auth" => $parts->auth,
			"scheme" => $parts->scheme,
			"hash" => $parts->hash,
		]);
		Url_Impl_::makePayload($parts1);
		return $parts1;
	}

	/**
	 * @param object $parts
	 * 
	 * @return void
	 */
	public static function makePayload ($parts) {
		$payload = "";
		$_g = $parts->hosts;
		$_g1 = $parts->auth;
		if ($_g1 === null) {
			if ($_g->length !== 0) {
				$payload = "" . ("//" . ($_g->join(",")??'null'));
			}
		} else if ($_g->length === 0) {
			$payload = "" . ("//" . ((($_g1 === null ? "null" : ($_g1 === null ? "" : "" . ($_g1??'null') . "@")))??'null'));
		} else {
			$payload = "" . ("//" . ((($_g1 === null ? "null" : ($_g1 === null ? "" : "" . ($_g1??'null') . "@")))??'null') . ($_g->join(",")??'null'));
		}
		$payload = ($payload??'null') . (($parts->path === null ? "null" : $parts->path)??'null');
		$_g = $parts->query;
		if ($_g !== null) {
			$payload = ($payload??'null') . "?" . ((($_g === null ? "null" : $_g))??'null');
		}
		$_g = $parts->hash;
		if ($_g !== null) {
			$payload = ($payload??'null') . "#" . ($_g??'null');
		}
		$parts->payload = $payload;
	}

	/**
	 * @param string $_
	 * 
	 * @return void
	 */
	public static function noop ($_) {
	}

	/**
	 * @param string $s
	 * @param \Closure $onError
	 * 
	 * @return object
	 */
	public static function parse ($s, $onError = null) {
		while (true) {
			if ($s === null) {
				$s = "";
				$onError = null;
				continue;
			}
			if ($onError === null) {
				$onError = Boot::getStaticClosure(Url_Impl_::class, 'noop');
			}
			$s = \trim($s);
			if (\StringTools::startsWith($s, "data:")) {
				return new HxAnon([
					"scheme" => "data",
					"payload" => \mb_substr($s, 5, null),
					"hosts" => new \Array_hx(),
				]);
			}
			$FORMAT = new \EReg("^(([a-zA-Z][a-zA-Z0-9\\-+.]*):)?((//(([^@/]+)@)?([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?)\$", "");
			$HOST = new \EReg("^(\\[(.*)\\]|([^:]*))(:(.*))?\$", "");
			$FORMAT->match($s);
			$hosts = null;
			$_g = $FORMAT->matched(7);
			if ($_g === null) {
				$hosts = new \Array_hx();
			} else {
				$_g1 = new \Array_hx();
				$_g2 = 0;
				$_g3 = HxString::split($_g, ",");
				while ($_g2 < $_g3->length) {
					$host = ($_g3->arr[$_g2] ?? null);
					++$_g2;
					$HOST->match($host);
					$host1 = null;
					$_g4 = $HOST->matched(2);
					$_g5 = $HOST->matched(3);
					if ($_g4 === null) {
						$host1 = $_g5;
					} else if ($_g5 === null) {
						$host1 = "[" . ($_g4??'null') . "]";
					} else {
						$onError("invalid host " . ($host??'null'));
						$host1 = null;
					}
					$port = null;
					$_g6 = $HOST->matched(5);
					if ($_g6 === null) {
						$port = null;
					} else {
						$_g7 = \Std::parseInt($_g6);
						if ($_g7 === null) {
							$onError("invalid port " . ($_g6??'null'));
							$port = null;
						} else {
							$port = $_g7;
						}
					}
					$x = Host_Impl_::_new($host1, $port);
					$_g1->arr[$_g1->length++] = $x;
				}
				$hosts = $_g1;
			}
			$path = $FORMAT->matched(8);
			if (($hosts->length > 0) && (\mb_substr($path, 0, 1) !== "/")) {
				$path = "/" . ($path??'null');
			}
			$parts = $FORMAT->matched(2);
			$parts1 = $FORMAT->matched(3);
			$parts2 = $FORMAT->matched(6);
			$parts3 = Path_Impl_::ofString($path);
			$parts4 = $FORMAT->matched(10);
			return new HxAnon([
				"scheme" => $parts,
				"payload" => $parts1,
				"hosts" => $hosts,
				"auth" => $parts2,
				"path" => $parts3,
				"query" => $parts4,
				"hash" => $FORMAT->matched(12),
			]);
		}
	}

	/**
	 * @param object $this
	 * @param object $that
	 * 
	 * @return object
	 */
	public static function resolve ($this1, $that) {
		if ($that->scheme !== null) {
			return $that;
		} else if (($that->hosts->arr[0] ?? null) !== null) {
			if ($that->scheme !== null) {
				return $that;
			} else {
				$copy = \Reflect::copy($that);
				$copy->scheme = $this1->scheme;
				return $copy;
			}
		} else {
			$parts = Path_Impl_::join($this1->path, $that->path);
			$parts1 = new HxAnon([
				"path" => $parts,
				"payload" => "",
				"scheme" => $this1->scheme,
				"query" => $that->query,
				"auth" => $this1->auth,
				"hosts" => $this1->hosts,
				"hash" => $that->hash,
			]);
			Url_Impl_::makePayload($parts1);
			return $parts1;
		}
	}

	/**
	 * @param object $this
	 * 
	 * @return string
	 */
	public static function toString ($this1) {
		if ($this1->scheme === null) {
			return $this1->payload;
		} else {
			return "" . ($this1->scheme??'null') . ":" . ($this1->payload??'null');
		}
	}
}

Boot::registerClass(Url_Impl_::class, 'tink._Url.Url_Impl_');
Boot::registerGetters('tink\\_Url\\Url_Impl_', [
	'pathWithQuery' => true,
	'hosts' => true,
	'host' => true
]);
