<?php
/**
 * Generated by Haxe 4.1.4
 */

namespace tink\_Chunk;

use \tink\chunk\CompoundChunk;
use \tink\chunk\ChunkObject;
use \haxe\io\_BytesData\Container;
use \php\Boot;
use \tink\chunk\ByteChunk;
use \tink\chunk\ChunkIterator;
use \haxe\io\Bytes;
use \tink\chunk\ChunkCursor;

final class Chunk_Impl_ {
	/**
	 * @var ChunkObject
	 */
	static public $EMPTY;

	/**
	 * @param ChunkObject $this
	 * @param Bytes $target
	 * @param int $offset
	 * 
	 * @return void
	 */
	public static function blitTo ($this1, $target, $offset) {
		$this1->blitTo($target, $offset);
	}

	/**
	 * @param ChunkObject $a
	 * @param ChunkObject $b
	 * 
	 * @return ChunkObject
	 */
	public static function catChunk ($a, $b) {
		return Chunk_Impl_::concat($a, $b);
	}

	/**
	 * @param ChunkObject $this
	 * @param ChunkObject $that
	 * 
	 * @return ChunkObject
	 */
	public static function concat ($this1, $that) {
		return CompoundChunk::cons($this1, $that);
	}

	/**
	 * @param ChunkObject $this
	 * 
	 * @return ChunkCursor
	 */
	public static function cursor ($this1) {
		return $this1->getCursor();
	}

	/**
	 * @param ChunkObject $this
	 * @param int $i
	 * 
	 * @return int
	 */
	public static function getByte ($this1, $i) {
		return $this1->getByte($i);
	}

	/**
	 * @param ChunkObject $this
	 * 
	 * @return int
	 */
	public static function get_length ($this1) {
		return $this1->getLength();
	}

	/**
	 * @param ChunkObject $this
	 * 
	 * @return ChunkIterator
	 */
	public static function iterator ($this1) {
		return new ChunkIterator($this1->getCursor());
	}

	/**
	 * @param \Array_hx $chunks
	 * 
	 * @return ChunkObject
	 */
	public static function join ($chunks) {
		if ($chunks === null) {
			return Chunk_Impl_::$EMPTY;
		} else {
			$__hx__switch = ($chunks->length);
			if ($__hx__switch === 0) {
				return Chunk_Impl_::$EMPTY;
			} else if ($__hx__switch === 1) {
				return ($chunks->arr[0] ?? null);
			} else {
				$ret = Chunk_Impl_::catChunk(($chunks->arr[0] ?? null), ($chunks->arr[1] ?? null));
				$_g = 2;
				$_g1 = $chunks->length;
				while ($_g < $_g1) {
					$ret = Chunk_Impl_::catChunk($ret, ($chunks->arr[$_g++] ?? null));
				}
				return $ret;
			}
		}
	}

	/**
	 * @param Bytes $a
	 * @param ChunkObject $b
	 * 
	 * @return ChunkObject
	 */
	public static function lcatBytes ($a, $b) {
		return Chunk_Impl_::catChunk(ByteChunk::of($a), $b);
	}

	/**
	 * @param string $a
	 * @param ChunkObject $b
	 * 
	 * @return ChunkObject
	 */
	public static function lcatString ($a, $b) {
		$b1 = \strlen($a);
		return Chunk_Impl_::catChunk(ByteChunk::of(new Bytes($b1, new Container($a))), $b);
	}

	/**
	 * @param Bytes $b
	 * 
	 * @return ChunkObject
	 */
	public static function ofBytes ($b) {
		return ByteChunk::of($b);
	}

	/**
	 * @param string $s
	 * 
	 * @return ChunkObject
	 */
	public static function ofHex ($s) {
		$length = mb_strlen($s) >> 1;
		$bytes = Bytes::alloc($length);
		$_g = 0;
		while ($_g < $length) {
			$i = $_g++;
			$v = \Std::parseInt("0x" . (\mb_substr($s, $i * 2, 2)??'null'));
			$bytes->b->s[$i] = \chr($v);
		}
		return ByteChunk::of($bytes);
	}

	/**
	 * @param string $s
	 * 
	 * @return ChunkObject
	 */
	public static function ofString ($s) {
		$b = \strlen($s);
		return ByteChunk::of(new Bytes($b, new Container($s)));
	}

	/**
	 * @param ChunkObject $a
	 * @param Bytes $b
	 * 
	 * @return ChunkObject
	 */
	public static function rcatBytes ($a, $b) {
		return Chunk_Impl_::catChunk($a, ByteChunk::of($b));
	}

	/**
	 * @param ChunkObject $a
	 * @param string $b
	 * 
	 * @return ChunkObject
	 */
	public static function rcatString ($a, $b) {
		$b1 = \strlen($b);
		return Chunk_Impl_::catChunk($a, ByteChunk::of(new Bytes($b1, new Container($b))));
	}

	/**
	 * @param ChunkObject $this
	 * @param int $from
	 * @param int $to
	 * 
	 * @return ChunkObject
	 */
	public static function slice ($this1, $from, $to) {
		return $this1->slice($from, $to);
	}

	/**
	 * @param ChunkObject $this
	 * 
	 * @return Bytes
	 */
	public static function toBytes ($this1) {
		return $this1->toBytes();
	}

	/**
	 * @param ChunkObject $this
	 * 
	 * @return string
	 */
	public static function toHex ($this1) {
		return \bin2hex($this1->toBytes()->b->s);
	}

	/**
	 * @param ChunkObject $this
	 * 
	 * @return string
	 */
	public static function toString ($this1) {
		return $this1->toString();
	}

	/**
	 * @internal
	 * @access private
	 */
	static public function __hx__init ()
	{
		static $called = false;
		if ($called) return;
		$called = true;


		self::$EMPTY = new EmptyChunk();
	}
}

Boot::registerClass(Chunk_Impl_::class, 'tink._Chunk.Chunk_Impl_');
Boot::registerGetters('tink\\_Chunk\\Chunk_Impl_', [
	'length' => true
]);
Chunk_Impl_::__hx__init();
