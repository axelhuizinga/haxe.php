<?php
/**
 * Generated by Haxe 4.1.5
 */

namespace tink\io;

use \tink\chunk\ChunkObject;
use \haxe\io\_BytesData\Container;
use \haxe\ds\Option;
use \php\Boot;
use \tink\chunk\ByteChunk;
use \haxe\io\Bytes;
use \tink\_Chunk\Chunk_Impl_;

class Splitter extends BytewiseParser {
	/**
	 * @var ChunkObject
	 */
	public $buf;
	/**
	 * @var ChunkObject
	 */
	public $delim;

	/**
	 * @param ChunkObject $delim
	 * 
	 * @return void
	 */
	public function __construct ($delim) {
		$this->buf = Chunk_Impl_::$EMPTY;
		$this->delim = $delim;
	}

	/**
	 * @param int $char
	 * 
	 * @return ParseStep
	 */
	public function read ($char) {
		if ($char === -1) {
			return ParseStep::Done(Option::None());
		}
		$tmp = $this->buf;
		$s = \mb_chr($char);
		$b = \strlen($s);
		$this->buf = Chunk_Impl_::catChunk($tmp, ByteChunk::of(new Bytes($b, new Container($s))));
		if ($this->buf->getLength() >= $this->delim->getLength()) {
			$bcursor = $this->buf->getCursor();
			$delta = $this->buf->getLength() - $this->delim->getLength();
			$bcursor->moveTo($bcursor->currentPos + $delta);
			$dcursor = $this->delim->getCursor();
			$_g = 0;
			$_g1 = $this->delim->getLength();
			while ($_g < $_g1) {
				++$_g;
				if ($bcursor->currentByte !== $dcursor->currentByte) {
					return ParseStep::Progressed();
				} else {
					$bcursor->next();
					$dcursor->next();
				}
			}
			$out = ParseStep::Done(Option::Some($this->buf->slice(0, $bcursor->currentPos - $this->delim->getLength())));
			$this->buf = Chunk_Impl_::$EMPTY;
			return $out;
		} else {
			return ParseStep::Progressed();
		}
	}
}

Boot::registerClass(Splitter::class, 'tink.io.Splitter');
