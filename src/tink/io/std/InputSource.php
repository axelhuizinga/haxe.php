<?php
/**
 * Generated by Haxe 4.1.5
 */

namespace tink\io\std;

use \php\_Boot\HxAnon;
use \tink\core\_Lazy\LazyFunc;
use \php\Boot;
use \haxe\Exception;
use \tink\streams\Step;
use \haxe\io\Eof;
use \tink\streams\Generator;
use \tink\core\TypedError;
use \tink\io\_Worker\Worker_Impl_;
use \tink\chunk\ByteChunk;
use \haxe\io\Error;
use \tink\io\WorkerObject;
use \haxe\io\Input;
use \tink\core\_Future\Future_Impl_;
use \tink\_Chunk\Chunk_Impl_;
use \haxe\io\Bytes;
use \haxe\NativeStackTrace;

class InputSource extends Generator {
	/**
	 * @param string $name
	 * @param Input $target
	 * @param WorkerObject $worker
	 * @param Bytes $buf
	 * @param int $offset
	 * 
	 * @return void
	 */
	public function __construct ($name, $target, $worker, $buf, $offset) {
		$next = function ($buf, $offset) use (&$name, &$worker, &$target) {
			return new InputSource($name, $target, $worker, $buf, $offset);
		};
		$free = $buf->length - $offset;
		parent::__construct(Future_Impl_::async(function ($cb) use (&$name, &$free, &$buf, &$next, &$worker, &$target, &$offset) {
			Worker_Impl_::work($worker, new LazyFunc(function () use (&$name, &$free, &$buf, &$next, &$target, &$offset) {
				try {
					$read = $target->readBytes($buf, $offset, $free);
					if ($read === 0) {
						$tmp = Chunk_Impl_::$EMPTY;
						return Step::Link($tmp, $next($buf, $offset));
					} else {
						$nextOffset = (($free - $read) < 1024 ? 0 : $offset + $read);
						$nextBuf = ($nextOffset === 0 ? Bytes::alloc($buf->length) : $buf);
						$tmp = ByteChunk::of($buf)->slice($offset, $offset + $read);
						return Step::Link($tmp, $next($nextBuf, $nextOffset));
					}
				} catch(\Throwable $_g) {
					NativeStackTrace::saveStack($_g);
					$_g1 = Exception::caught($_g)->unwrap();
					if (($_g1 instanceof Eof)) {
						return Step::End();
					} else if (Boot::isOfType($_g1, Boot::getClass(Error::class))) {
						$e = $_g1;
						if ($e->index === 0) {
							$tmp = Chunk_Impl_::$EMPTY;
							return Step::Link($tmp, $next($buf, $offset));
						} else {
							return Step::Fail(TypedError::withData(null, "Failed to read from " . ($name??'null'), $e, new HxAnon([
								"fileName" => "tink/io/std/InputSource.hx",
								"lineNumber" => 50,
								"className" => "tink.io.std.InputSource",
								"methodName" => "new",
							])));
						}
					} else {
						throw $_g;
					}
				}
			}))->handle(function ($step) use (&$target, &$cb) {
				$__hx__switch = ($step->index);
				if ($__hx__switch === 1) {
					try {
						$target->close();
					} catch(\Throwable $_g) {
						NativeStackTrace::saveStack($_g);
					}
				} else if ($__hx__switch === 2) {
					try {
						$target->close();
					} catch(\Throwable $_g) {
						NativeStackTrace::saveStack($_g);
					}
				} else {
				}
				$cb($step);
			});
		}, true));
	}
}

Boot::registerClass(InputSource::class, 'tink.io.std.InputSource');
