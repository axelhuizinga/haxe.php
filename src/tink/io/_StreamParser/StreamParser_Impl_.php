<?php
/**
 * Generated by Haxe 4.1.5
 */

namespace tink\io\_StreamParser;

use \php\_Boot\HxAnon;
use \tink\core\_Future\SyncFuture;
use \tink\io\StreamParserObject;
use \php\Boot;
use \tink\streams\Step;
use \tink\streams\Generator;
use \tink\io\_Source\Source_Impl_;
use \tink\streams\Single;
use \tink\streams\StreamObject;
use \tink\streams\Handled;
use \tink\core\_Lazy\LazyConst;
use \tink\streams\_Stream\Handler_Impl_;
use \tink\io\ParseResult;
use \tink\core\_Future\Future_Impl_;
use \tink\_Chunk\Chunk_Impl_;
use \tink\core\FutureObject;

final class StreamParser_Impl_ {
	/**
	 * @param StreamObject $source
	 * @param StreamParserObject $p
	 * @param \Closure $consume
	 * @param \Closure $finish
	 * 
	 * @return FutureObject
	 */
	public static function doParse ($source, $p, $consume, $finish) {
		$cursor = Chunk_Impl_::$EMPTY->getCursor();
		$resume = true;
		$mk = function ($source) use (&$cursor) {
			if ($cursor->currentPos < $cursor->length) {
				return $source->prepend(new Single(new LazyConst($cursor->right())));
			} else {
				return $source;
			}
		};
		$flush = function () use (&$cursor) {
			$_g = $cursor->flush();
			if ($_g->getLength() === 0) {
				return Source_Impl_::$EMPTY;
			} else {
				return new Single(new LazyConst($_g));
			}
		};
		return $source->forEach(Handler_Impl_::ofUnknown(function ($chunk) use (&$consume, &$resume, &$cursor, &$p) {
			if ($chunk->getLength() === 0) {
				return new SyncFuture(new LazyConst(Handled::Resume()));
			}
			$cursor->shift($chunk);
			return Future_Impl_::async(function ($cb) use (&$consume, &$resume, &$cursor, &$p) {
				$next = null;
				$next = function () use (&$consume, &$next, &$resume, &$cb, &$cursor, &$p) {
					$cursor->shift();
					$lastPos = $cursor->currentPos;
					$_g = $p->progress($cursor);
					$__hx__switch = ($_g->index);
					if ($__hx__switch === 0) {
						if (($lastPos !== $cursor->currentPos) && ($cursor->currentPos < $cursor->length)) {
							$next();
						} else {
							$cb(Handled::Resume());
						}
					} else if ($__hx__switch === 1) {
						$consume($_g->params[0])->handle(function ($o) use (&$next, &$lastPos, &$resume, &$cb, &$cursor) {
							$resume = $o->resume;
							if ($resume) {
								if (($lastPos !== $cursor->currentPos) && ($cursor->currentPos < $cursor->length)) {
									$next();
								} else {
									$cb(Handled::Resume());
								}
							} else {
								$cb(Handled::Finish());
							}
						});
					} else if ($__hx__switch === 2) {
						$cb(Handled::Clog($_g->params[0]));
					}
				};
				$next();
			});
		}))->flatMap(function ($c) use (&$finish, &$consume, &$mk, &$flush, &$resume, &$cursor, &$p) {
			$__hx__switch = ($c->index);
			if ($__hx__switch === 0) {
				$v = $finish();
				return new SyncFuture(new LazyConst(ParseResult::Parsed($v, $mk($c->params[0]))));
			} else if ($__hx__switch === 1) {
				return new SyncFuture(new LazyConst(ParseResult::Invalid($c->params[0], $mk($c->params[1]))));
			} else if ($__hx__switch === 2) {
				return new SyncFuture(new LazyConst(ParseResult::Broke($c->params[0])));
			} else if ($__hx__switch === 3) {
				if ($cursor->currentPos < $cursor->length) {
					$v = $finish();
					return new SyncFuture(new LazyConst(ParseResult::Parsed($v, $mk(new Single(new LazyConst(Chunk_Impl_::$EMPTY))))));
				} else if (!$resume) {
					$v = $finish();
					return new SyncFuture(new LazyConst(ParseResult::Parsed($v, $flush())));
				} else {
					$_g = $p->eof($cursor);
					$__hx__switch = ($_g->index);
					if ($__hx__switch === 0) {
						return $consume($_g->params[0])->map(function ($_) use (&$finish, &$flush) {
							$ret = $finish();
							return ParseResult::Parsed($ret, $flush());
						})->gather();
					} else if ($__hx__switch === 1) {
						return new SyncFuture(new LazyConst(ParseResult::Invalid($_g->params[0], $flush())));
					}
				}
			}
		})->gather();
	}

	/**
	 * @param StreamObject $s
	 * @param StreamParserObject $p
	 * 
	 * @return FutureObject
	 */
	public static function parse ($s, $p) {
		$res = null;
		return StreamParser_Impl_::doParse($s, $p, function ($r) use (&$res) {
			$res = $r;
			return new SyncFuture(new LazyConst(new HxAnon(["resume" => false])));
		}, function () use (&$res) {
			return $res;
		});
	}

	/**
	 * @param StreamObject $s
	 * @param StreamParserObject $p
	 * 
	 * @return StreamObject
	 */
	public static function parseStream ($s, $p) {
		$next = null;
		$next = function ($step) use (&$next, &$s, &$p) {
			if ($s->get_depleted()) {
				$step(Step::End());
			} else {
				StreamParser_Impl_::parse($s, $p)->handle(function ($o) use (&$step, &$next, &$s) {
					$__hx__switch = ($o->index);
					if ($__hx__switch === 0) {
						$s = $o->params[1];
						$step(Step::Link($o->params[0], Generator::stream($next)));
					} else if ($__hx__switch === 1) {
						$step(Step::Fail($o->params[0]));
					} else if ($__hx__switch === 2) {
						$step(Step::Fail($o->params[0]));
					}
				});
			}
		};
		return Generator::stream($next);
	}
}

Boot::registerClass(StreamParser_Impl_::class, 'tink.io._StreamParser.StreamParser_Impl_');
