<?php
/**
 * Generated by Haxe 4.1.4
 */

namespace tink\io;

use \php\_Boot\HxAnon;
use \php\Boot;
use \haxe\Exception;
use \tink\core\TypedError;
use \tink\core\Outcome;
use \tink\chunk\ChunkCursor;

class BytewiseParser implements StreamParserObject {
	/**
	 * @param ChunkCursor $rest
	 * 
	 * @return Outcome
	 */
	public function eof ($rest) {
		$_g = $this->read(-1);
		$__hx__switch = ($_g->index);
		if ($__hx__switch === 0) {
			return Outcome::Failure(new TypedError(422, "Unexpected end of input", new HxAnon([
				"fileName" => "tink/io/StreamParser.hx",
				"lineNumber" => 180,
				"className" => "tink.io.BytewiseParser",
				"methodName" => "eof",
			])));
		} else if ($__hx__switch === 1) {
			return Outcome::Success($_g->params[0]);
		} else if ($__hx__switch === 2) {
			return Outcome::Failure($_g->params[0]);
		}
	}

	/**
	 * @param ChunkCursor $cursor
	 * 
	 * @return ParseStep
	 */
	public function progress ($cursor) {
		while (true) {
			$_g = $this->read($cursor->currentByte);
			$__hx__switch = ($_g->index);
			if ($__hx__switch === 0) {
			} else if ($__hx__switch === 1) {
				$cursor->next();
				return ParseStep::Done($_g->params[0]);
			} else if ($__hx__switch === 2) {
				return ParseStep::Failed($_g->params[0]);
			}
			if (!$cursor->next()) {
				break;
			}
		}
		return ParseStep::Progressed();
	}

	/**
	 * @param int $char
	 * 
	 * @return ParseStep
	 */
	public function read ($char) {
		throw Exception::thrown("abstract");
	}
}

Boot::registerClass(BytewiseParser::class, 'tink.io.BytewiseParser');
