<?php
/**
 * Generated by Haxe 4.1.4
 */

namespace tink\querystring;

use \php\_Boot\HxAnon;
use \php\Boot;
use \haxe\Exception;
use \tink\core\_Callback\Callback_Impl_;
use \tink\core\TypedError;
use \tink\core\Outcome;
use \php\_Boot\HxString;
use \haxe\ds\StringMap;
use \haxe\NativeStackTrace;

class ParserBase {
	/**
	 * @var StringMap
	 */
	public $exists;
	/**
	 * @var \Closure
	 */
	public $onError;
	/**
	 * @var StringMap
	 */
	public $params;
	/**
	 * @var object
	 */
	public $pos;
	/**
	 * @var Outcome
	 */
	public $result;

	/**
	 * @param \Closure $onError
	 * @param object $pos
	 * 
	 * @return void
	 */
	public function __construct ($onError = null, $pos = null) {
		$this->pos = $pos;
		$this->onError = ($onError === null ? Boot::getInstanceClosure($this, 'abort') : $onError);
	}

	/**
	 * @param object $e
	 * 
	 * @return void
	 */
	public function abort ($e) {
		throw Exception::thrown($this->error("" . ($e->reason??'null') . " for " . ($e->name??'null')));
	}

	/**
	 * @param string $field
	 * @param Outcome $o
	 * 
	 * @return mixed
	 */
	public function attempt ($field, $o) {
		$__hx__switch = ($o->index);
		if ($__hx__switch === 0) {
			return $o->params[0];
		} else if ($__hx__switch === 1) {
			return $this->fail($field, $o->params[0]->message);
		}
	}

	/**
	 * @param string $reason
	 * @param mixed $data
	 * 
	 * @return TypedError
	 */
	public function error ($reason, $data = null) {
		return TypedError::withData(422, $reason, $data, $this->pos);
	}

	/**
	 * @param string $field
	 * @param string $reason
	 * 
	 * @return mixed
	 */
	public function fail ($field, $reason) {
		Callback_Impl_::invoke($this->onError, new HxAnon([
			"name" => $field,
			"reason" => $reason,
		]));
		return null;
	}

	/**
	 * @param object $input
	 * @param \Closure $name
	 * @param \Closure $value
	 * 
	 * @return void
	 */
	public function init ($input, $name, $value) {
		$this->params = new StringMap();
		$this->exists = new StringMap();
		if ($input !== null) {
			while ($input->hasNext()) {
				$pair = $input->next();
				$name1 = $name($pair);
				$this1 = $this->params;
				$v = $value($pair);
				$this1->data[$name1] = $v;
				$end = mb_strlen($name1);
				while ($end > 0) {
					$name1 = HxString::substring($name1, 0, $end);
					if (($this->exists->data[$name1] ?? null)) {
						break;
					}
					$this->exists->data[$name1] = true;
					$_g = HxString::lastIndexOf($name1, ".", $end);
					$_g1 = HxString::lastIndexOf($name1, "[", $end);
					if ($_g1 > $_g) {
						$end = $_g1;
					} else {
						$end = $_g;
					}
				}
			}
		}
	}

	/**
	 * @param string $name
	 * 
	 * @return mixed
	 */
	public function missing ($name) {
		return $this->fail($name, "Missing value");
	}

	/**
	 * @param mixed $input
	 * 
	 * @return mixed
	 */
	public function parse ($input) {
		throw Exception::thrown(TypedError::withData(501, "not implemented", $this->pos, new HxAnon([
			"fileName" => "tink/querystring/Parser.hx",
			"lineNumber" => 58,
			"className" => "tink.querystring.ParserBase",
			"methodName" => "parse",
		])));
	}

	/**
	 * @param mixed $input
	 * 
	 * @return Outcome
	 */
	public function tryParse ($input) {
		try {
			return Outcome::Success($this->parse($input));
		} catch(\Throwable $_g) {
			NativeStackTrace::saveStack($_g);
			$_g1 = Exception::caught($_g)->unwrap();
			if (($_g1 instanceof TypedError)) {
				return Outcome::Failure($_g1);
			} else {
				return Outcome::Failure($this->error("Parse Error", $_g1));
			}
		}
	}
}

Boot::registerClass(ParserBase::class, 'tink.querystring.ParserBase');
