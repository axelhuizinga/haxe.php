<?php
/**
 * Generated by Haxe 4.1.4
 */

namespace tink\chunk;

use \haxe\ds\Option;
use \php\Boot;
use \tink\_Chunk\Chunk_Impl_;

class ChunkCursor {
	/**
	 * @var int
	 */
	public $curLength;
	/**
	 * @var int
	 */
	public $curOffset;
	/**
	 * @var ByteChunk
	 */
	public $curPart;
	/**
	 * @var int
	 */
	public $curPartIndex;
	/**
	 * @var int
	 */
	public $currentByte;
	/**
	 * @var int
	 */
	public $currentPos;
	/**
	 * @var int
	 */
	public $length;
	/**
	 * @var \Array_hx
	 */
	public $parts;

	/**
	 * @param \Array_hx $parts
	 * 
	 * @return ChunkCursor
	 */
	public static function create ($parts) {
		$ret = new ChunkCursor();
		$ret->parts = $parts;
		$ret->reset();
		return $ret;
	}

	/**
	 * @return void
	 */
	public function __construct () {
		$this->currentByte = -1;
		$this->currentPos = 0;
		$this->length = 0;
		$this->curLength = 0;
		$this->curOffset = 0;
		$this->curPartIndex = 0;
	}

	/**
	 *  Add a chunk to the end and reset `currentPos` to zero.
	 *  @param chunk - Chunk to be added
	 * 
	 * @param ChunkObject $chunk
	 * 
	 * @return void
	 */
	public function add ($chunk) {
		$chunk->flatten($this->parts);
		$this->reset();
	}

	/**
	 *  Clear all data of this cursor
	 * 
	 * @return void
	 */
	public function clear () {
		$this->parts = new \Array_hx();
		$this->reset();
	}

	/**
	 *  Creates a cloned cursor
	 *  @return cloned cursor
	 * 
	 * @return ChunkCursor
	 */
	public function clone () {
		$ret = new ChunkCursor();
		$ret->parts = (clone $this->parts);
		$ret->curPart = $this->curPart;
		$ret->curPartIndex = $this->curPartIndex;
		$ret->curOffset = $this->curOffset;
		$ret->curLength = $this->curLength;
		$ret->length = $this->length;
		$ret->currentPos = $this->currentPos;
		$ret->currentByte = $this->currentByte;
		return $ret;
	}

	/**
	 * @return void
	 */
	public function ffwd () {
		$this->currentByte = -1;
		$this->curLength = 0;
		$this->curOffset = 0;
		$this->curPart = null;
		$this->curPartIndex = $this->parts->length;
	}

	/**
	 *  Like prune(), but returns the removed chunk
	 *  @return Removed chunk (chunk to the left of current position)
	 * 
	 * @return ChunkObject
	 */
	public function flush () {
		$ret = $this->left();
		$this->shift();
		return $ret;
	}

	/**
	 *  Return the chunk to the left of current position, excluding current byte
	 * 
	 * @return ChunkObject
	 */
	public function left () {
		if ($this->curPart === null) {
			return Chunk_Impl_::$EMPTY;
		}
		$_g = new \Array_hx();
		$_g1 = 0;
		$_g2 = $this->curPartIndex;
		while ($_g1 < $_g2) {
			$x = ($this->parts->arr[$_g1++] ?? null);
			$_g->arr[$_g->length++] = $x;
		}
		$x = $this->curPart->slice(0, $this->curOffset);
		$_g->arr[$_g->length++] = $x;
		return Chunk_Impl_::join($_g);
	}

	/**
	 *  Move cursor position by specified amount.
	 *  @param delta - amount to move
	 *  @return new position
	 * 
	 * @param int $delta
	 * 
	 * @return int
	 */
	public function moveBy ($delta) {
		return $this->moveTo($this->currentPos + $delta);
	}

	/**
	 *  Move to specified position.
	 *  If `position` is greater than length of cursor, it is set to `length - 1`.
	 *  If `position` is less than zero, it is set to zero.
	 *  @param position - the position to move to
	 *  @return new position
	 * 
	 * @param int $position
	 * 
	 * @return int
	 */
	public function moveTo ($position) {
		if ($this->length === 0) {
			return 0;
		}
		if ($position > $this->length) {
			$position = $this->length - 1;
		}
		if ($position < 0) {
			$position = 0;
		}
		$this->currentPos = $position;
		if ($position === $this->length) {
			$this->ffwd();
		} else {
			$_g = 0;
			$_g1 = $this->parts->length;
			while ($_g < $_g1) {
				$i = $_g++;
				$c = ($this->parts->arr[$i] ?? null);
				$_g2 = $c->to - $c->from;
				if ($_g2 > $position) {
					$this->curPart = $c;
					$this->curPartIndex = $i;
					$this->curOffset = $position;
					$this->curLength = $c->to - $c->from;
					$this->currentByte = \ord($c->data->s[$c->from + $position]);
					break;
				} else {
					$position -= $_g2;
				}
			}
		}
		return $this->currentPos;
	}

	/**
	 *  Advance to next byte
	 *  @return `false` if there is no next byte
	 * 
	 * @return bool
	 */
	public function next () {
		if ($this->currentPos === $this->length) {
			return false;
		}
		$this->currentPos++;
		if ($this->currentPos === $this->length) {
			$this->ffwd();
			return false;
		}
		if ($this->curOffset === ($this->curLength - 1)) {
			$this->curOffset = 0;
			$this->curPart = ($this->parts->arr[++$this->curPartIndex] ?? null);
			$_this = $this->curPart;
			$this->curLength = $_this->to - $_this->from;
			$_this = $this->curPart;
			$this->currentByte = \ord($_this->data->s[$_this->from]);
		} else {
			$_this = $this->curPart;
			$this->currentByte = \ord($_this->data->s[$_this->from + ++$this->curOffset]);
		}
		return true;
	}

	/**
	 *  Remove chunk to the left of current position and reset `currentPos` to zero.
	 * 
	 * @return void
	 */
	public function prune () {
		$this->shift();
	}

	/**
	 * @return void
	 */
	public function reset () {
		$this->length = 0;
		$this->currentPos = 0;
		$this->currentByte = -1;
		$this->curOffset = 0;
		$_g = 0;
		$_g1 = $this->parts;
		while ($_g < $_g1->length) {
			$p = ($_g1->arr[$_g] ?? null);
			++$_g;
			$this->length += $p->to - $p->from;
		}
		$this->curPartIndex = 0;
		$this->curPart = ($this->parts->arr[0] ?? null);
		if ($this->curPart !== null) {
			$_this = $this->curPart;
			$this->curLength = $_this->to - $_this->from;
			$_this = $this->curPart;
			$this->currentByte = \ord($_this->data->s[$_this->from]);
		}
	}

	/**
	 *  Return the chunk to the right of current position, including current byte
	 * 
	 * @return ChunkObject
	 */
	public function right () {
		if ($this->curPart === null) {
			return Chunk_Impl_::$EMPTY;
		}
		$_g = new \Array_hx();
		$_g1 = $this->curPartIndex;
		$_g2 = $this->parts->length;
		while ($_g1 < $_g2) {
			$x = ($this->parts->arr[$_g1++] ?? null);
			$_g->arr[$_g->length++] = $x;
		}
		if ($_g->length > 0) {
			$_g->offsetSet(0, $this->curPart->slice($this->curOffset, $this->curLength));
		}
		return Chunk_Impl_::join($_g);
	}

	/**
	 * @param \Array_hx $seekable
	 * @param object $options
	 * 
	 * @return Option
	 */
	public function seek ($seekable, $options = null) {
		$_gthis = $this;
		if (($this->curPart === null) || ($seekable === null) || ($seekable->length === 0)) {
			return Option::None();
		}
		$max = $seekable->length - 1;
		$first = ($seekable->arr[0] ?? null);
		$candidates = new \Array_hx();
		$count = 0;
		$copy = $this->clone();
		$copy->shift();
		$part = function ($b, $offset) use (&$count, &$copy, &$candidates, &$_gthis, &$first, &$max, &$seekable, &$options) {
			$data = $b->data;
			$_g = $b->from + $offset;
			$_g1 = $b->to;
			while ($_g < $_g1) {
				$i = $_g++;
				$byte = \ord($data->s[$i]);
				if ($candidates->length > 0) {
					$c = 0;
					while ($c < $count) {
						$pos = ($candidates->arr[$c] ?? null);
						if (($seekable->arr[$pos] ?? null) === $byte) {
							if ($pos === $max) {
								$copy->moveTo($copy->currentPos + ($i - ($b->from + $offset) - $seekable->length + 1));
								$before = $copy->left();
								$delta = $before->getLength() + $seekable->length;
								$_gthis->moveTo($_gthis->currentPos + $delta);
								if ($options === null) {
									$_gthis->shift();
								} else {
									$_g2 = $options->withoutPruning;
									if ($_g2 === null) {
										$_gthis->shift();
									} else if ($_g2 === false) {
										$_gthis->shift();
									}
								}
								return Option::Some($before);
							} else {
								$candidates->offsetSet($c++, $pos + 1);
							}
						} else {
							$count -= 1;
							if ($candidates->length > 0) {
								$candidates->length--;
							}
							$last = \array_pop($candidates->arr);
							if ($count > $c) {
								$candidates->offsetSet($c, $last);
							}
						}
					}
				}
				if ($byte === $first) {
					$candidates->arr[$candidates->length++] = 1;
					$count = $candidates->length;
				}
			}
			$copy->moveTo($copy->currentPos + ($b->to - ($b->from + $offset)));
			return Option::None();
		};
		$_g = $part($this->curPart, $this->curOffset);
		if ($_g->index === 1) {
			$_g1 = $this->curPartIndex + 1;
			$_g2 = $this->parts->length;
			while ($_g1 < $_g2) {
				$_g3 = $part(($this->parts->arr[$_g1++] ?? null), 0);
				$__hx__switch = ($_g3->index);
				if ($__hx__switch === 0) {
					return Option::Some($_g3->params[0]);
				} else if ($__hx__switch === 1) {
				}
			}
			return Option::None();
		} else {
			return $_g;
		}
	}

	/**
	 *  Remove data to the left of current position and optionally add a chunk at the end.
	 *  Reset `currentPos` to zero.
	 *  @param chunk - Optional chunk to be added to the end
	 * 
	 * @param ChunkObject $chunk
	 * 
	 * @return void
	 */
	public function shift ($chunk = null) {
		$this->parts->splice(0, $this->curPartIndex);
		$_g = ($this->parts->arr[0] ?? null);
		if ($_g !== null) {
			$_g1 = $_g->getSlice($this->curOffset, $this->curLength);
			if ($_g1 === null) {
				$_this = $this->parts;
				if ($_this->length > 0) {
					$_this->length--;
				}
				\array_shift($_this->arr);
			} else {
				$this->parts->offsetSet(0, $_g1);
			}
		}
		if ($chunk !== null) {
			$this->add($chunk);
		} else {
			$this->reset();
		}
	}

	/**
	 *  Like moveBy(), but returns the swept chunk instead of new position
	 *  @param len - length to sweep
	 *  @return the swept chunk
	 * 
	 * @param int $len
	 * 
	 * @return ChunkObject
	 */
	public function sweep ($len) {
		$data = $this->right()->slice(0, $len);
		$this->moveTo($this->currentPos + $len);
		return $data;
	}

	/**
	 *  Like moveTo(), but returns the swept chunk instead of new position
	 *  @param pos - target position
	 *  @return the swept chunk
	 * 
	 * @param int $pos
	 * 
	 * @return ChunkObject
	 */
	public function sweepTo ($pos) {
		return $this->sweep($pos - $this->currentPos);
	}
}

Boot::registerClass(ChunkCursor::class, 'tink.chunk.ChunkCursor');
