<?php
/**
 * Generated by Haxe 4.1.4
 */

namespace tink\chunk;

use \haxe\io\_BytesData\Container;
use \php\Boot;
use \haxe\Exception;
use \haxe\io\Error;
use \tink\_Chunk\Chunk_Impl_;
use \haxe\io\Bytes;

class ByteChunk extends ChunkBase implements ChunkObject {
	/**
	 * @var Container
	 */
	public $data;
	/**
	 * @var int
	 */
	public $from;
	/**
	 * @var int
	 */
	public $to;
	/**
	 * @var Bytes
	 */
	public $wrapped;

	/**
	 * @param Bytes $b
	 * 
	 * @return ChunkObject
	 */
	public static function of ($b) {
		if ($b->length === 0) {
			return Chunk_Impl_::$EMPTY;
		}
		$ret = new ByteChunk($b->b, 0, $b->length);
		$ret->wrapped = $b;
		return $ret;
	}

	/**
	 * @param Container $data
	 * @param int $from
	 * @param int $to
	 * 
	 * @return void
	 */
	public function __construct ($data, $from, $to) {
		$this->data = $data;
		$this->from = $from;
		$this->to = $to;
	}

	/**
	 * @param Bytes $target
	 * @param int $offset
	 * 
	 * @return void
	 */
	public function blitTo ($target, $offset) {
		if ($this->wrapped === null) {
			$b = $this->data;
			$this->wrapped = new Bytes(\strlen($b->s), $b);
		}
		$src = $this->wrapped;
		$srcpos = $this->from;
		$len = $this->to - $this->from;
		if (($offset < 0) || ($srcpos < 0) || ($len < 0) || (($offset + $len) > $target->length) || (($srcpos + $len) > $src->length)) {
			throw Exception::thrown(Error::OutsideBounds());
		} else {
			$this1 = $target->b;
			$src1 = $src->b;
			$this1->s = ((\substr($this1->s, 0, $offset) . \substr($src1->s, $srcpos, $len)) . \substr($this1->s, $offset + $len));
		}
	}

	/**
	 * @param \Array_hx $into
	 * 
	 * @return void
	 */
	public function flatten ($into) {
		$into->arr[$into->length++] = $this;
	}

	/**
	 * @param int $index
	 * 
	 * @return int
	 */
	public function getByte ($index) {
		return \ord($this->data->s[$this->from + $index]);
	}

	/**
	 * @return int
	 */
	public function getLength () {
		return $this->to - $this->from;
	}

	/**
	 * @param int $from
	 * @param int $to
	 * 
	 * @return ByteChunk
	 */
	public function getSlice ($from, $to) {
		if ($to > ($this->to - $this->from)) {
			$to = $this->to - $this->from;
		}
		if ($from < 0) {
			$from = 0;
		}
		if ($to <= $from) {
			return null;
		} else if (($to === ($this->to - $this->from)) && ($from === 0)) {
			return $this;
		} else {
			return new ByteChunk($this->data, $this->from + $from, $to + $this->from);
		}
	}

	/**
	 * @return Bytes
	 */
	public function get_wrapped () {
		if ($this->wrapped === null) {
			$b = $this->data;
			$this->wrapped = new Bytes(\strlen($b->s), $b);
		}
		return $this->wrapped;
	}

	/**
	 * @param int $from
	 * @param int $to
	 * 
	 * @return ChunkObject
	 */
	public function slice ($from, $to) {
		$_g = $this->getSlice($from, $to);
		if ($_g === null) {
			return Chunk_Impl_::$EMPTY;
		} else {
			return $_g;
		}
	}

	/**
	 * @return Bytes
	 */
	public function toBytes () {
		if ($this->wrapped === null) {
			$b = $this->data;
			$this->wrapped = new Bytes(\strlen($b->s), $b);
		}
		$_this = $this->wrapped;
		$pos = $this->from;
		$len = $this->to - $this->from;
		if (($pos < 0) || ($len < 0) || (($pos + $len) > $_this->length)) {
			throw Exception::thrown(Error::OutsideBounds());
		} else {
			return new Bytes($len, new Container(\substr($_this->b->s, $pos, $len)));
		}
	}

	/**
	 * @return string
	 */
	public function toString () {
		if ($this->wrapped === null) {
			$b = $this->data;
			$this->wrapped = new Bytes(\strlen($b->s), $b);
		}
		$_this = $this->wrapped;
		$pos = $this->from;
		$len = $this->to - $this->from;
		if (($pos < 0) || ($len < 0) || (($pos + $len) > $_this->length)) {
			throw Exception::thrown(Error::OutsideBounds());
		} else {
			return \substr($_this->b->s, $pos, $len);
		}
	}

	public function __toString() {
		return $this->toString();
	}
}

Boot::registerClass(ByteChunk::class, 'tink.chunk.ByteChunk');
Boot::registerGetters('tink\\chunk\\ByteChunk', [
	'wrapped' => true
]);
