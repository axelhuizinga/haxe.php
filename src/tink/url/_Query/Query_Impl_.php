<?php
/**
 * Generated by Haxe 4.1.3
 */

namespace tink\url\_Query;

use \php\Boot;
use \haxe\IMap;
use \haxe\ds\StringMap;
use \tink\url\_Portion\Portion_Impl_;

final class Query_Impl_ {
	/**
	 * @return \Array_hx
	 */
	public static function build () {
		return new \Array_hx();
	}

	/**
	 * @param string $this
	 * 
	 * @return QueryStringParser
	 */
	public static function iterator ($this1) {
		return new QueryStringParser($this1, "&", "=", 0);
	}

	/**
	 * @param mixed $v
	 * 
	 * @return string
	 */
	public static function ofObj ($v) {
		$ret = new \Array_hx();
		$v1 = $v;
		$_g = 0;
		$_g1 = \Reflect::fields($v1);
		while ($_g < $_g1->length) {
			$k = ($_g1->arr[$_g] ?? null);
			++$_g;
			$name = Portion_Impl_::ofString($k);
			$value = Portion_Impl_::ofString(\Reflect::field($v1, $k));
			$ret->arr[$ret->length++] = ($name??'null') . "=" . ($value??'null');
		}
		return $ret->join("&");
	}

	/**
	 * @param string $this
	 * 
	 * @return QueryStringParser
	 */
	public static function parse ($this1) {
		return new QueryStringParser($this1, "&", "=", 0);
	}

	/**
	 * @param string $s
	 * @param string $sep
	 * @param string $set
	 * @param int $pos
	 * 
	 * @return QueryStringParser
	 */
	public static function parseString ($s, $sep = "&", $set = "=", $pos = 0) {
		if ($sep === null) {
			$sep = "&";
		}
		if ($set === null) {
			$set = "=";
		}
		if ($pos === null) {
			$pos = 0;
		}
		return new QueryStringParser($s, $sep, $set, $pos);
	}

	/**
	 * @param string $this
	 * 
	 * @return StringMap
	 */
	public static function toMap ($this1) {
		$_g = new StringMap();
		$p = new QueryStringParser($this1, "&", "=", 0);
		while ($p->hasNext()) {
			$p1 = $p->next();
			$_g->data[$p1->name] = $p1->value;
		}
		return $_g;
	}

	/**
	 * @param string $this
	 * 
	 * @return string
	 */
	public static function toString ($this1) {
		return $this1;
	}

	/**
	 * @param string $this
	 * @param IMap $values
	 * 
	 * @return string
	 */
	public static function with ($this1, $values) {
		$ret = new \Array_hx();
		$_g = new \Array_hx();
		$key = $values->keys();
		while ($key->hasNext()) {
			$key1 = $key->next();
			$_g->arr[$_g->length++] = $key1;
		}
		$p = new QueryStringParser($this1, "&", "=", 0);
		while ($p->hasNext()) {
			$p1 = $p->next();
			if ($values->exists(Portion_Impl_::ofString($p1->name))) {
				$name = Portion_Impl_::ofString($p1->name);
				$value = $values->get(Portion_Impl_::ofString($p1->name));
				$ret->arr[$ret->length++] = ($name??'null') . "=" . ($value??'null');
				$_g->remove(Portion_Impl_::ofString($p1->name));
			} else {
				$name1 = Portion_Impl_::ofString($p1->name);
				$ret->arr[$ret->length++] = ($name1??'null') . "=" . ($p1->value??'null');
			}
		}
		$_g1 = 0;
		while ($_g1 < $_g->length) {
			$name = ($_g->arr[$_g1] ?? null);
			++$_g1;
			$value = $values->get($name);
			$ret->arr[$ret->length++] = ($name??'null') . "=" . ($value??'null');
		}
		return $ret->join("&");
	}
}

Boot::registerClass(Query_Impl_::class, 'tink.url._Query.Query_Impl_');
