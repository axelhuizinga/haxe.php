<?php
/**
 * Generated by Haxe 4.1.5
 */

namespace tink\http\containers;

use \tink\http\IncomingRequest;
use \php\_Boot\HxAnon;
use \tink\http\Container;
use \tink\core\_Future\SyncFuture;
use \tink\http\ContainerResult;
use \php\Boot;
use \tink\io\_Source\Source_Impl_;
use \tink\core\Outcome;
use \tink\http\ResponseHeaderBase;
use \tink\core\_Lazy\LazyConst;
use \tink\http\_Response\OutgoingResponseData;
use \tink\core\SignalTrigger;
use \tink\core\FutureObject;
use \tink\http\HandlerObject;

class LocalContainer implements Container {
	/**
	 * @var HandlerObject
	 */
	public $handler;
	/**
	 * @var bool
	 */
	public $running;

	/**
	 * @return void
	 */
	public function __construct () {
	}

	/**
	 * @param HandlerObject $handler
	 * 
	 * @return FutureObject
	 */
	public function run ($handler) {
		$_gthis = $this;
		$this->handler = $handler;
		$this->running = true;
		return new SyncFuture(new LazyConst(ContainerResult::Running(new HxAnon([
			"failures" => new SignalTrigger(),
			"shutdown" => function ($hard) use (&$_gthis) {
				$_gthis->running = false;
				return (new SyncFuture(new LazyConst(true)))->map(Boot::getStaticClosure(Outcome::class, 'Success'))->gather();
			},
		]))));
	}

	/**
	 * @param IncomingRequest $req
	 * 
	 * @return FutureObject
	 */
	public function serve ($req) {
		if (!$this->running) {
			return new SyncFuture(new LazyConst(new OutgoingResponseData(new ResponseHeaderBase(503, "Server stopped", new \Array_hx(), "HTTP/1.1"), Source_Impl_::$EMPTY)));
		}
		return $this->handler->process($req);
	}
}

Boot::registerClass(LocalContainer::class, 'tink.http.containers.LocalContainer');
