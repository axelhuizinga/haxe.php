<?php
/**
 * Generated by Haxe 4.1.4
 */

namespace tink\http;

use \php\_Boot\HxAnon;
use \php\Boot;
use \tink\core\TypedError;
use \tink\core\Outcome;
use \php\_Boot\HxString;
use \tink\core\OutcomeTools;
use \tink\http\_Header\HeaderValue_Impl_;
use \haxe\iterators\ArrayIterator;

class Header {
	/**
	 * @var \Array_hx
	 */
	public $fields;

	/**
	 * @param \Array_hx $fields
	 * 
	 * @return void
	 */
	public function __construct ($fields = null) {
		$this->fields = ($fields === null ? new \Array_hx() : $fields);
	}

	/**
	 * @param string $type
	 * 
	 * @return Outcome
	 */
	public function accepts ($type) {
		$prefix = (HxString::split($type, "/")->arr[0] ?? null);
		return OutcomeTools::map($this->byName("accept"), function ($v) use (&$prefix, &$type) {
			$_g = 0;
			$_g1 = HeaderValue_Impl_::parse($v);
			while ($_g < $_g1->length) {
				$entry = ($_g1->arr[$_g] ?? null);
				++$_g;
				if (($entry->value === "*/*") || ($entry->value === $type)) {
					return true;
				}
				$_g2 = HxString::split($entry->value, "/");
				if ($_g2->length === 2) {
					if (($_g2->arr[1] ?? null) === "*") {
						if ($prefix === ($_g2->arr[0] ?? null)) {
							return true;
						}
					}
				}
			}
			return false;
		});
	}

	/**
	 *  Get a header
	 *  @param name - Header name to retrieve
	 *  @return `Success(header)` if there is exactly one entry of the given header name, `Failure(err)` otherwise
	 * 
	 * @param string $name
	 * 
	 * @return Outcome
	 */
	public function byName ($name) {
		$_g = $this->get($name);
		$__hx__switch = ($_g->length);
		if ($__hx__switch === 0) {
			return Outcome::Failure(new TypedError(422, "No " . ($name??'null') . " header found", new HxAnon([
				"fileName" => "tink/http/Header.hx",
				"lineNumber" => 91,
				"className" => "tink.http.Header",
				"methodName" => "byName",
			])));
		} else if ($__hx__switch === 1) {
			return Outcome::Success(($_g->arr[0] ?? null));
		} else {
			return Outcome::Failure(new TypedError(422, "Multiple entries for " . ($name??'null') . " header", new HxAnon([
				"fileName" => "tink/http/Header.hx",
				"lineNumber" => 95,
				"className" => "tink.http.Header",
				"methodName" => "byName",
			])));
		}
	}

	/**
	 *  Clone this header with additional header fields
	 *  @param fields - Header fields to be added
	 *  @return Header with additional fields
	 * 
	 * @param \Array_hx $fields
	 * 
	 * @return Header
	 */
	public function concat ($fields) {
		return new Header($this->fields->concat($fields));
	}

	/**
	 *  Get the content type header
	 * 
	 * @return Outcome
	 */
	public function contentType () {
		return OutcomeTools::map($this->byName("content-type"), Boot::getStaticClosure(ContentType::class, 'ofString'));
	}

	/**
	 *  Get all headers of the given name
	 *  @param name - Header name to retrieve
	 *  @return Array of headers of the given name
	 * 
	 * @param string $name
	 * 
	 * @return \Array_hx
	 */
	public function get ($name) {
		$_g = new \Array_hx();
		$_g1 = 0;
		$_g2 = $this->fields;
		while ($_g1 < $_g2->length) {
			$f = ($_g2->arr[$_g1] ?? null);
			++$_g1;
			if ($f->name === $name) {
				$_g->arr[$_g->length++] = $f->value;
			}
		}
		return $_g;
	}

	/**
	 *  Get content length. Assumes zero if content-length header is missing
	 * 
	 * @return Outcome
	 */
	public function getContentLength () {
		$_g = $this->byName("content-length");
		$__hx__switch = ($_g->index);
		if ($__hx__switch === 0) {
			$_hx_tmp = \Std::parseInt($_g->params[0]);
			if ($_hx_tmp === null) {
				return Outcome::Failure(new TypedError(422, "Invalid Content-Length Header", new HxAnon([
					"fileName" => "tink/http/Header.hx",
					"lineNumber" => 120,
					"className" => "tink.http.Header",
					"methodName" => "getContentLength",
				])));
			} else {
				return Outcome::Success($_hx_tmp);
			}
		} else if ($__hx__switch === 1) {
			return Outcome::Failure($_g->params[0]);
		}
	}

	/**
	 * @return string
	 */
	public function get_LINEBREAK () {
		return "\x0D\x0A";
	}

	/**
	 * @param string $name
	 * 
	 * @return string
	 */
	public function headerNotFound ($name) {
		return "No " . ($name??'null') . " header found";
	}

	/**
	 * @return ArrayIterator
	 */
	public function iterator () {
		return new ArrayIterator($this->fields);
	}

	/**
	 * @return string
	 */
	public function toString () {
		$_g = new \Array_hx();
		$_g1 = 0;
		$_g2 = $this->fields;
		while ($_g1 < $_g2->length) {
			$x = ($_g2->arr[$_g1++] ?? null)->toString();
			$_g->arr[$_g->length++] = $x;
		}
		return ($_g->join("\x0D\x0A")??'null') . "\x0D\x0A" . "\x0D\x0A";
	}

	public function __toString() {
		return $this->toString();
	}
}

Boot::registerClass(Header::class, 'tink.http.Header');
Boot::registerGetters('tink\\http\\Header', [
	'LINEBREAK' => true
]);
