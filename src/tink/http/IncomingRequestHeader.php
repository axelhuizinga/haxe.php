<?php
/**
 * Generated by Haxe 4.1.5
 */

namespace tink\http;

use \php\_Boot\HxAnon;
use \tink\io\StreamParserObject;
use \php\Boot;
use \haxe\Exception;
use \tink\url\_Query\QueryStringParser;
use \haxe\io\_BytesData\Container as _BytesDataContainer;
use \tink\core\TypedError;
use \tink\core\Outcome;
use \php\_Boot\HxString;
use \tink\core\OutcomeTools;
use \haxe\ds\StringMap;
use \tink\_Url\Url_Impl_;
use \haxe\io\Bytes;
use \php\_NativeIndexedArray\NativeIndexedArrayIterator;
use \haxe\NativeStackTrace;
use \tink\core\_Outcome\OutcomeMapper_Impl_;
use \tink\url\_Portion\Portion_Impl_;

class IncomingRequestHeader extends RequestHeader {
	/**
	 * @var StringMap
	 */
	public $cookies;

	/**
	 *  Get a StreamParser which can parse a Source into an IncomingRequestHeader
	 * 
	 * @return StreamParserObject
	 */
	public static function parser () {
		return new HeaderParser(function ($line, $headers) {
			$_g = HxString::split($line, " ");
			if ($_g->length === 3) {
				$_g1 = ($_g->arr[2] ?? null);
				$_g2 = ($_g->arr[0] ?? null);
				return Outcome::Success(new IncomingRequestHeader($_g2, Url_Impl_::fromString(($_g->arr[1] ?? null)), $_g1, $headers));
			} else {
				return Outcome::Failure(new TypedError(422, "Invalid HTTP header", new HxAnon([
					"fileName" => "tink/http/Request.hx",
					"lineNumber" => 95,
					"className" => "tink.http.IncomingRequestHeader",
					"methodName" => "parser",
				])));
			}
		});
	}

	/**
	 * @param string $method
	 * @param object $url
	 * @param string $protocol
	 * @param \Array_hx $fields
	 * 
	 * @return void
	 */
	public function __construct ($method, $url, $protocol, $fields) {
		parent::__construct($method, $url, $protocol, $fields);
	}

	/**
	 * @param \Array_hx $fields
	 * 
	 * @return IncomingRequestHeader
	 */
	public function concat ($fields) {
		$tmp = $this->method;
		$tmp1 = $this->url;
		$tmp2 = $this->protocol;
		return new IncomingRequestHeader($tmp, $tmp1, $tmp2, $this->fields->concat($fields));
	}

	/**
	 *  List all cookie names
	 * 
	 * @return object
	 */
	public function cookieNames () {
		return new NativeIndexedArrayIterator(\array_values(\array_map("strval", \array_keys($this->cookies->data))));
	}

	/**
	 *  Get the Authorization header as an Enum
	 * 
	 * @return Outcome
	 */
	public function getAuth () {
		return $this->getAuthWith(function ($s, $p) {
			if ($s === "Basic") {
				$decoded = null;
				try {
					$s1 = \base64_decode($p, true);
					$decoded1 = \strlen($s1);
					$decoded = (new Bytes($decoded1, new _BytesDataContainer($s1)))->toString();
				} catch(\Throwable $_g) {
					NativeStackTrace::saveStack($_g);
					return Outcome::Failure(TypedError::withData(null, "Error in decoding basic auth", Exception::caught($_g)->unwrap(), new HxAnon([
						"fileName" => "tink/http/Request.hx",
						"lineNumber" => 67,
						"className" => "tink.http.IncomingRequestHeader",
						"methodName" => "getAuth",
					])));
				}
				$_g = HxString::indexOf($decoded, ":");
				if ($_g === -1) {
					return Outcome::Failure(new TypedError(null, "Cannot parse username and password because \":\" is missing", new HxAnon([
						"fileName" => "tink/http/Request.hx",
						"lineNumber" => 69,
						"className" => "tink.http.IncomingRequestHeader",
						"methodName" => "getAuth",
					])));
				} else {
					$tmp = \mb_substr($decoded, 0, $_g);
					return Outcome::Success(Authorization::Basic($tmp, \mb_substr($decoded, $_g + 1, null)));
				}
			} else if ($s === "Bearer") {
				return Outcome::Success(Authorization::Bearer($p));
			} else {
				return Outcome::Success(Authorization::Others($s, $p));
			}
		});
	}

	/**
	 * @param \Closure $parser
	 * 
	 * @return Outcome
	 */
	public function getAuthWith ($parser) {
		return OutcomeTools::flatMap($this->byName("authorization"), OutcomeMapper_Impl_::withSameError(function ($v) use (&$parser) {
			$_g = HxString::indexOf($v, " ");
			if ($_g === -1) {
				return Outcome::Failure(new TypedError(422, "Invalid Authorization Header", new HxAnon([
					"fileName" => "tink/http/Request.hx",
					"lineNumber" => 81,
					"className" => "tink.http.IncomingRequestHeader",
					"methodName" => "getAuthWith",
				])));
			} else {
				return $parser(\mb_substr($v, 0, $_g), \mb_substr($v, $_g + 1, null));
			}
		}));
	}

	/**
	 *  Get a single cookie
	 * 
	 * @param string $name
	 * 
	 * @return string
	 */
	public function getCookie ($name) {
		return ($this->getCookies()->data[$name] ?? null);
	}

	/**
	 * @return StringMap
	 */
	public function getCookies () {
		if ($this->cookies === null) {
			$_g = new StringMap();
			$_g1 = 0;
			$_g2 = $this->get(\mb_strtolower("cookie"));
			while ($_g1 < $_g2->length) {
				$entry = new QueryStringParser(($_g2->arr[$_g1++] ?? null), ";", "=", 0);
				while ($entry->hasNext()) {
					$entry1 = $entry->next();
					$key = $entry1->name;
					$value = Portion_Impl_::toString($entry1->value);
					$_g->data[$key] = $value;
				}
			}
			$this->cookies = $_g;
		}
		return $this->cookies;
	}
}

Boot::registerClass(IncomingRequestHeader::class, 'tink.http.IncomingRequestHeader');
