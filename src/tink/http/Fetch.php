<?php
/**
 * Generated by Haxe 4.1.5
 */

namespace tink\http;

use \tink\http\clients\SecureSocketClient;
use \tink\http\_Client\CustomClient;
use \php\_Boot\HxAnon;
use \tink\core\_Future\SyncFuture;
use \php\Boot;
use \tink\http\clients\CurlClient;
use \tink\io\_Source\Source_Impl_;
use \tink\core\Outcome;
use \tink\core\_Lazy\LazyConst;
use \tink\http\clients\StdClient;
use \tink\core\_Future\Future_Impl_;
use \tink\_Url\Url_Impl_;
use \tink\core\_Promise\Promise_Impl_;
use \haxe\ds\EnumValueMap;
use \tink\http\clients\SecureCurlClient;
use \tink\http\clients\SocketClient;
use \tink\http\clients\LocalContainerClient;
use \tink\core\FutureObject;
use \tink\http\clients\PhpClient;

class Fetch {
	/**
	 * @var EnumValueMap
	 */
	static public $client;
	/**
	 * @var EnumValueMap
	 */
	static public $sclient;

	/**
	 * @param object $url
	 * @param object $options
	 * 
	 * @return FutureObject
	 */
	public static function fetch ($url, $options = null) {
		return Future_Impl_::async(function ($cb) use (&$url, &$options) {
			$method = "GET";
			$headers = null;
			$body = Source_Impl_::$EMPTY;
			$type = ClientType::Default();
			$followRedirect = true;
			if ($options !== null) {
				if ($options->method !== null) {
					$method = $options->method;
				}
				if ($options->headers !== null) {
					$headers = $options->headers;
				}
				if ($options->body !== null) {
					$body = $options->body;
				}
				if ($options->client !== null) {
					$type = $options->client;
				}
				if ($options->followRedirect === false) {
					$followRedirect = false;
				}
			}
			$client = Fetch::getClient($type, $url->scheme === "https");
			if (($options !== null) && ($options->augment !== null)) {
				$pipeline = $options->augment;
				$client = CustomClient::create($client, $pipeline->before, $pipeline->after);
			}
			$client->request(new OutgoingRequest(new OutgoingRequestHeader($method, $url, null, $headers), $body))->handle(function ($res) use (&$followRedirect, &$url, &$cb, &$options) {
				$__hx__switch = ($res->index);
				if ($__hx__switch === 0) {
					$_g = $res->params[0];
					$_g1 = $_g->header->statusCode;
					if ($_g1 === 301 || $_g1 === 302 || $_g1 === 303 || $_g1 === 307 || $_g1 === 308) {
						$code = $_g1;
						if ($followRedirect) {
							Promise_Impl_::next(new SyncFuture(new LazyConst($_g->header->byName(\mb_strtolower("location")))), function ($location) use (&$url, &$code, &$options) {
								$this1 = Url_Impl_::resolve($url, Url_Impl_::fromString($location));
								$this2 = null;
								if ($code === 303) {
									$__o0 = $options;
									$__tink_tmp0 = new HxAnon(["method" => "GET"]);
									$_g = $__o0->headers;
									if ($_g !== null) {
										$__tink_tmp0->headers = $_g;
									}
									$_g = $__o0->followRedirect;
									if ($_g !== null) {
										$__tink_tmp0->followRedirect = $_g;
									}
									$_g = $__o0->client;
									if ($_g !== null) {
										$__tink_tmp0->client = $_g;
									}
									$_g = $__o0->body;
									if ($_g !== null) {
										$__tink_tmp0->body = $_g;
									}
									$_g = $__o0->augment;
									if ($_g !== null) {
										$__tink_tmp0->augment = $_g;
									}
									$this2 = $__tink_tmp0;
								} else {
									$this2 = $options;
								}
								return Fetch::fetch($this1, $this2);
							})->handle($cb);
						} else {
							$cb(Outcome::Success($_g));
						}
					} else {
						$cb(Outcome::Success($_g));
					}
				} else if ($__hx__switch === 1) {
					$cb(Outcome::Failure($res->params[0]));
				}
			});
		});
	}

	/**
	 * @param ClientType $type
	 * @param bool $secure
	 * 
	 * @return ClientObject
	 */
	public static function getClient ($type, $secure) {
		$cache = ($secure ? Fetch::$sclient : Fetch::$client);
		if (!$cache->exists($type)) {
			$c = null;
			$__hx__switch = ($type->index);
			if ($__hx__switch === 0) {
				$c = ($secure ? new SecureSocketClient() : new SocketClient());
			} else if ($__hx__switch === 1) {
				$c = new LocalContainerClient($type->params[0]);
			} else if ($__hx__switch === 2) {
				$c = ($secure ? new SecureCurlClient() : new CurlClient());
			} else if ($__hx__switch === 3) {
				$c = ($secure ? new StdClient() : new StdClient());
			} else if ($__hx__switch === 4) {
				$c = $type->params[0];
			} else if ($__hx__switch === 5) {
				$c = ($secure ? new PhpClient() : new PhpClient());
			}
			$cache->set($type, $c);
		}
		return $cache->get($type);
	}

	/**
	 * @internal
	 * @access private
	 */
	static public function __hx__init ()
	{
		static $called = false;
		if ($called) return;
		$called = true;


		self::$client = new EnumValueMap();
		self::$sclient = new EnumValueMap();
	}
}

Boot::registerClass(Fetch::class, 'tink.http.Fetch');
Fetch::__hx__init();
