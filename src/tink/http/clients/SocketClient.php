<?php
/**
 * Generated by Haxe 4.1.5
 */

namespace tink\http\clients;

use \haxe\io\_BytesData\Container;
use \php\net\SslSocket;
use \php\_Boot\HxAnon;
use \tink\http\HeaderField;
use \tink\core\_Lazy\LazyFunc;
use \tink\io\RealSourceTools;
use \php\Boot;
use \sys\net\Socket;
use \tink\io\std\InputSource;
use \tink\core\Noise;
use \tink\http\IncomingResponse;
use \tink\io\_Source\Source_Impl_;
use \tink\streams\Single;
use \tink\core\TypedError;
use \tink\io\_Worker\Worker_Impl_;
use \tink\chunk\ByteChunk;
use \tink\core\Outcome;
use \tink\io\WorkerObject;
use \tink\http\ResponseHeaderBase;
use \tink\core\_Lazy\LazyConst;
use \sys\net\Host;
use \tink\core\_Future\Future_Impl_;
use \tink\_Url\Url_Impl_;
use \tink\http\ClientObject;
use \tink\url\_Host\Host_Impl_;
use \tink\io\_Sink\SinkYielding_Impl_;
use \haxe\io\Bytes;
use \tink\http\OutgoingRequest;
use \tink\core\FutureObject;

class SocketClient implements ClientObject {
	/**
	 * @var bool
	 */
	public $secure;
	/**
	 * @var WorkerObject
	 */
	public $worker;

	/**
	 * @param WorkerObject $worker
	 * 
	 * @return void
	 */
	public function __construct ($worker = null) {
		$this->secure = false;
		$this->worker = Worker_Impl_::ensure($worker);
	}

	/**
	 * @param OutgoingRequest $req
	 * 
	 * @return FutureObject
	 */
	public function request ($req) {
		$_gthis = $this;
		return Future_Impl_::async(function ($cb) use (&$req, &$_gthis) {
			$addHeaders = function ($headers) use (&$req) {
				$req1 = $req->header->concat($headers);
				$req = new OutgoingRequest($req1, $req->body);
			};
			$_g = $req->header->byName(\mb_strtolower("connection"));
			$__hx__switch = ($_g->index);
			if ($__hx__switch === 0) {
				$_g1 = $_g->params[0];
				if (\mb_strtolower($_g1) !== "close") {
					$cb(Outcome::Failure(new TypedError(null, "Only \"Connection: Close\" is supported. But specified as \"" . ($_g1??'null') . "\"", new HxAnon([
						"fileName" => "tink/http/clients/SocketClient.hx",
						"lineNumber" => 33,
						"className" => "tink.http.clients.SocketClient",
						"methodName" => "request",
					]))));
					return;
				}
			} else if ($__hx__switch === 1) {
				$addHeaders(\Array_hx::wrap([new HeaderField(\mb_strtolower("connection"), "close")]));
			}
			$__hx__switch = ($req->header->byName(\mb_strtolower("host"))->index);
			if ($__hx__switch === 0) {
			} else if ($__hx__switch === 1) {
				$tmp = \mb_strtolower("host");
				$addHeaders(\Array_hx::wrap([new HeaderField($tmp, Host_Impl_::get_name(($req->header->url->hosts->arr[0] ?? null)))]));
			}
			$socket = ($_gthis->secure ? new SslSocket() : new Socket());
			$port = null;
			$_g = Host_Impl_::get_port(($req->header->url->hosts->arr[0] ?? null));
			$port = ($_g === null ? ($_gthis->secure ? 443 : 80) : $_g);
			Worker_Impl_::work($_gthis->worker, new LazyFunc(function () use (&$port, &$req, &$socket) {
				$socket->connect(new Host(Host_Impl_::get_name(($req->header->url->hosts->arr[0] ?? null))), $port);
				return Noise::Noise();
			}))->handle(function ($_) use (&$req, &$_gthis, &$cb, &$socket) {
				$sink = SinkYielding_Impl_::ofOutput("Request to " . ((($req->header->url === null ? "null" : Url_Impl_::toString($req->header->url)))??'null'), $socket->output, new HxAnon(["worker" => $_gthis->worker]));
				$name = ($req->header->url === null ? "null" : Url_Impl_::toString($req->header->url));
				$input = $socket->input;
				$options = new HxAnon(["worker" => $_gthis->worker]);
				if ($options === null) {
					$options = new HxAnon();
				}
				$source = Worker_Impl_::ensure($options->worker);
				$_g = $options->chunkSize;
				$source1 = new InputSource("Response from " . ($name??'null'), $input, $source, Bytes::alloc(($_g === null ? 65536 : $_g)), 0);
				$this1 = $req->body;
				$s = $req->header->toString();
				$b = \strlen($s);
				Source_Impl_::pipeTo($this1->prepend(new Single(new LazyConst(ByteChunk::of(new Bytes($b, new Container($s)))))), $sink)->handle(function ($r) use (&$cb, &$source1) {
					$__hx__switch = ($r->index);
					if ($__hx__switch === 0) {
						RealSourceTools::parse($source1, ResponseHeaderBase::parser())->handle(function ($o) use (&$cb) {
							$__hx__switch = ($o->index);
							if ($__hx__switch === 0) {
								$_g = $o->params[0];
								$_g1 = $_g->a->getContentLength();
								$__hx__switch = ($_g1->index);
								if ($__hx__switch === 0) {
									$parsed = $_g->a;
									$cb(Outcome::Success(new IncomingResponse($parsed, Source_Impl_::limit($_g->b, $_g1->params[0]))));
								} else if ($__hx__switch === 1) {
									$cb(Outcome::Failure(new TypedError(null, "Chunked encoding is not supported and the content-length header is required.", new HxAnon([
										"fileName" => "tink/http/clients/SocketClient.hx",
										"lineNumber" => 74,
										"className" => "tink.http.clients.SocketClient",
										"methodName" => "request",
									]))));
								}
							} else if ($__hx__switch === 1) {
								$cb(Outcome::Failure($o->params[0]));
							}
						});
					} else if ($__hx__switch === 1) {
						$cb(Outcome::Failure(new TypedError(null, "Sink ended unexpectedly", new HxAnon([
							"fileName" => "tink/http/clients/SocketClient.hx",
							"lineNumber" => 79,
							"className" => "tink.http.clients.SocketClient",
							"methodName" => "request",
						]))));
					} else if ($__hx__switch === 2) {
						$cb(Outcome::Failure($r->params[0]));
					}
				});
			});
		});
	}
}

Boot::registerClass(SocketClient::class, 'tink.http.clients.SocketClient');
