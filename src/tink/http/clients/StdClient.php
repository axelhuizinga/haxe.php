<?php
/**
 * Generated by Haxe 4.1.4
 */

namespace tink\http\clients;

use \haxe\io\_BytesData\Container;
use \php\_Boot\HxAnon;
use \tink\http\HeaderField;
use \tink\core\_Lazy\LazyFunc;
use \php\Boot;
use \tink\http\IncomingResponse;
use \tink\core\_Callback\Callback_Impl_;
use \tink\streams\Single;
use \tink\core\TypedError;
use \tink\io\_Worker\Worker_Impl_;
use \tink\chunk\ByteChunk;
use \tink\core\Outcome;
use \tink\io\WorkerObject;
use \tink\http\ResponseHeaderBase;
use \tink\core\_Lazy\LazyConst;
use \sys\Http;
use \tink\core\_Future\Future_Impl_;
use \tink\_Url\Url_Impl_;
use \tink\http\ClientObject;
use \haxe\io\Bytes;
use \tink\http\OutgoingRequest;
use \php\_NativeIndexedArray\NativeIndexedArrayIterator;
use \tink\core\FutureObject;
use \tink\io\IdealSourceTools;

class StdClient implements ClientObject {
	/**
	 * @var WorkerObject
	 */
	public $worker;

	/**
	 * @param WorkerObject $worker
	 * 
	 * @return void
	 */
	public function __construct ($worker = null) {
		$this->worker = Worker_Impl_::ensure($worker);
	}

	/**
	 * @param OutgoingRequest $req
	 * 
	 * @return FutureObject
	 */
	public function request ($req) {
		$_gthis = $this;
		return Future_Impl_::async(function ($cb) use (&$req, &$_gthis) {
			$r = new Http(Url_Impl_::toString($req->header->url));
			$send = function ($post) use (&$r, &$_gthis, &$cb) {
				$code = 200;
				$r->onStatus = function ($c) use (&$code) {
					$code = $c;
				};
				$headers = function () use (&$r) {
					$_g = $r->responseHeaders;
					if ($_g === null) {
						return new \Array_hx();
					} else {
						$_g1 = new \Array_hx();
						$name = new NativeIndexedArrayIterator(\array_values(\array_map("strval", \array_keys($_g->data))));
						while ($name->hasNext()) {
							$name1 = $name->next();
							$x = \mb_strtolower($name1);
							$x1 = new HeaderField($x, ($_g->data[$name1] ?? null));
							$_g1->arr[$_g1->length++] = $x1;
						}
						return $_g1;
					}
				};
				$r->onError = function ($msg) use (&$_gthis, &$cb, &$code) {
					if ($code === 200) {
						$code = 500;
					}
					Worker_Impl_::work($_gthis->worker, new LazyConst(true))->handle(Callback_Impl_::fromNiladic(function () use (&$msg, &$cb, &$code) {
						$cb(Outcome::Failure(new TypedError($code, $msg, new HxAnon([
							"fileName" => "tink/http/clients/StdClient.hx",
							"lineNumber" => 44,
							"className" => "tink.http.clients.StdClient",
							"methodName" => "request",
						]))));
					}));
				};
				$r->onData = function ($data) use (&$headers, &$_gthis, &$cb, &$code) {
					Worker_Impl_::work($_gthis->worker, new LazyConst(true))->handle(Callback_Impl_::fromNiladic(function () use (&$headers, &$data, &$cb, &$code) {
						$cb1 = $cb;
						$fields = $headers();
						$this1 = new ResponseHeaderBase($code, "OK", $fields, "HTTP/1.1");
						$b = \strlen($data);
						$cb1(Outcome::Success(new IncomingResponse($this1, new Single(new LazyConst(ByteChunk::of(new Bytes($b, new Container($data))))))));
					}));
				};
				Worker_Impl_::work($_gthis->worker, new LazyFunc(function () use (&$post, &$r) {
					$r->request($post);
				}));
			};
			$_this = $req->header->fields;
			$_g_current = 0;
			while ($_g_current < $_this->length) {
				$h = ($_this->arr[$_g_current++] ?? null);
				$r->setHeader($h->name, $h->value);
			}
			$__hx__switch = ($req->header->method);
			if ($__hx__switch === "GET" || $__hx__switch === "HEAD" || $__hx__switch === "OPTIONS") {
				$send(false);
			} else {
				IdealSourceTools::all($req->body)->handle(function ($bytes) use (&$r, &$send) {
					$r->setPostData($bytes->toString());
					$send(true);
				});
			}
		});
	}
}

Boot::registerClass(StdClient::class, 'tink.http.clients.StdClient');
