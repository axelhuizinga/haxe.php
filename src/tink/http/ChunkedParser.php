<?php
/**
 * Generated by Haxe 4.1.5
 */

namespace tink\http;

use \php\_Boot\HxAnon;
use \tink\chunk\_Seekable\Seekable_Impl_;
use \tink\io\StreamParserObject;
use \php\Boot;
use \haxe\io\_BytesData\Container as _BytesDataContainer;
use \tink\core\TypedError;
use \tink\core\Outcome;
use \tink\io\ParseStep;
use \haxe\io\Bytes;
use \tink\_Chunk\Chunk_Impl_;
use \tink\chunk\ChunkCursor;

class ChunkedParser implements StreamParserObject {
	/**
	 * @var \Array_hx
	 */
	static public $LINEBREAK;

	/**
	 * @var int
	 */
	public $chunkSize;

	/**
	 * @return void
	 */
	public function __construct () {
		$this->reset();
	}

	/**
	 * @param ChunkCursor $rest
	 * 
	 * @return Outcome
	 */
	public function eof ($rest) {
		if ($this->chunkSize === 0) {
			return Outcome::Success(Chunk_Impl_::$EMPTY);
		} else {
			return Outcome::Failure(new TypedError(null, "Unexpected end of input", new HxAnon([
				"fileName" => "tink/http/Chunked.hx",
				"lineNumber" => 89,
				"className" => "tink.http.ChunkedParser",
				"methodName" => "eof",
			])));
		}
	}

	/**
	 * @param ChunkCursor $cursor
	 * 
	 * @return ParseStep
	 */
	public function progress ($cursor) {
		if ($this->chunkSize < 0) {
			$_g = $cursor->seek(ChunkedParser::$LINEBREAK);
			$__hx__switch = ($_g->index);
			if ($__hx__switch === 0) {
				$_g1 = $_g->params[0];
				$this->chunkSize = \Std::parseInt("0x" . ((($_g1 === null ? "null" : $_g1->toString()))??'null'));
			} else if ($__hx__switch === 1) {
			}
			return ParseStep::Progressed();
		} else if ($this->chunkSize === 0) {
			return ParseStep::Progressed();
		} else if ($cursor->length >= ($this->chunkSize + 2)) {
			$_g = $cursor->seek(ChunkedParser::$LINEBREAK);
			$__hx__switch = ($_g->index);
			if ($__hx__switch === 0) {
				$this->reset();
				return ParseStep::Done($_g->params[0]);
			} else if ($__hx__switch === 1) {
				return ParseStep::Failed(new TypedError(null, "Invalid encoding", new HxAnon([
					"fileName" => "tink/http/Chunked.hx",
					"lineNumber" => 82,
					"className" => "tink.http.ChunkedParser",
					"methodName" => "progress",
				])));
			}
		} else {
			return ParseStep::Progressed();
		}
	}

	/**
	 * @return void
	 */
	public function reset () {
		$this->chunkSize = -1;
	}

	/**
	 * @internal
	 * @access private
	 */
	static public function __hx__init ()
	{
		static $called = false;
		if ($called) return;
		$called = true;


		$tmp = \strlen("\x0D\x0A");
		self::$LINEBREAK = Seekable_Impl_::ofBytes(new Bytes($tmp, new _BytesDataContainer("\x0D\x0A")));
	}
}

Boot::registerClass(ChunkedParser::class, 'tink.http.ChunkedParser');
ChunkedParser::__hx__init();
