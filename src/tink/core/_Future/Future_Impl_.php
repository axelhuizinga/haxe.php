<?php
/**
 * Generated by Haxe 4.1.2
 */

namespace tink\core\_Future;

use \tink\core\_Callback\LinkPair;
use \haxe\Timer;
use \tink\core\_Lazy\LazyObject;
use \php\Boot;
use \haxe\ds\Either;
use \tink\core\Noise;
use \tink\core\_Callback\Callback_Impl_;
use \tink\core\Outcome;
use \tink\core\FutureTrigger;
use \tink\core\_Lazy\LazyConst;
use \tink\core\OutcomeTools;
use \tink\core\SimpleLink;
use \tink\core\MPair;
use \tink\core\FutureObject;
use \tink\core\_Outcome\OutcomeMapper_Impl_;

final class Future_Impl_ {
	/**
	 * @var FutureObject
	 */
	static public $NEVER;
	/**
	 * @var FutureObject
	 */
	static public $NOISE;
	/**
	 * @var FutureObject
	 */
	static public $NULL;

	/**
	 * @param FutureObject $f
	 * @param \Closure $map
	 * 
	 * @return FutureObject
	 */
	public static function _flatMap ($f, $map) {
		return $f->flatMap($map)->gather();
	}

	/**
	 * @param FutureObject $f
	 * @param \Closure $map
	 * 
	 * @return FutureObject
	 */
	public static function _map ($f, $map) {
		return $f->map($map)->gather();
	}

	/**
	 * @param \Closure $f
	 * 
	 * @return FutureObject
	 */
	public static function _new ($f) {
		return new SuspendableFuture($f);
	}

	/**
	 * @param FutureObject $f
	 * @param \Closure $map
	 * 
	 * @return FutureObject
	 */
	public static function _tryFailingFlatMap ($f, $map) {
		return $f->flatMap(function ($o) use (&$map) {
			$__hx__switch = ($o->index);
			if ($__hx__switch === 0) {
				return $map($o->params[0]);
			} else if ($__hx__switch === 1) {
				return new SyncFuture(new LazyConst(Outcome::Failure($o->params[0])));
			}
		})->gather();
	}

	/**
	 * @param FutureObject $f
	 * @param \Closure $map
	 * 
	 * @return FutureObject
	 */
	public static function _tryFailingMap ($f, $map) {
		return $f->map(function ($o) use (&$map) {
			return OutcomeTools::flatMap($o, OutcomeMapper_Impl_::withSameError($map));
		})->gather();
	}

	/**
	 * @param FutureObject $f
	 * @param \Closure $map
	 * 
	 * @return FutureObject
	 */
	public static function _tryFlatMap ($f, $map) {
		return $f->flatMap(function ($o) use (&$map) {
			$__hx__switch = ($o->index);
			if ($__hx__switch === 0) {
				return $map($o->params[0])->map(Boot::getStaticClosure(Outcome::class, 'Success'))->gather();
			} else if ($__hx__switch === 1) {
				return new SyncFuture(new LazyConst(Outcome::Failure($o->params[0])));
			}
		})->gather();
	}

	/**
	 * @param FutureObject $f
	 * @param \Closure $map
	 * 
	 * @return FutureObject
	 */
	public static function _tryMap ($f, $map) {
		return $f->map(function ($o) use (&$map) {
			return OutcomeTools::map($o, $map);
		})->gather();
	}

	/**
	 *  Uses `Pair` to merge two futures
	 * 
	 * @param FutureObject $a
	 * @param FutureObject $b
	 * 
	 * @return FutureObject
	 */
	public static function and ($a, $b) {
		return Future_Impl_::merge($a, $b, function ($a, $b) {
			return new MPair($a, $b);
		});
	}

	/**
	 *  Casts a Surprise into a Promise
	 * 
	 * @param FutureObject $s
	 * 
	 * @return FutureObject
	 */
	public static function asPromise ($s) {
		return $s;
	}

	/**
	 *  Creates an async future
	 *  Example: `var i = Future.async(function(cb) cb(1)); // Future<Int>`
	 * 
	 * @param \Closure $f
	 * @param bool $lazy
	 * 
	 * @return FutureObject
	 */
	public static function async ($f, $lazy = false) {
		if ($lazy === null) {
			$lazy = false;
		}
		if ($lazy) {
			return new SuspendableFuture(function ($yield) use (&$f) {
				$f($yield);
				return null;
			});
		} else {
			$op = new FutureTrigger();
			Callback_Impl_::invoke($f, Boot::getInstanceClosure($op, 'trigger'));
			return $op;
		}
	}

	/**
	 * @param int $ms
	 * @param LazyObject $value
	 * 
	 * @return FutureObject
	 */
	public static function delay ($ms, $value) {
		return Future_Impl_::async(function ($cb) use (&$ms, &$value) {
			Timer::delay(function () use (&$cb, &$value) {
				$cb($value->get());
			}, $ms);
		});
	}

	/**
	 *  Same as `first`, but use `Either` to handle the two different types
	 * 
	 * @param FutureObject $a
	 * @param FutureObject $b
	 * 
	 * @return FutureObject
	 */
	public static function either ($a, $b) {
		return Future_Impl_::first($a->map(Boot::getStaticClosure(Either::class, 'Left')), $b->map(Boot::getStaticClosure(Either::class, 'Right')));
	}

	/**
	 *  Creates a future that contains the first result from `this` or `other`
	 * 
	 * @param FutureObject $this
	 * @param FutureObject $other
	 * 
	 * @return FutureObject
	 */
	public static function first ($this1, $other) {
		$ret = new FutureTrigger();
		$l1 = $this1->handle(Boot::getInstanceClosure($ret, 'trigger'));
		$l2 = $other->handle(Boot::getInstanceClosure($ret, 'trigger'));
		$ret1 = $ret;
		if ($l1 !== null) {
			$this1 = $l1;
			$ret1->handle(function ($_) use (&$this1) {
				$this1->cancel();
			});
		}
		if ($l2 !== null) {
			$this2 = $l2;
			$ret1->handle(function ($_) use (&$this2) {
				$this2->cancel();
			});
		}
		return $ret1;
	}

	/**
	 *  Creates a new future by applying a transform function to the result.
	 *  Different from `map`, the transform function of `flatMap` returns a `Future`
	 * 
	 * @param FutureObject $this
	 * @param \Closure $next
	 * @param bool $gather
	 * 
	 * @return FutureObject
	 */
	public static function flatMap ($this1, $next, $gather = true) {
		if ($gather === null) {
			$gather = true;
		}
		$ret = $this1->flatMap($next);
		if ($gather) {
			return $ret->gather();
		} else {
			return $ret;
		}
	}

	/**
	 *  Flattens `Future<Future<A>>` into `Future<A>`
	 * 
	 * @param FutureObject $f
	 * 
	 * @return FutureObject
	 */
	public static function flatten ($f) {
		return new SuspendableFuture(function ($yield) use (&$f) {
			$inner = null;
			$outer = $f->handle(function ($second) use (&$yield, &$inner) {
				$inner = $second->handle($yield);
			});
			return new LinkPair($outer, new SimpleLink(function () use (&$inner) {
				if ($inner !== null) {
					$inner->cancel();
				}
			}));
		});
	}

	/**
	 * @param \Array_hx $futures
	 * 
	 * @return FutureObject
	 */
	public static function fromMany ($futures) {
		return Future_Impl_::ofMany($futures);
	}

	/**
	 * @param mixed $maybeFuture
	 * 
	 * @return bool
	 */
	public static function isFuture ($maybeFuture) {
		return ($maybeFuture instanceof FutureObject);
	}

	/**
	 * @param LazyObject $l
	 * 
	 * @return FutureObject
	 */
	public static function lazy ($l) {
		return new SyncFuture($l);
	}

	/**
	 *  Creates a new future by applying a transform function to the result.
	 *  Different from `flatMap`, the transform function of `map` returns a sync value
	 * 
	 * @param FutureObject $this
	 * @param \Closure $f
	 * @param bool $gather
	 * 
	 * @return FutureObject
	 */
	public static function map ($this1, $f, $gather = true) {
		if ($gather === null) {
			$gather = true;
		}
		$ret = $this1->map($f);
		if ($gather) {
			return $ret->gather();
		} else {
			return $ret;
		}
	}

	/**
	 *  Merges two futures into one by applying the merger function on the two future values
	 * 
	 * @param FutureObject $this
	 * @param FutureObject $other
	 * @param \Closure $merger
	 * @param bool $gather
	 * 
	 * @return FutureObject
	 */
	public static function merge ($this1, $other, $merger, $gather = true) {
		if ($gather === null) {
			$gather = true;
		}
		$gather1 = $gather;
		if ($gather === null) {
			$gather1 = true;
		}
		$ret = $this1->flatMap(function ($t) use (&$other, &$merger) {
			return $other->map(function ($a) use (&$t, &$merger) {
				return $merger($t, $a);
			});
		});
		if ($gather1) {
			return $ret->gather();
		} else {
			return $ret;
		}
	}

	/**
	 *  Like `map` and `flatMap` but with a polymorphic transformer and return a `Promise`
	 *  @see `Next`
	 * 
	 * @param FutureObject $this
	 * @param \Closure $n
	 * 
	 * @return FutureObject
	 */
	public static function next ($this1, $n) {
		return $this1->flatMap(function ($v) use (&$n) {
			return $n($v);
		});
	}

	/**
	 * @param mixed $v
	 * 
	 * @return FutureObject
	 */
	public static function ofAny ($v) {
		return new SyncFuture(new LazyConst($v));
	}

	/**
	 *  Merges multiple futures into Future<Array<A>>
	 * 
	 * @param \Array_hx $futures
	 * @param bool $gather
	 * 
	 * @return FutureObject
	 */
	public static function ofMany ($futures, $gather = true) {
		if ($gather === null) {
			$gather = true;
		}
		$ret = new SyncFuture(new LazyConst(new \Array_hx()));
		$_g = 0;
		while ($_g < $futures->length) {
			unset($f);
			$f = ($futures->arr[$_g++] ?? null);
			$ret = $ret->flatMap(function ($results) use (&$f) {
				return $f->map(function ($result) use (&$results) {
					return $results->concat(\Array_hx::wrap([$result]));
				});
			});
		}
		if ($gather) {
			return $ret->gather();
		} else {
			return $ret;
		}
	}

	/**
	 *  Same as `first`
	 * 
	 * @param FutureObject $a
	 * @param FutureObject $b
	 * 
	 * @return FutureObject
	 */
	public static function or ($a, $b) {
		return Future_Impl_::first($a, $b);
	}

	/**
	 *  Creates a sync future.
	 *  Example: `var i = Future.sync(1); // Future<Int>`
	 * 
	 * @param mixed $v
	 * 
	 * @return FutureObject
	 */
	public static function sync ($v) {
		return new SyncFuture(new LazyConst($v));
	}

	/**
	 *  Creates a new `FutureTrigger`
	 * 
	 * @return FutureTrigger
	 */
	public static function trigger () {
		return new FutureTrigger();
	}

	/**
	 * @internal
	 * @access private
	 */
	static public function __hx__init ()
	{
		static $called = false;
		if ($called) return;
		$called = true;


		self::$NULL = new SyncFuture(new LazyConst(null));
		self::$NOISE = new SyncFuture(new LazyConst(Noise::Noise()));
		self::$NEVER = NeverFuture::$inst;
	}
}

Boot::registerClass(Future_Impl_::class, 'tink.core._Future.Future_Impl_');
Future_Impl_::__hx__init();
