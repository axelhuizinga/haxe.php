<?php
/**
 * Generated by Haxe 4.1.1
 */

namespace tink\core\_Future;

use \php\Boot;
use \tink\core\LinkObject;
use \tink\core\_Callback\Callback_Impl_;
use \tink\core\_Callback\ListCell;
use \tink\core\CallbackList;
use \tink\core\FutureObject;

class SuspendableFuture implements FutureObject {
	/**
	 * @var CallbackList
	 */
	public $callbacks;
	/**
	 * @var LinkObject
	 */
	public $link;
	/**
	 * @var mixed
	 */
	public $result;
	/**
	 * @var bool
	 */
	public $suspended;
	/**
	 * @var \Closure
	 */
	public $wakeup;

	/**
	 * @param \Closure $wakeup
	 * 
	 * @return void
	 */
	public function __construct ($wakeup) {
		$this->suspended = true;
		$_gthis = $this;
		$this->wakeup = $wakeup;
		$this->callbacks = new CallbackList();
		$this->callbacks->ondrain = function () use (&$_gthis) {
			if ($_gthis->callbacks !== null) {
				$_gthis->suspended = true;
				$this1 = $_gthis->link;
				if ($this1 !== null) {
					$this1->cancel();
				}
				$_gthis->link = null;
			}
		};
	}

	/**
	 * @return FutureObject
	 */
	public function eager () {
		$this->handle(Callback_Impl_::fromNiladic(function () {
		}));
		return $this;
	}

	/**
	 * @param \Closure $f
	 * 
	 * @return FutureObject
	 */
	public function flatMap ($f) {
		return Future_Impl_::flatten($this->map($f));
	}

	/**
	 * @return FutureObject
	 */
	public function gather () {
		return $this;
	}

	/**
	 * @param \Closure $callback
	 * 
	 * @return LinkObject
	 */
	public function handle ($callback) {
		if ($this->callbacks === null) {
			Callback_Impl_::invoke($callback, $this->result);
			return null;
		} else {
			$_this = $this->callbacks;
			$node = new ListCell($callback, $_this);
			$_this1 = $_this->cells;
			$_this1->arr[$_this1->length++] = $node;
			$_this->used++;
			if ($this->suspended) {
				$this->suspended = false;
				$this->link = ($this->wakeup)(Boot::getInstanceClosure($this, 'trigger'));
			}
			return $node;
		}
	}

	/**
	 * @param \Closure $f
	 * 
	 * @return FutureObject
	 */
	public function map ($f) {
		$_gthis = $this;
		return new SuspendableFuture(function ($yield) use (&$f, &$_gthis) {
			return $_gthis->handle(function ($res) use (&$f, &$yield) {
				$yield($f($res));
			});
		});
	}

	/**
	 * @param mixed $value
	 * 
	 * @return void
	 */
	public function trigger ($value) {
		$_g = $this->callbacks;
		if ($_g !== null) {
			$this->callbacks = null;
			$this->suspended = false;
			$this->result = $value;
			$this->link = null;
			$this->wakeup = null;
			$_g->invoke($value, true);
		}
	}
}

Boot::registerClass(SuspendableFuture::class, 'tink.core._Future.SuspendableFuture');
