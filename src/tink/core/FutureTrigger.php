<?php
/**
 * Generated by Haxe 4.1.5
 */

namespace tink\core;

use \tink\core\_Future\SyncFuture;
use \php\Boot;
use \tink\core\_Callback\Callback_Impl_;
use \tink\core\_Future\SuspendableFuture;
use \tink\core\_Lazy\LazyConst;
use \tink\core\_Callback\ListCell;

class FutureTrigger implements FutureObject {
	/**
	 * @var CallbackList
	 */
	public $list;
	/**
	 * @var mixed
	 */
	public $result;

	/**
	 * @param FutureObject $f
	 * 
	 * @return FutureObject
	 */
	public static function gatherFuture ($f) {
		return new SuspendableFuture(function ($yield) use (&$f) {
			return $f->handle($yield);
		});
	}

	/**
	 * @return void
	 */
	public function __construct () {
		$this->list = new CallbackList();
	}

	/**
	 * @return FutureObject
	 */
	public function asFuture () {
		return $this;
	}

	/**
	 * @return FutureTrigger
	 */
	public function eager () {
		return $this;
	}

	/**
	 * @param \Closure $f
	 * 
	 * @return FutureObject
	 */
	public function flatMap ($f) {
		if ($this->list === null) {
			return $f($this->result);
		} else {
			$ret = new FutureTrigger();
			$_this = $this->list;
			$node = new ListCell(function ($v) use (&$f, &$ret) {
				$f($v)->handle(Boot::getInstanceClosure($ret, 'trigger'));
			}, $_this);
			$_this1 = $_this->cells;
			$_this1->arr[$_this1->length++] = $node;
			if ($_this->used++ === 0) {
				$_this->onfill();
			}
			return $ret;
		}
	}

	/**
	 * @return FutureTrigger
	 */
	public function gather () {
		return $this;
	}

	/**
	 * @param \Closure $callback
	 * 
	 * @return LinkObject
	 */
	public function handle ($callback) {
		$_g = $this->list;
		if ($_g === null) {
			Callback_Impl_::invoke($callback, $this->result);
			return null;
		} else {
			$node = new ListCell($callback, $_g);
			$_this = $_g->cells;
			$_this->arr[$_this->length++] = $node;
			if ($_g->used++ === 0) {
				$_g->onfill();
			}
			return $node;
		}
	}

	/**
	 * @param \Closure $f
	 * 
	 * @return FutureObject
	 */
	public function map ($f) {
		if ($this->list === null) {
			return new SyncFuture(new LazyConst($f($this->result)));
		} else {
			$ret = new FutureTrigger();
			$_this = $this->list;
			$node = new ListCell(function ($v) use (&$f, &$ret) {
				$ret->trigger($f($v));
			}, $_this);
			$_this1 = $_this->cells;
			$_this1->arr[$_this1->length++] = $node;
			if ($_this->used++ === 0) {
				$_this->onfill();
			}
			return $ret;
		}
	}

	/**
	 *  Triggers a value for this future
	 * 
	 * @param mixed $result
	 * 
	 * @return bool
	 */
	public function trigger ($result) {
		if ($this->list === null) {
			return false;
		} else {
			$list = $this->list;
			$this->list = null;
			$this->result = $result;
			$list->invoke($result, true);
			return true;
		}
	}
}

Boot::registerClass(FutureTrigger::class, 'tink.core.FutureTrigger');
