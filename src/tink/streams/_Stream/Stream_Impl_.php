<?php
/**
 * Generated by Haxe 4.1.4
 */

namespace tink\streams\_Stream;

use \php\Boot;
use \tink\streams\Step;
use \tink\streams\Generator;
use \tink\streams\Single;
use \tink\core\TypedError;
use \tink\streams\StreamObject;
use \tink\core\_Lazy\LazyConst;
use \tink\streams\FutureStream;
use \tink\core\_Promise\Promise_Impl_;
use \tink\core\FutureObject;

final class Stream_Impl_ {

	/**
	 * @param StreamObject $this
	 * 
	 * @return StreamObject
	 */
	public static function dirty ($this1) {
		return $this1;
	}

	/**
	 * @param FutureObject $f
	 * 
	 * @return StreamObject
	 */
	public static function flatten ($f) {
		return new FutureStream($f);
	}

	/**
	 * @param StreamObject $this
	 * 
	 * @return bool
	 */
	public static function get_depleted ($this1) {
		return $this1->get_depleted();
	}

	/**
	 * @param TypedError $e
	 * 
	 * @return StreamObject
	 */
	public static function ofError ($e) {
		return new ErrorStream($e);
	}

	/**
	 * @param object $i
	 * 
	 * @return StreamObject
	 */
	public static function ofIterator ($i) {
		$next = null;
		$next = function ($step) use (&$next, &$i) {
			$next1 = null;
			if ($i->hasNext()) {
				$next2 = $i->next();
				$next1 = Step::Link($next2, Generator::stream($next));
			} else {
				$next1 = Step::End();
			}
			$step($next1);
		};
		return Generator::stream($next);
	}

	/**
	 * @param FutureObject $f
	 * 
	 * @return StreamObject
	 */
	public static function promise ($f) {
		return Stream_Impl_::flatten($f->map(function ($o) {
			$__hx__switch = ($o->index);
			if ($__hx__switch === 0) {
				return Stream_Impl_::dirty($o->params[0]);
			} else if ($__hx__switch === 1) {
				return Stream_Impl_::ofError($o->params[0]);
			}
		})->gather());
	}

	/**
	 * @param FutureObject $f
	 * 
	 * @return StreamObject
	 */
	public static function promiseIdeal ($f) {
		return Stream_Impl_::promise(Promise_Impl_::ofSpecific($f));
	}

	/**
	 * @param FutureObject $f
	 * 
	 * @return StreamObject
	 */
	public static function promiseReal ($f) {
		return Stream_Impl_::promise(Promise_Impl_::ofSpecific($f));
	}

	/**
	 * @param mixed $i
	 * 
	 * @return StreamObject
	 */
	public static function single ($i) {
		return new Single(new LazyConst($i));
	}
}

Boot::registerClass(Stream_Impl_::class, 'tink.streams._Stream.Stream_Impl_');
Boot::registerGetters('tink\\streams\\_Stream\\Stream_Impl_', [
	'depleted' => true
]);
