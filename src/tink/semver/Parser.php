<?php
/**
 * Generated by Haxe 4.1.4
 */

namespace tink\semver;

use \php\_Boot\HxAnon;
use \tink\semver\_Constraint\Constraint_Impl_;
use \php\Boot;
use \tink\semver\_Version\Data as _VersionData;
use \tink\semver\_Parser\Reporter;
use \tink\semver\_Preview\Preview_Impl_;
use \tink\semver\_Version\Version_Impl_;
use \tink\core\OutcomeTools;
use \tink\parse\_StringSlice\Data;
use \tink\parse\_StringSlice\StringSlice_Impl_;
use \tink\parse\_Char\Char_Impl_;
use \tink\parse\ParserBase;

class Parser extends ParserBase {
	/**
	 * @var Data
	 */
	static public $COMMA;
	/**
	 * @var Data
	 */
	static public $DOT;
	/**
	 * @var Data
	 */
	static public $HYPHEN;
	/**
	 * @var Data
	 */
	static public $OR;

	/**
	 * @param Data $s
	 * 
	 * @return void
	 */
	public function __construct ($s) {
		parent::__construct($s, new Reporter($s));
	}

	/**
	 * @param _VersionData $v
	 * 
	 * @return \Array_hx
	 */
	public function carret ($v) {
		return Version_Impl_::range($v, ($v->major === 0 ? ($v->minor === 0 ? Version_Impl_::nextPatch($v) : Version_Impl_::nextMinor($v)) : Version_Impl_::nextMajor($v)));
	}

	/**
	 * @param int $i
	 * 
	 * @return int
	 */
	public function clamp ($i) {
		if ($i < 0) {
			return 0;
		} else {
			return $i;
		}
	}

	/**
	 * @return void
	 */
	public function doSkipIgnored () {
		while (true) {
			$tmp = null;
			if ($this->pos < $this->max) {
				$this1 = $this->source;
				$char = \StringTools::fastCodeAt($this1->string, $this->pos + $this1->start);
				$tmp = (Char_Impl_::$WHITE->data[$char] ?? null);
			} else {
				$tmp = false;
			}
			if (!$tmp) {
				break;
			}
			$this->pos++;
		}
	}

	/**
	 * @param object $p
	 * @param bool $clamped
	 * 
	 * @return _VersionData
	 */
	public function full ($p, $clamped = null) {
		if (($clamped !== true) && ($p->patch < 0)) {
			$this->die("Partial version not allowed", $p->pos);
		}
		$ret = Version_Impl_::_new($p->major, $this->clamp($p->minor), $this->clamp($p->patch));
		if ($p->preview !== null) {
			return new _VersionData($ret->major, $ret->minor, $ret->patch, $p->preview, $p->previewNum);
		} else {
			return $ret;
		}
	}

	/**
	 * @return Data
	 */
	public function ident () {
		$this->skipIgnored();
		$start = $this->pos;
		while (true) {
			$tmp = null;
			if ($this->pos < $this->max) {
				$this1 = $this->source;
				$char = \StringTools::fastCodeAt($this1->string, $this->pos + $this1->start);
				$tmp = (Char_Impl_::$LOWER->data[$char] ?? null);
			} else {
				$tmp = false;
			}
			if (!$tmp) {
				break;
			}
			$this->pos++;
		}
		$this1 = $this->source;
		return StringSlice_Impl_::_new($this1->string, StringSlice_Impl_::wrap($this1, $start) + $this1->start, StringSlice_Impl_::clamp($this1, $this->pos) + $this1->start);
	}

	/**
	 * @param \Closure $f
	 * 
	 * @return \Closure
	 */
	public function lower ($f) {
		return function ($v) use (&$f) {
			return Constraint_Impl_::fromRange(new HxAnon([
				"min" => $f($v),
				"max" => Bound::Unbounded(),
			]));
		};
	}

	/**
	 * @return int
	 */
	public function num () {
		$this->skipIgnored();
		$start = $this->pos;
		while (true) {
			$_g = null;
			if ($this->pos < $this->max) {
				$this1 = $this->source;
				$char = \StringTools::fastCodeAt($this1->string, $this->pos + $this1->start);
				$_g = (Char_Impl_::$DIGIT->data[$char] ?? null);
			} else {
				$_g = false;
			}
			if (!$_g) {
				break;
			}
			$this->pos++;
		}
		$this1 = $this->source;
		$_g = \Std::parseInt(StringSlice_Impl_::_new($this1->string, StringSlice_Impl_::wrap($this1, $start) + $this1->start, StringSlice_Impl_::clamp($this1, $this->pos) + $this1->start)->toString());
		if ($_g === null) {
			return -1;
		} else {
			return $_g;
		}
	}

	/**
	 * @return int
	 */
	public function numX () {
		if ($this->allowHere(StringSlice_Impl_::ofString("x")) || $this->allowHere(StringSlice_Impl_::ofString("X")) || $this->allowHere(StringSlice_Impl_::ofString("*"))) {
			return -1;
		} else {
			return $this->num();
		}
	}

	/**
	 * @return \Array_hx
	 */
	public function parseConstraint () {
		$ret = $this->parseSingle();
		while ($this->allow(Parser::$OR)) {
			$ret = Constraint_Impl_::or($ret, $this->parseSingle());
		}
		return $ret;
	}

	/**
	 * @return _VersionData
	 */
	public function parseInlineVersion () {
		return $this->full($this->parsePartial());
	}

	/**
	 * @return object
	 */
	public function parsePartial () {
		$_gthis = $this;
		$start = $this->pos;
		$next = function () use (&$_gthis) {
			if ($_gthis->allowHere(StringSlice_Impl_::ofString("."))) {
				return $_gthis->num();
			} else {
				return -1;
			}
		};
		$major = $this->num();
		$minor = $next();
		$patch = $next();
		$preview = null;
		$previewNum = -1;
		if (($patch >= 0) && $this->allowHere(Parser::$HYPHEN)) {
			$this->skipIgnored();
			$start1 = $this->pos;
			while (true) {
				$preview1 = null;
				if ($this->pos < $this->max) {
					$this1 = $this->source;
					$char = \StringTools::fastCodeAt($this1->string, $this->pos + $this1->start);
					$preview1 = (Char_Impl_::$LOWER->data[$char] ?? null);
				} else {
					$preview1 = false;
				}
				if (!$preview1) {
					break;
				}
				$this->pos++;
			}
			$this1 = $this->source;
			$preview = OutcomeTools::sure(Preview_Impl_::ofString(StringSlice_Impl_::_new($this1->string, StringSlice_Impl_::wrap($this1, $start1) + $this1->start, StringSlice_Impl_::clamp($this1, $this->pos) + $this1->start)->toString()));
			if ($this->allowHere(Parser::$DOT)) {
				$previewNum = $this->num();
			}
		}
		return new HxAnon([
			"major" => $major,
			"minor" => $minor,
			"patch" => $patch,
			"preview" => $preview,
			"previewNum" => $previewNum,
			"pos" => new \IntIterator($start, $this->pos),
		]);
	}

	/**
	 * @param \Closure $f
	 * 
	 * @return \Array_hx
	 */
	public function parseSimple ($f) {
		$r = $f($this->parseInlineVersion());
		while (true) {
			$cond = Char_Impl_::ofCode(124);
			$this->skipIgnored();
			$tmp = null;
			if ($this->pos < $this->max) {
				$this1 = $this->source;
				$char = \StringTools::fastCodeAt($this1->string, $this->pos + $this1->start);
				$tmp = ($cond->data[$char] ?? null);
			} else {
				$tmp = false;
			}
			if (!(!$tmp && ($this->pos < $this->max))) {
				break;
			}
			$r = Constraint_Impl_::and($r, $this->parseSingle());
		}
		return $r;
	}

	/**
	 * @return \Array_hx
	 */
	public function parseSingle () {
		$this->skipIgnored();
		if ($this->allowHere(StringSlice_Impl_::ofString("*"))) {
			return null;
		} else if ($this->allowHere(StringSlice_Impl_::ofString(">="))) {
			return $this->parseSimple($this->lower(Boot::getStaticClosure(Bound::class, 'Inclusive')));
		} else if ($this->allowHere(StringSlice_Impl_::ofString(">"))) {
			return $this->parseSimple($this->lower(Boot::getStaticClosure(Bound::class, 'Exlusive')));
		} else if ($this->allowHere(StringSlice_Impl_::ofString("<="))) {
			return $this->parseSimple($this->upper(Boot::getStaticClosure(Bound::class, 'Inclusive')));
		} else if ($this->allowHere(StringSlice_Impl_::ofString("<"))) {
			return $this->parseSimple($this->upper(Boot::getStaticClosure(Bound::class, 'Exlusive')));
		} else if ($this->allowHere(StringSlice_Impl_::ofString("="))) {
			return Constraint_Impl_::exact($this->parseInlineVersion());
		} else if ($this->allowHere(StringSlice_Impl_::ofString("^"))) {
			return $this->parseSimple(Boot::getInstanceClosure($this, 'carret'));
		} else {
			$p = $this->parsePartial();
			if ($this->allow(Parser::$HYPHEN)) {
				$tmp = Bound::Inclusive($this->full($p));
				$this->skipIgnored();
				return Constraint_Impl_::fromRange(new HxAnon([
					"min" => $tmp,
					"max" => Bound::Inclusive($this->parseInlineVersion()),
				]));
			} else if ($p->patch < 0) {
				$v = $this->full($p, true);
				return Version_Impl_::range($v, ($p->minor < 0 ? Version_Impl_::nextMajor($v) : Version_Impl_::nextMinor($v)));
			} else {
				return Constraint_Impl_::ofVersion($this->full($p));
			}
		}
	}

	/**
	 * @return _VersionData
	 */
	public function parseVersion () {
		$ret = $this->parseInlineVersion();
		$this->skipIgnored();
		if ($this->pos === $this->max) {
			return $ret;
		} else {
			return $this->die("Unexpected string", new \IntIterator($this->pos, $this->max));
		}
	}

	/**
	 * @param \Closure $f
	 * 
	 * @return \Closure
	 */
	public function upper ($f) {
		return function ($v) use (&$f) {
			return Constraint_Impl_::fromRange(new HxAnon([
				"min" => Bound::Unbounded(),
				"max" => $f($v),
			]));
		};
	}

	/**
	 * @internal
	 * @access private
	 */
	static public function __hx__init ()
	{
		static $called = false;
		if ($called) return;
		$called = true;


		self::$OR = StringSlice_Impl_::ofString("||");
		self::$DOT = StringSlice_Impl_::ofString(".");
		self::$HYPHEN = StringSlice_Impl_::ofString("-");
		self::$COMMA = StringSlice_Impl_::ofString(",");
	}
}

Boot::registerClass(Parser::class, 'tink.semver.Parser');
Parser::__hx__init();
