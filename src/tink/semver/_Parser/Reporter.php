<?php
/**
 * Generated by Haxe 4.1.4
 */

namespace tink\semver\_Parser;

use \php\_Boot\HxAnon;
use \php\Boot;
use \tink\core\TypedError;
use \tink\parse\_StringSlice\Data;
use \tink\parse\_StringSlice\StringSlice_Impl_;
use \tink\parse\ReporterObject;

class Reporter implements ReporterObject {
	/**
	 * @var Data
	 */
	public $source;

	/**
	 * @param Data $source
	 * 
	 * @return void
	 */
	public function __construct ($source) {
		$this->source = $source;
	}

	/**
	 * @param string $message
	 * @param \IntIterator $pos
	 * 
	 * @return TypedError
	 */
	public function makeError ($message, $pos) {
		$this1 = $this->source;
		$tmp = StringSlice_Impl_::_new($this1->string, StringSlice_Impl_::wrap($this1, $pos->min) + $this1->start, StringSlice_Impl_::clamp($this1, $pos->max) + $this1->start);
		$tmp1 = "" . ($message??'null') . " at " . ("\"" . ((($tmp === null ? "null" : $tmp->toString()))??'null') . "\"(" . ($pos->min??'null') . "-" . ($pos->max??'null') . ")");
		$tmp = ($this->source === null ? "null" : $this->source->toString());
		return new TypedError(null, ($tmp1??'null') . (" in \"" . ($tmp??'null') . "\""), new HxAnon([
			"fileName" => "tink/semver/Parser.hx",
			"lineNumber" => 23,
			"className" => "tink.semver._Parser.Reporter",
			"methodName" => "makeError",
		]));
	}

	/**
	 * @param int $from
	 * @param int $to
	 * 
	 * @return \IntIterator
	 */
	public function makePos ($from, $to) {
		return new \IntIterator($from, $to);
	}
}

Boot::registerClass(Reporter::class, 'tink.semver._Parser.Reporter');
